input,subject,relation,object
本章将围绕知识图谱推理展开介绍，6.1节从广义的推理角度介绍什么是推理以及推理的不同类型，并附以不同推理的实例以及不同推理之间的比较，再介绍知识图谱推理的定义及包含的任务。,知识图谱推理,包含,推理的不同类型
本章将围绕知识图谱推理展开介绍，6.1节从广义的推理角度介绍什么是推理以及推理的不同类型，并附以不同推理的实例以及不同推理之间的比较，再介绍知识图谱推理的定义及包含的任务。,知识图谱推理,包含,推理的定义及包含的任务
推理的方法大致可以分为逻辑推理和非逻辑推理，其中逻辑推理的过程包含了严格的约束和推理过程，而非逻辑推理的过程相对模糊。,推理,包含,逻辑推理
推理的方法大致可以分为逻辑推理和非逻辑推理，其中逻辑推理的过程包含了严格的约束和推理过程，而非逻辑推理的过程相对模糊。,推理,包含,非逻辑推理
逻辑推理按照推理方式的不同包含两大类：演绎推理（Deductive_Reasoning）和归纳推理（Inductive_Reasoning）。,逻辑推理,包含,演绎推理
逻辑推理按照推理方式的不同包含两大类：演绎推理（Deductive_Reasoning）和归纳推理（Inductive_Reasoning）。,逻辑推理,包含,归纳推理
其中，归纳推理又包含了溯因推理（Abductive_Reasoning）和类比推理（Analogy_Reasoning）等。,归纳推理,包含,溯因推理
其中，归纳推理又包含了溯因推理（Abductive_Reasoning）和类比推理（Analogy_Reasoning）等。,归纳推理,包含,类比推理
演绎推理[1]是一种自上而下（top-down_logic）的逻辑推理，是指在给定的一个或多个前提的情况下，推断出一个必然成立的结论的过程。,演绎推理,包含,自上而下（top-down_logic）的逻辑推理
其中，肯定前件假言推理是指性质命题肯定了假言命题的前件，从而推理出肯定的假言后件。,肯定前件假言推理,包含,性质命题肯定了假言命题的前件
其中，肯定前件假言推理是指性质命题肯定了假言命题的前件，从而推理出肯定的假言后件。,肯定前件假言推理,包含,推理出肯定的假言后件
而否定后件假言推理是指性质命题否定了假言命题的后件，从而推理出否定的假言前件。,否定后件假言推理,包含,性质命题否定了假言命题的后件
归纳推理[2]是一种自下而上的推理，是指基于已有的部分观察得出一般结论的过程。,归纳推理,包含,自下而上的推理
归纳推理[2]是一种自下而上的推理，是指基于已有的部分观察得出一般结论的过程。,归纳推理,包含,基于已有的部分观察得出一般结论的过程
归纳泛化是指基于对个体的观察而得出可能适用于整体的结论，即在整体的一些样本中得到的结论可以泛化到整体上。,归纳泛化,包含,基于对个体的观察而得出可能适用于整体的结论
可以从20个球中抽样4个球，如果发现4个球中有3个白色和1个黑色，那么可以通过归纳泛化推理出这20个球中可能有15个球是白色的，5个球是黑色的。,归纳泛化推理,包含,从20个球中抽样4个球
溯因推理[3]也是一种逻辑推理，是在给定一个或多个已有观察事实O（Observation），并根据已有的知识T（Theory）推断出对已有观察最简单且最有可能的解释的过程。,溯因推理,包含,逻辑推理
溯因推理[3]也是一种逻辑推理，是在给定一个或多个已有观察事实O（Observation），并根据已有的知识T（Theory）推断出对已有观察最简单且最有可能的解释的过程。,溯因推理,包含,根据已有的知识推断出对已有观察最简单且最有可能的解释的过程
在溯因推理中，要使基于知识T而生成的对观察O的解释E是合理的，需要满足两个条件，一是E可以由T和O经过推理得出，可以是演绎、归纳推理等多种方式；二是E和T是相关且相容的。,溯因推理,包含,要使基于知识T而生成的对观察O的解释E是合理的两个条件
例如，我们知道下雨了马路一定会湿（T），如果观察到马路是湿的（O），可以通过溯因推理得到很大概率是因为下雨了（E）。,下雨了马路一定会湿,包含,如果观察到马路是湿的
例如，我们知道下雨了马路一定会湿（T），如果观察到马路是湿的（O），可以通过溯因推理得到很大概率是因为下雨了（E）。,下雨了,包含,很大概率是因为下雨了
类比推理[4]可以看作只基于对一个事物的观察而进行的对另一个事物的归纳推理，是通过寻找两者之间可以类比的信息，将已知事物上的结论迁移到新的事物上的过程。,类比推理,包含,只基于对一个事物的观察而进行的对另一个事物的归纳推理
类比推理[4]可以看作只基于对一个事物的观察而进行的对另一个事物的归纳推理，是通过寻找两者之间可以类比的信息，将已知事物上的结论迁移到新的事物上的过程。,类比推理,包含,通过寻找两者之间可以类比的信息
类比推理[4]可以看作只基于对一个事物的观察而进行的对另一个事物的归纳推理，是通过寻找两者之间可以类比的信息，将已知事物上的结论迁移到新的事物上的过程。,类比推理,包含,将已知事物上的结论迁移到新的事物上的过程
例如在上例中，如果歌手C和歌手A、歌手B完全不是一种类型或一个领域的歌手，那么小明喜欢歌手C与他喜欢歌手A和歌手B是完全无关的，所以将“喜欢歌手C”的结论应用到小红身上不合适。,喜欢歌手C,包含,歌手C
例如在上例中，如果歌手C和歌手A、歌手B完全不是一种类型或一个领域的歌手，那么小明喜欢歌手C与他喜欢歌手A和歌手B是完全无关的，所以将“喜欢歌手C”的结论应用到小红身上不合适。,喜欢歌手A和歌手B,包含,歌手A和歌手B
又例如在知识演变的过程中，根据原有的推论可否被推翻可以分为不会被推翻的单调推理以及可能会被推翻的非单调推理。,推论,包含,根据原有的推论可否被推翻
"如图6-1所示为人物关系图推理，利用推理可以得到新的事实(X,isFatherOf,M)，以及得到规则isFatherOf(x,y)<=fatherIs(y,x)等。",人物关系图推理,包含,"新的事实(X,isFatherOf,M)"
"如图6-1所示为人物关系图推理，利用推理可以得到新的事实(X,isFatherOf,M)，以及得到规则isFatherOf(x,y)<=fatherIs(y,x)等。",人物关系图推理,包含,"规则isFatherOf(x,y)<=fatherIs(y,x)"
将不同且相关的知识图谱融合为一个是一种有效地完善和扩大知识图谱的方式，而融合的过Alignment）[7]和关系对齐（Relation程包含两个重要的推理任务：有实体对齐（Entity_Alignment），关系对齐也叫作属性对齐（Property_Alignment）。,融合的过,包含,知识图谱融合为一个
将不同且相关的知识图谱融合为一个是一种有效地完善和扩大知识图谱的方式，而融合的过Alignment）[7]和关系对齐（Relation程包含两个重要的推理任务：有实体对齐（Entity_Alignment），关系对齐也叫作属性对齐（Property_Alignment）。,融合的过,包含,有效地完善和扩大知识图谱的方式
即识别出分别存在两个知识图谱中的两个实体实际上表示的是同一个实体，或者两个关系是同一种语义的关系，从而在知识图谱中将其对齐，形成一个统一的实体或关系。,概念/知识图谱对齐,包含,识别出分别存在两个知识图谱中的两个实体实际上表示的是同一个实体
即识别出分别存在两个知识图谱中的两个实体实际上表示的是同一个实体，或者两个关系是同一种语义的关系，从而在知识图谱中将其对齐，形成一个统一的实体或关系。,概念/知识图谱对齐,包含,两个关系是同一种语义的关系
存储了众多知识的知识图谱的一个重要作用是提供知识服务，为相关的查询返回正确的相关知识信息，但查询的模糊以及知识图谱本身的语义丰富性容易造成查询困难，而推理有利于查询重写，有效地提升查询结果的质量。,知识图谱,包含,知识服务
表6-1OWL成员与描述逻辑之间的对应关系基于OWL的模型论语义，在丰富逻辑描述的知识图谱中，除了包含实体和二元关系，还包含了许多更抽象的信息，例如描述实体类别的概念以及关系之间的从属信息等。,知识图谱,包含,实体
表6-1OWL成员与描述逻辑之间的对应关系基于OWL的模型论语义，在丰富逻辑描述的知识图谱中，除了包含实体和二元关系，还包含了许多更抽象的信息，例如描述实体类别的概念以及关系之间的从属信息等。,知识图谱,包含,二元关系
从而有一系列实用有趣的推理问题，包括：（1）概念包含。,推理问题,包含,概念包含
例如，在包含公理Mother⊑Women和Women⊑Person的本体中，可以判定Mother⊑Person成立。,本体,包含,公理Mother⊑Women
例如，在包含公理Mother⊑Women和Women⊑Person的本体中，可以判定Mother⊑Person成立。,本体,包含,公理Women⊑Person
例如，在包含Man⊓Women⊑⊥的本体中，概念Man和Women是互斥的。,Man,包含,概念Man
例如，在包含Man⊓Women⊑⊥的本体中，概念Man和Women是互斥的。,Women,包含,概念Women
例如，包含公理Eternity⊑⊥的本体中，概念Eternity是不可满足概念。,本体中,包含,公理Eternity⊑⊥
例如，包含公理Eternity⊑⊥的本体中，概念Eternity是不可满足概念。,本体中,包含,概念Eternity
例如，包含公理Man⊓Women⊑⊥、Man（Allen）和Women（Allen）的本体是不一致的。,本体,包含,公理Man⊓Women⊑⊥
例如，包含公理Man⊓Women⊑⊥、Man（Allen）和Women（Allen）的本体是不一致的。,本体,包含,Man（Allen）
例如，包含公理Man⊓Women⊑⊥、Man（Allen）和Women（Allen）的本体是不一致的。,本体,包含,Women（Allen）
例如，包含公理Man⊓Women⊑⊥、Professor⊑Man和Professor⊑Women的TBox是不一致的。,TBox,包含,公理Man⊓Women⊑⊥
例如，包含公理Man⊓Women⊑⊥、Professor⊑Man和Professor⊑Women的TBox是不一致的。,TBox,包含,Professor⊑Man
例如，包含公理Man⊓Women⊑⊥、Professor⊑Man和Professor⊑Women的TBox是不一致的。,TBox,包含,Professor⊑Women
找出概念C在给定知识库中的所有实例，需要找出属于C的所有个体a，即C(a)是给定知识库的逻辑结论。,C,包含,a
"例如，如果=｛D｝而且通过←C来对进行更新，那么将变成{C,D}。",O,包含,C
以描述逻辑为例，在初始情况下，是原始的Abox，迭代运用如下规则：其中，y是新加进来的个体。,初始情况,包含,原始的Abox
以描述逻辑为例，在初始情况下，是原始的Abox，迭代运用如下规则：其中，y是新加进来的个体。,规则,包含,其中，y是新加进来的个体。
"给定包含如下公理和断言的本体：Man⊓Women⊑⊥,Man(Allen)，检测实例Allen是否Woman_Woman(Allen)，根据⊓−−规则，在Man⊓Women（Allen）加入中，再通过⊑−规则得到⊥(Allen)，这样就得到了一个矛盾，中。",初始情况,包含,原始的Abox
"给定包含如下公理和断言的本体：Man⊓Women⊑⊥,Man(Allen)，检测实例Allen是否Woman_Woman(Allen)，根据⊓−−规则，在Man⊓Women（Allen）加入中，再通过⊑−规则得到⊥(Allen)，这样就得到了一个矛盾，中。",规则,包含,其中，y是新加进来的个体。
"给定包含如下公理和断言的本体：Man⊓Women⊑⊥,Man(Allen)，检测实例Allen是否Woman_Woman(Allen)，根据⊓−−规则，在Man⊓Women（Allen）加入中，再通过⊑−规则得到⊥(Allen)，这样就得到了一个矛盾，中。",本体,包含,公理和断言
为了提高Tableaux算法的效率，研究者提出了不少优化技术[20-22]，使该算法对于中小型描述逻辑知识库的推理达到了实用化的程度。,Tableaux算法,包含,提高该算法对于中小型描述逻辑知识库的推理
"逻辑编程的研究始于Prolog语言[24,25]，后来由ISO标准化。",逻辑编程,包含,Prolog语言
Prolog在多种系统中被实现，例如SWI-Prolog、Sicstus_Prolog、GNU_Prolog和XSB。,Prolog,包含,SWI-Prolog
Prolog在多种系统中被实现，例如SWI-Prolog、Sicstus_Prolog、GNU_Prolog和XSB。,Prolog,包含,Sicstus_Prolog
Prolog在多种系统中被实现，例如SWI-Prolog、Sicstus_Prolog、GNU_Prolog和XSB。,Prolog,包含,GNU_Prolog
Prolog在多种系统中被实现，例如SWI-Prolog、Sicstus_Prolog、GNU_Prolog和XSB。,Prolog,包含,XSB
在通常情况下，Prolog程序是通过SLD消解和回溯来执行的[25]。,Prolog程序,包含,SLD消解
在通常情况下，Prolog程序是通过SLD消解和回溯来执行的[25]。,Prolog程序,包含,回溯
运行结果依赖对规则内部的原子顺序和规则之间的顺序，因此不是完全的声明式的（declarative）。,运行结果,包含,非完全的声明式
"原子（atom）形如p(t1,…,tn），其中p是一个谓词，t1,…,tn为项，n被称为p的元数。",原子,包含,"p(t1,…,tn）"
"例如，假定has_child为一个二元谓词，原子has_child(X,Y)表示变量X和Y有has_child的关系，而原子has_child(jim,bob)表示常量jim和bob有has_child的关系。",has_child,包含,原子
"H称为此规则的头部原子，B1,B2,…,Bm称为体部原子。",H,包含,头部原子
"H称为此规则的头部原子，B1,B2,…,Bm称为体部原子。",B1,包含,体部原子
"例如，规则has_child(Y,X):-has_son(X,Y)表示当X和Y有has_son的关系时，则Y与X有has_child的关系。",规则,包含,has_child
"例如，规则has_child(Y,X):-has_son(X,Y)表示当X和Y有has_son的关系时，则Y与X有has_child的关系。",规则,包含,has_son
"例如，上面的关于图联通的例子，结果集为{path(a,b).path(b,c).path(a,c).path(d,e).edge(a,b).edge(b,c).edge(d,e)}，如图6-3所示。",图联通,包含,"path(a,b)"
"例如，上面的关于图联通的例子，结果集为{path(a,b).path(b,c).path(a,c).path(d,e).edge(a,b).edge(b,c).edge(d,e)}，如图6-3所示。",图联通,包含,"path(b,c)"
"例如，上面的关于图联通的例子，结果集为{path(a,b).path(b,c).path(a,c).path(d,e).edge(a,b).edge(b,c).edge(d,e)}，如图6-3所示。",图联通,包含,"path(a,c)"
"例如，上面的关于图联通的例子，结果集为{path(a,b).path(b,c).path(a,c).path(d,e).edge(a,b).edge(b,c).edge(d,e)}，如图6-3所示。",图联通,包含,"path(d,e)"
"例如，上面的关于图联通的例子，结果集为{path(a,b).path(b,c).path(a,c).path(d,e).edge(a,b).edge(b,c).edge(d,e)}，如图6-3所示。",图联通,包含,"edge(a,b)"
"例如，上面的关于图联通的例子，结果集为{path(a,b).path(b,c).path(a,c).path(d,e).edge(a,b).edge(b,c).edge(d,e)}，如图6-3所示。",图联通,包含,"edge(b,c)"
"例如，上面的关于图联通的例子，结果集为{path(a,b).path(b,c).path(a,c).path(d,e).edge(a,b).edge(b,c).edge(d,e)}，如图6-3所示。",图联通,包含,"edge(d,e)"
下面介绍的三种语言SWRL、OWL_RL、RDFS与Datalog密切相关。,SWRL,包含,Datalog
下面介绍的三种语言SWRL、OWL_RL、RDFS与Datalog密切相关。,OWL_RL,包含,Datalog
下面介绍的三种语言SWRL、OWL_RL、RDFS与Datalog密切相关。,RDFS,包含,Datalog
SWRL规则形如Datalog，只是限制原子的谓词必须是本体中的概念或者属性。,SWRL规则,包含,Datalog
SWRL规则形如Datalog，只是限制原子的谓词必须是本体中的概念或者属性。,SWRL规则,包含,限制原子的谓词必须是本体中的概念或者属性
知识图谱领域也有多个系统，包括KAON2[7]、HermiT[8]、Pellet[9]、Stardog[10]、RDFox[11]等，支持RL或者SWRL推理。,知识图谱推理系统,包含,KAON2
知识图谱领域也有多个系统，包括KAON2[7]、HermiT[8]、Pellet[9]、Stardog[10]、RDFox[11]等，支持RL或者SWRL推理。,知识图谱推理系统,包含,HermiT
知识图谱领域也有多个系统，包括KAON2[7]、HermiT[8]、Pellet[9]、Stardog[10]、RDFox[11]等，支持RL或者SWRL推理。,知识图谱推理系统,包含,Pellet
知识图谱领域也有多个系统，包括KAON2[7]、HermiT[8]、Pellet[9]、Stardog[10]、RDFox[11]等，支持RL或者SWRL推理。,知识图谱推理系统,包含,Stardog
知识图谱领域也有多个系统，包括KAON2[7]、HermiT[8]、Pellet[9]、Stardog[10]、RDFox[11]等，支持RL或者SWRL推理。,知识图谱推理系统,包含,RDFox
表6-3Datalog相关工具总结RDFox是由牛津大学开发的可扩展、跨平台、基于内存的RDF三元组存储系统。,RDFox,包含,可扩展、跨平台、基于内存的RDF三元组存储系统
其最主要的特点是支持基于内存的高效并行Datalog推理，同时也支持SPARQL查询。,OWL_Reasoner,包含,基于内存的高效并行Datalog推理
其最主要的特点是支持基于内存的高效并行Datalog推理，同时也支持SPARQL查询。,OWL_Reasoner,包含,SPARQL查询
将结果输出为结合规则推理的所有三元组实例化。,结合规则推理,包含,三元组实例化
OMQ可以看作OBDA的特殊情况，即每个本体中谓词的实例都存储在一个特定的对应表中，而映射只是一个简单的同构关系。,OMQ,包含,OBDA的特殊情况
1.OBDA框架OBDA框架包含外延（extensional）和内涵（intensional）两个部分。,OBDA框架,包含,外延
1.OBDA框架OBDA框架包含外延（extensional）和内涵（intensional）两个部分。,OBDA框架,包含,内涵
将SPARQL利用映射M展开，把每一个查询中的谓词替换成映射中的定义，生成SQL语句查询[30]。,SPARQL,包含,查询中的谓词
通过层次关系和定义域可以被重写为q1'=请注意q1’包括了所有的已知教师和所有有教学任务的人。,q1,包含,所有的已知教师和所有有教学任务的人
4.相关工具介绍基于查询重写的推理机有多个，例如Ontop[12]Mastro[13]、Stardog[14]、Ultrawrap[15]、Morph[16]。,基于查询重写的推理机,包含,Ontop
4.相关工具介绍基于查询重写的推理机有多个，例如Ontop[12]Mastro[13]、Stardog[14]、Ultrawrap[15]、Morph[16]。,基于查询重写的推理机,包含,Mastro
4.相关工具介绍基于查询重写的推理机有多个，例如Ontop[12]Mastro[13]、Stardog[14]、Ultrawrap[15]、Morph[16]。,基于查询重写的推理机,包含,Stardog
4.相关工具介绍基于查询重写的推理机有多个，例如Ontop[12]Mastro[13]、Stardog[14]、Ultrawrap[15]、Morph[16]。,基于查询重写的推理机,包含,Ultrawrap
4.相关工具介绍基于查询重写的推理机有多个，例如Ontop[12]Mastro[13]、Stardog[14]、Ultrawrap[15]、Morph[16]。,基于查询重写的推理机,包含,Morph
它被扩展为支持对具有反向和传递属性的RDFS扩展的推断。,OWL_2_RDFS,包含,支持对具有反向和传递属性的RDFS扩展的推断
6.2.4基于产生式规则的方法1.产生式系统产生式系统是一种前向推理系统，可以按照一定机制执行规则并达到某些目标，与一阶逻辑类似，也有区别。,产生式系统,包含,一阶逻辑
"事实集合是运行内存（Working_Memory,WM）为事实（WME）的集合，用于存储当前系统中的所有事实。",事实集合,包含,"运行内存（Working_Memory,WM）为事实（WME）"
事实可描述对象，形如(typeattr_1:val_1attr_2:val_2…attr_n:val_n），其中type、attr_i、val_i均为原子（常量）。,事实对象的类型属性,包含,type
事实可描述对象，形如(typeattr_1:val_1attr_2:val_2…attr_n:val_n），其中type、attr_i、val_i均为原子（常量）。,事实对象的类型属性,包含,attr_i
事实可描述对象，形如(typeattr_1:val_1attr_2:val_2…attr_n:val_n），其中type、attr_i、val_i均为原子（常量）。,事实对象的类型属性,包含,val_i
产生式形如：●IFconditionsTHENactions其中，conditions是由条件组成的集合，又称为LHS;actions是由动作组成的序列，又称为RHS。,产生式,包含,conditions
产生式形如：●IFconditionsTHENactions其中，conditions是由条件组成的集合，又称为LHS;actions是由动作组成的序列，又称为RHS。,产生式,包含,actions
其中，spec_i表示对attr_i的约束，形式可取下列中的一种：●原子，如：Alice(personname:Alice)●变量，如：x(personname:x)●表达式，如：[n+4](personage:[n+4])●布尔测试，如：{>10}(personage:{>10})●约束的与、或、非操作RHS是action的序列，执行时依次执行。,spec_i,包含,对attr_i的约束
动作的种类有如下三种：●ADDpattern。,动作的种类,包含,ADDpattern
例如，产生式IF(Studentname:)ThenADD(Personname:)表示如果有一个学生名为？x，则向事实集加入一个事实，表示有一个名为？x的人。,产生式,包含,IF(Studentname:)ThenADD(Personname:)
产生式具体语法因不同系统而异，某些系统中此产生式亦可写作(Studentname:x)⇒ADD(Personname:x)。,产生式具体语法,包含,不同系统
图6-7产生式系统执行流程产生式系统主要有三个部分：●模式匹配。,产生式系统,包含,模式匹配
模式匹配用每条规则的条件部分匹配当前的WM，如图6-8所示为匹配规则过程。,规则的条件部分,包含,匹配当前的WM
"规则为：（typexy）,(subClassOfyz)⇒ADD(typexz)。",typexy,包含,ADD(typexz)
"规则为：（typexy）,(subClassOfyz)⇒ADD(typexz)。",subClassOfyz,包含,ADD(typexz)
图6-9Rete网络图6-10Rete算法的匹配过程选择规则从被触发的多条规则中选择一条执行，常用的策略有：●随机选择。,Rete网络,包含,Rete算法的匹配过程
选择最具体的规则，例如下面的第二条规则比第一条更具体，故当同时满足时触发第二条：(Studentname:)⇒…(Studentname:age:20)⇒…●新近程度（recency）。,具体的规则,包含,第二条规则
选择最具体的规则，例如下面的第二条规则比第一条更具体，故当同时满足时触发第二条：(Studentname:)⇒…(Studentname:age:20)⇒…●新近程度（recency）。,第一条规则,包含,第二条规则
4.相关工具介绍表6-5为三个基于产生式规则的系统，它们都是基于Rete算法或其改进的。,基于产生式规则的系统,包含,基于Rete算法或其改进的
提供三元组的内存存储于SPARQL、查询。,SPARQL,包含,内存存储于SPARQL、查询
GraphDB（原OWLIM）是一个可扩展的语义数据存储系统（基于RDF4J），其功能包含三元组存储、推理引擎、查询引擎，支持RDFS、OWL_DLP、OWL_Horst、OWL_2_RL等多种语言。,GraphDB,包含,三元组存储
GraphDB（原OWLIM）是一个可扩展的语义数据存储系统（基于RDF4J），其功能包含三元组存储、推理引擎、查询引擎，支持RDFS、OWL_DLP、OWL_Horst、OWL_2_RL等多种语言。,GraphDB,包含,推理引擎
GraphDB（原OWLIM）是一个可扩展的语义数据存储系统（基于RDF4J），其功能包含三元组存储、推理引擎、查询引擎，支持RDFS、OWL_DLP、OWL_Horst、OWL_2_RL等多种语言。,GraphDB,包含,查询引擎
GraphDB（原OWLIM）是一个可扩展的语义数据存储系统（基于RDF4J），其功能包含三元组存储、推理引擎、查询引擎，支持RDFS、OWL_DLP、OWL_Horst、OWL_2_RL等多种语言。,GraphDB,包含,语义数据存储系统
GraphDB（原OWLIM）是一个可扩展的语义数据存储系统（基于RDF4J），其功能包含三元组存储、推理引擎、查询引擎，支持RDFS、OWL_DLP、OWL_Horst、OWL_2_RL等多种语言。,GraphDB,包含,RDFS
GraphDB（原OWLIM）是一个可扩展的语义数据存储系统（基于RDF4J），其功能包含三元组存储、推理引擎、查询引擎，支持RDFS、OWL_DLP、OWL_Horst、OWL_2_RL等多种语言。,GraphDB,包含,OWL_DLP
GraphDB（原OWLIM）是一个可扩展的语义数据存储系统（基于RDF4J），其功能包含三元组存储、推理引擎、查询引擎，支持RDFS、OWL_DLP、OWL_Horst、OWL_2_RL等多种语言。,GraphDB,包含,OWL_Horst
GraphDB（原OWLIM）是一个可扩展的语义数据存储系统（基于RDF4J），其功能包含三元组存储、推理引擎、查询引擎，支持RDFS、OWL_DLP、OWL_Horst、OWL_2_RL等多种语言。,GraphDB,包含,OWL_2_RL
GraphDB（原OWLIM）是一个可扩展的语义数据存储系统（基于RDF4J），其功能包含三元组存储、推理引擎、查询引擎，支持RDFS、OWL_DLP、OWL_Horst、OWL_2_RL等多种语言。,GraphDB,包含,多种语言
基于归纳的知识图谱推理主要是通过对知识图谱已有信息的分析和挖掘进行推理的，最常用的信息为已有的三元组。,基于归纳的知识图谱推理,包含,已有的三元组
按照推理要素的不同，基于归纳的知识图谱推理可以分为以下几类：基于图结构的推理、基于规则学习的推理和基于表示学习的推理。,基于归纳的知识图谱推理,包含,基于图结构的推理
按照推理要素的不同，基于归纳的知识图谱推理可以分为以下几类：基于图结构的推理、基于规则学习的推理和基于表示学习的推理。,基于归纳的知识图谱推理,包含,基于规则学习的推理
按照推理要素的不同，基于归纳的知识图谱推理可以分为以下几类：基于图结构的推理、基于规则学习的推理和基于表示学习的推理。,基于归纳的知识图谱推理,包含,基于表示学习的推理
对于这些三元组，从图的角度来看，可以看作是标签的有向图，有向图以实体为节点，以关系为有向边，并且每个关系边从头实体的节点指向尾实体的节点，如图6-11所示。,三元组,包含,关系边
例如，上面的示例中描述了不同人物之间的关系以及人物的职业信息，包含了如下的路径：这是一条从实体小明到实体小小的路径，表述的信息是小明的妻子是小红，小红的孩子有小小。,路径,包含,这是一条从实体小明到实体小小的路径，表述的信息是小明的妻子是小红，小红的孩子有小小。
从语义角度来看，这条由关系“妻子是”和“孩子有”组成的路径揭示了小明和小小之间的父子关系，这条路径蕴涵着三元组：而这个推理过程不仅仅存在于这个包含小明、小红和小小的子图中，同样也存在于建国、秀娟和小明的子图中，而路径和三元组是常常同时出现在知识图谱中的。,路径,包含,小明和小小之间的父子关系
从语义角度来看，这条由关系“妻子是”和“孩子有”组成的路径揭示了小明和小小之间的父子关系，这条路径蕴涵着三元组：而这个推理过程不仅仅存在于这个包含小明、小红和小小的子图中，同样也存在于建国、秀娟和小明的子图中，而路径和三元组是常常同时出现在知识图谱中的。,路径,包含,这条路径蕴涵着三元组：
其中A、B、C是三个代表关系的变量，由“妻子是”和“孩子有”两种关系组成的路径与关系“孩子有”在图谱中是经常共现的，且其共现与A、B、C具体是什么实体没有关系。,路径与关系“孩子有”,包含,A、B、C
除了路径，实体的邻居节点以及它们之间的关系也是刻画和描述一个实体的重要信息，例如在上例中的关于“小明”的7个三元组鲜明地描述了小明这个人物，包括（小明，父亲是，建国）、（小明，获得奖项，最佳男主角）以及（小明，妻子是，小红）等。,小明,中文名,建国
除了路径，实体的邻居节点以及它们之间的关系也是刻画和描述一个实体的重要信息，例如在上例中的关于“小明”的7个三元组鲜明地描述了小明这个人物，包括（小明，父亲是，建国）、（小明，获得奖项，最佳男主角）以及（小明，妻子是，小红）等。,小明,中文名,最佳男主角
除了路径，实体的邻居节点以及它们之间的关系也是刻画和描述一个实体的重要信息，例如在上例中的关于“小明”的7个三元组鲜明地描述了小明这个人物，包括（小明，父亲是，建国）、（小明，获得奖项，最佳男主角）以及（小明，妻子是，小红）等。,小明,中文名,小红
除了路径，实体的邻居节点以及它们之间的关系也是刻画和描述一个实体的重要信息，例如在上例中的关于“小明”的7个三元组鲜明地描述了小明这个人物，包括（小明，父亲是，建国）、（小明，获得奖项，最佳男主角）以及（小明，妻子是，小红）等。,小明,中文名,建国
除了路径，实体的邻居节点以及它们之间的关系也是刻画和描述一个实体的重要信息，例如在上例中的关于“小明”的7个三元组鲜明地描述了小明这个人物，包括（小明，父亲是，建国）、（小明，获得奖项，最佳男主角）以及（小明，妻子是，小红）等。,小明,中文名,最佳男主角
除了路径，实体的邻居节点以及它们之间的关系也是刻画和描述一个实体的重要信息，例如在上例中的关于“小明”的7个三元组鲜明地描述了小明这个人物，包括（小明，父亲是，建国）、（小明，获得奖项，最佳男主角）以及（小明，妻子是，小红）等。,小明,中文名,小红
一般而言，离实体越近的节点对描述这个实体的贡献越大，在知识图谱推理的研究中，常考虑的是实体一跳和两跳范围内的节点和关系。,知识图谱推理,包含,实体一跳和两跳范围内的节点和关系
2.常见算法简介典型的基于图结构的推理方法有PRA（Path_Ranking_Algorithm）[10]利用了实体节点之间的路径当作特征从而进行链接预测推理。,基于图结构的推理方法,包含,PRA
"PRA处理的推理问题是关系推理，其中包含了两个任务，一个是给定关系r和头实体h预测可能的尾实体t是什么，即在给定h,r的情况下，预测哪个三元组（h,r,t）成立的可能性比较大，叫作尾实体链接预测；另一个是在给定r,t的情况下，预测可能的头实体h是什么，叫作头实体链接预测。",PRA处理的推理问题,包含,关系推理
在PRA中，利用随机游走的路径排序算法首先需要生成一些路径特征，一个路径P是由一系列关系组成的，即：式中，Tn为关系rn的作用域（range)以及关系rn−1的值域（domian)，即Tn=range（rn）=domain（rn−1），关系的值域和作用域通常指的是实体的类型。,一个路径P,包含,一系列关系
"具体操作为，在随机游走的初始阶段，sℎ,P（e）初始化为1，如果e=s，否则初始化为0。",具体操作为,包含,"在随机游走的初始阶段，sℎ,P（e）初始化为1"
"具体操作为，在随机游走的初始阶段，sℎ,P（e）初始化为1，如果e=s，否则初始化为0。",具体操作为,包含,如果e=s，否则初始化为0
在路径特征搜索的过程中，PRA增加了对有效路径特征的约束，来有效减小搜索空间：路径在图谱中的支持度（support）应大于某设定的比例α；路径的长度小于或等于某设定的长度；每条路径至少有一个正样本在训练集中。,PRA,包含,对有效路径特征的约束
所以，CoR-PRA（Constant_and_Reversed_Path_RankingAlgorithm）[43]通过改变PRA的路径特征搜索策略，促使其能够涵盖更多种语义信息的特征，主要是包含常量的图结构特征。,CoR-PRA,包含,改变PRA的路径特征搜索策略，促使其能够涵盖更多种语义信息的特征
4）生成更长的路径特征候选集（LongConcatenatedPathCandidates）。,生成更长的路径特征候选集,包含,LongConcatenatedPathCandidates
"从路径搜索过程可以看出，相比PRA,CoR-PRA最重要的不同有两方面，一是增加了带有常量的路径特征的搜索，二是搜索过程由单项搜索变成了双向搜索。",CoR-PRA,包含,路径搜索过程
"为了提升路径搜索的效率，SFE去除了路径特征的概率计算这个需要较大计算量的过程，而是直接保留二值特征，仅记录此路径是否在两个实体之间存在，SFE首先通过随机游走采集每个实体的制定步数以内的子图特征，并记录下子图中所有的结束节点实体e，对于某个关系的训练样本实体对（h,t），如果实体ei同时存在于实体h和t的结束实体集中，那么就以ei为链接节点，将h和t对应子图中的结构生成一条h和t之间的路径。",SFE,包含,去除路径特征的概率计算
"为了增加子图特征的丰富性，除了PRA中用到的路径特征，SFE还增加了二元路径特征，类似自然语言处理中的bigram，即将两个具有连接的关系组成一个新的关系，例如“BIGRAM：对齐实体/妻子是”，除了二元路径特征，SFE还增加了one-sided_feature,one-sided_path指的是一个存在在给定两个节点之间的路径的，是从起始节点开始，但不一定由另一个节点结束，类似Co-PRA中的带有常量的路径特征。",SFE,包含,one-sided_path
"为了增加子图特征的丰富性，除了PRA中用到的路径特征，SFE还增加了二元路径特征，类似自然语言处理中的bigram，即将两个具有连接的关系组成一个新的关系，例如“BIGRAM：对齐实体/妻子是”，除了二元路径特征，SFE还增加了one-sided_feature,one-sided_path指的是一个存在在给定两个节点之间的路径的，是从起始节点开始，但不一定由另一个节点结束，类似Co-PRA中的带有常量的路径特征。",SFE,包含,one-sided_feature
SFE还会对给定的两个节点进行one-sided_feature的比较，如果两个节点都具有相同的关系ri，例如“性别是”，那么将会把两个节点的ri以及连接的实体记录下来。,SFE,包含,one-sided_feature比较
如果两个节点在关系ri下连接的节点是一样的，那么这个特征是可以被PRA路径特征捕捉到的，但是如果取值不一样就只有SFE能捕捉到。,PRA路径特征,包含,关系ri下连接的节点是一样的
SFE还增加了一个表示任意关系的关系ANYREL来增加路径特征的丰富性。,SFE,包含,ANYREL
总体来说，SFE在PRA的路径特征搜索的效率和特征的丰富性方面做了比较大的提升。,SFE,包含,PRA的路径特征搜索的效率
总体来说，SFE在PRA的路径特征搜索的效率和特征的丰富性方面做了比较大的提升。,SFE,包含,特征的丰富性
从基于图结构的PRA系列研究可以看出，被研究得比较多的图结构是与路径相关的结构特征，在利用路径特征的过程中，一个重要的问题是如何有效地搜索到路径，涌现出了很多提升路径搜索效率的研究工作。,基于图结构的PRA系列研究,包含,提升路径搜索效率的研究工作
但路径相关的特征还不能覆盖知识图谱中包含的所有语义信息，因而由相关工作通过引入带有实例的路径来丰富图特征所包含的语义信息的类型。,图特征,包含,带有实例的路径来丰富图特征所包含的语义信息
图6-15SFE和PRA的性能比较典型的PRA系列工具可以参考https://github.com/noon99jaki/pra，集成了PRA以及CoR-PRA算法。,PRA,包含,典型的PRA系列工具
规则一般包含了两个部分，分别为规则头（head）和规则主体（body），其一般形式为rule:head←body.解读为有规则主体的信息可推出规则头的信息。,规则头的信息,包含,规则主体的信息
规则一般包含了两个部分，分别为规则头（head）和规则主体（body），其一般形式为rule:head←body.解读为有规则主体的信息可推出规则头的信息。,规则主体的信息,包含,规则头的信息
其中，规则头由一个二元的原子（atom）构成，而规则主体由一个或多个一元原子或二元原子组成。,规则头,包含,二元的原子
其中，规则头由一个二元的原子（atom）构成，而规则主体由一个或多个一元原子或二元原子组成。,规则主体,包含,一个或多个一元原子或二元原子
"原子（atom）是指包含了变量的元组，例如isLocation(X)是一个一元原子表示实体变量X是一个位置实体；hasWife(X,Y)是一个二元原子，表示实体变量X的妻子是实体变量Y。",原子,包含,元组
"原子（atom）是指包含了变量的元组，例如isLocation(X)是一个一元原子表示实体变量X是一个位置实体；hasWife(X,Y)是一个二元原子，表示实体变量X的妻子是实体变量Y。",原子,包含,变量
"二元原子可以包含两个或一个，例如liveIn(X,Hangzhou)是一个指含有一个实体变量X的二元原子，表示了变量X居住在杭州。",二元原子,包含,两个或一个
在规则主体中，不同的原子是通过逻辑合取组合在一起的，且规则主体中的原子可以以肯定或否定的形式出现，例如如下规则：这里的规则示例说明了如果任意实体X的妻子是实体Y，且实体Y的孩子有Z且X和Y都不曾离婚，那么可以推出X的孩子也有Z。,规则主体,包含,逻辑合取
在规则主体中，不同的原子是通过逻辑合取组合在一起的，且规则主体中的原子可以以肯定或否定的形式出现，例如如下规则：这里的规则示例说明了如果任意实体X的妻子是实体Y，且实体Y的孩子有Z且X和Y都不曾离婚，那么可以推出X的孩子也有Z。,规则主体,包含,肯定或否定形式
这条规则里的规则主体就包含了以否定形式出现的原子。,这条规则里的规则主体,包含,以否定形式出现的原子
所以，规则也可以表示为：rule:head←body+∧body−.其中，body+表示以肯定形式出现的原子的逻辑合取集合，而body−表示以否定形式出现的原子的逻辑合取集合。,rule,包含,body+
所以，规则也可以表示为：rule:head←body+∧body−.其中，body+表示以肯定形式出现的原子的逻辑合取集合，而body−表示以否定形式出现的原子的逻辑合取集合。,rule,包含,body−
如果规则主体中只包含有肯定形式出现的原子而不包含否定形式出现的原子，称这样的规则为霍恩规则（horn规则类型，可以表示为以下形式：rules），霍恩规则是被研究得比较多的a0←a1∧a2∧…∧an.其中，每个ai都为一个原子。,霍恩规则,包含,肯定形式出现的原子
如果规则主体中只包含有肯定形式出现的原子而不包含否定形式出现的原子，称这样的规则为霍恩规则（horn规则类型，可以表示为以下形式：rules），霍恩规则是被研究得比较多的a0←a1∧a2∧…∧an.其中，每个ai都为一个原子。,霍恩规则,包含,否定形式出现的原子
"在知识图谱的规则学习方法中，另一种被研究得比较多的规则类型叫作路径规则（pathrules），路径规则可以表示为如下形式：r0（e1,en+1）←r1（e1,e2）∧r2（e2,e3）∧…∧rn（en,en+1）.其中，规则主体中的原子均为含有两个变量的二元原子，且规则主体的所有二元原子构成一个从规则头中的两个实体之间的路径，且整个规则在知识图谱中构成一个闭环结构。",路径规则,包含,规则主体中的原子均为含有两个变量的二元原子
"在知识图谱的规则学习方法中，另一种被研究得比较多的规则类型叫作路径规则（pathrules），路径规则可以表示为如下形式：r0（e1,en+1）←r1（e1,e2）∧r2（e2,e3）∧…∧rn（en,en+1）.其中，规则主体中的原子均为含有两个变量的二元原子，且规则主体的所有二元原子构成一个从规则头中的两个实体之间的路径，且整个规则在知识图谱中构成一个闭环结构。",路径规则,包含,且规则主体的所有二元原子构成一个从规则头中的两个实体之间的路径
"在知识图谱的规则学习方法中，另一种被研究得比较多的规则类型叫作路径规则（pathrules），路径规则可以表示为如下形式：r0（e1,en+1）←r1（e1,e2）∧r2（e2,e3）∧…∧rn（en,en+1）.其中，规则主体中的原子均为含有两个变量的二元原子，且规则主体的所有二元原子构成一个从规则头中的两个实体之间的路径，且整个规则在知识图谱中构成一个闭环结构。",路径规则,包含,且整个规则在知识图谱中构成一个闭环结构
这几种不同规则的包含关系如下：路径规则∈霍恩规则∈一般规则.即路径规则是霍恩规则的一个子集，而霍恩规则又是一般规则的一个子集，从规则的表达能力来看，一般规则的表达能力最强，包含各种不同的规则类型，而霍恩规则次之，规则路径的表达能力最弱，只能表达特定类型的规则。,路径规则的表达能力,包含,霍恩规则的子集
这几种不同规则的包含关系如下：路径规则∈霍恩规则∈一般规则.即路径规则是霍恩规则的一个子集，而霍恩规则又是一般规则的一个子集，从规则的表达能力来看，一般规则的表达能力最强，包含各种不同的规则类型，而霍恩规则次之，规则路径的表达能力最弱，只能表达特定类型的规则。,路径规则的表达能力,包含,一般规则的子集
在规则学习过程中，对于学习到的规则一般有三种评估方法，分别是支持度（support）、置信度（confidence）、规则头覆盖度（headcoverage）。,评估方法,包含,支持度
在规则学习过程中，对于学习到的规则一般有三种评估方法，分别是支持度（support）、置信度（confidence）、规则头覆盖度（headcoverage）。,评估方法,包含,置信度
在规则学习过程中，对于学习到的规则一般有三种评估方法，分别是支持度（support）、置信度（confidence）、规则头覆盖度（headcoverage）。,评估方法,包含,规则头覆盖度
对于一个规则rule，在知识图谱中，其支持度（support）指的是满足规则主体和规则头的实例个数，规则的实例化指的是将规则中的变量替换成知识图谱中真实的实体后的结果。,规则的实例化,包含,将规则中的变量替换成知识图谱中真实的实体后的结果
所以，规则的支持度通常是一个大于或等于0的整数值，用support(rule)表示。,规则的支持度,包含,大于或等于0的整数值
一般来说，一个规则的支持度越大，说明这个规则的实例在知识图谱中存在得越多，从统计角度来看，也越可能是一个比较好的规则。,规则的支持度,包含,一个规则的实例在知识图谱中存在得越多
规则的置信度（confidence）的计算方式为：即规则支持度和满足规则主体的实例个数的比值，即在满足规则主体的实例中，同时也能满足规则头的实例比例。,规则的置信度（confidence）,包含,规则支持度和满足规则主体的实例个数的比值
"PCA置信度的计算方法为从上面的式子可以看出，和前文介绍的置信度计算方法相比，PCA置信度最大的区别是分母中需要多考虑一个条件r0（x,y′），这里r0（x,y）是规则头，而r0（x,y′）说明在知识图谱中，只要当规则头中的头实体x通过关系r0连接到除y以外的实体时才能算进分母的计数，否则不作分母计数。",PCA置信度的计算方法,包含,"分母中需要多考虑一个条件r0（x,y′）"
所以，在PCA置信度中排除了来自这类实例对置信度值的负向影响。,PCA置信度,包含,来自这类实例对置信度值的负向影响
规则头覆盖度（Head_Coverage）的计算方法为即规则支持度和满足规则头的实例个数的比值，即在满足规则头的实例中，同时也满足规则主体的实例比例。,规则头覆盖度的计算方法,包含,规则支持度和满足规则头的实例个数的比值
规则的支持度、置信度以及头覆盖度从不同的角度反映了规则的质量，但三者之间没有必然的关联关系。,支持度,包含,规则的质量
规则的支持度、置信度以及头覆盖度从不同的角度反映了规则的质量，但三者之间没有必然的关联关系。,置信度,包含,规则的质量
规则的支持度、置信度以及头覆盖度从不同的角度反映了规则的质量，但三者之间没有必然的关联关系。,头覆盖度,包含,反映规则的质量
例如，置信度高的规则，其头覆盖度并不一定高，所以在规则学习中通常会结合这三个评价指标综合衡量规则的质量。,规则质量,包含,置信度高的规则头覆盖度
"AMIE能挖掘的规则形如：fatherOf（f,c）←motherOf（m,c）∧marriedTo（m,f）.AMIE是一种霍恩规则，也是一种闭环规则，即整条规则可以在图中构成一个闭环结构。",AMIE,包含,霍恩规则
"AMIE能挖掘的规则形如：fatherOf（f,c）←motherOf（m,c）∧marriedTo（m,f）.AMIE是一种霍恩规则，也是一种闭环规则，即整条规则可以在图中构成一个闭环结构。",AMIE,包含,闭环规则
AMIE定义了3个挖掘算子（Mining_Operators），通过不断在规则中增加挖掘算子来探索图上的搜索空间，并且融入了对应的剪枝策略。,AMIE,包含,挖掘算子
3个挖掘算子如下：●增加悬挂原子（Adding_Dangling_Atom）。,挖掘算子,包含,增加悬挂原子（Adding_Dangling_Atom）
即在规则中增加一个原子，这个原子包含一个新的变量和一个已经在规则中出现的元素，可以是出现过的变量，也可以是出现过的实体。,SPO,包含,原子
即在规则中增加一个原子，这个原子包含一个实例化的实体以及一个已经在规则中出现的元素。,SPO,包含,原子
即在规则中增加一个原子，这个原子包含的两个元素都是已经出现在规则中的变量或实体。,SPO,包含,原子
AMIE的剪枝策略主要包含两条：●设置最低规则头覆盖度过滤，头覆盖度很低的规则一般是一些边缘规则，可以直接过滤掉。,AMIE的剪枝策略,包含,设置最低规则头覆盖度过滤
AMIE的剪枝策略主要包含两条：●设置最低规则头覆盖度过滤，头覆盖度很低的规则一般是一些边缘规则，可以直接过滤掉。,AMIE的剪枝策略,包含,包含两条
●在一条规则中，每在规则主体中增加一个原子，都应该使得规则的置信度增加，即confidence（a0←a0∧a2∧…∧an∧an+1）＞confidence（a0←a0∧a2∧…∧an）。,一条规则的置信度,包含,增加一个原子
如果在规则中增加一个新的原子an+1，但没有提升规则整体的置信度，那么就将拓展后的规则a0←a0∧a2∧…∧an∧an+1剪枝掉。,拓展后的规则,包含,a0
图6-17AMIE不同数据集规则挖掘结果对比规则挖掘的典型工具AMIE可参考http://www.mpi-inf.mpg.de/departments/ontologies/projects/amie/，其中包括了进一步提升AMIE效率的AMIE+[45]。,AMIE,包含,进一步提升AMIE效率
6.3.3基于表示学习的推理1.方法概述基于图结构的推理和基于规则学习的推理，都显式地定义了推理学习所需的特征，而基于表示学习的推理通过将知识图谱中包括实体和关系的元素映射到一个连续的向量空间中，为每个元素学习在向量空间中表示，向量空间中的表示可以是一个或多个向量或矩阵。,基于表示学习的推理,包含,将知识图谱中包括实体和关系的元素映射到一个连续的向量空间中
表示学习让算法在学习向量表示的过程中自动捕捉、推理所需的特征，通过训练学习，将知识图谱中离散符号表示的信息编码在不同的向量空间表示中，使得知识图谱的推理能够通过预设的向量空间表示之间的计算自动实现，不需要显式的推理步骤。,表示学习,包含,知识图谱中离散符号表示的信息
而拓展到知识图谱上，就可以理解为拥有同一种关系的头实体和尾实体对，在向量空间的表示可能具有平移不变性，这启发了经典的知识图谱表示学习方法TransE的提出以及知识图谱表示学习的相关研究。,知识图谱表示学习,包含,经典的知识图谱表示学习方法TransE的提出以及知识图谱表示学习的相关研究
在需要映射到的向量空间中，TransE将关系看作是从头实体向量到尾实体向量的翻译，即头实体向量通过关系向量的翻译得到尾实体，则说明这个三元组在知识图谱中成立。,TransE,包含,关系看作是从头实体向量到尾实体向量的翻译
"然后通过一个正负样本之间最大间隔的损失函数，设计训练得到知识图谱的表示学习结果，其损失函数为式中，S表示知识图谱中正样本的集合；S（′ℎ,r,t）表示（h,r,t）的负样本，在训练过程中三元组（h,r,t）的负样本通过随机替换头实体h或者尾实体t得到；[x]+表示max（0,x）;γ表示损失函数中的间隔，是一个需要设置的大于零的超参。",知识图谱的表示学习结果,包含,损失函数
例如，实体“中国”在关系“拥有省份”这个关系下有很多个尾实体，根据TransE的假设，任何一个省份的向量表示都满足v（省份x）:v（中国）+v（拥有省份）=v（省份x），这将会导致TransE无法很好地区分各个省份。,“中国”,包含,“拥有省份”
为了减少TransR的参数量且同时保留其表达能力，TransD[47]提出了用一个与实体相关的向量以及一个与关系相关的向量通过外积计算，动态地得到关系投影矩阵，如图6-20所示。,TransD,包含,关系相关的向量通过外积计算
上式表达的hMr=t.意思是头实体通过与关系矩阵相乘，经过空间中的线性变化以后，可以转变为尾实体向量。,头实体,包含,hMr=t
上式表达的hMr=t.意思是头实体通过与关系矩阵相乘，经过空间中的线性变化以后，可以转变为尾实体向量。,尾实体向量,包含,头实体通过与关系矩阵相乘，经过空间中的线性变化以后
从语义的角度分析，知识图谱中的关系既包含了对称关系如“配偶是”，也包含了不对称关系如“出生地”，而且非对称关系一般还多于对称关系。,关系,包含,对称关系
从语义的角度分析，知识图谱中的关系既包含了对称关系如“配偶是”，也包含了不对称关系如“出生地”，而且非对称关系一般还多于对称关系。,关系,包含,非对称关系
"其得分函数的计算如下：f（h,r,t）=＜Re（h）,Re（r）,Re（t）＞+＜Re（h）,Im（r）,Im（t）＞+＜Im（h）,Re（r）,Im（t）＞−＜Im（h）,Im（r）,Im（t）＞式中，Re（x）表示复数x的实部，Im（x）表示x的虚部，＜x,y,z＞=xyz。",得分函数的计算,包含,复数x的实部
"其得分函数的计算如下：f（h,r,t）=＜Re（h）,Re（r）,Re（t）＞+＜Re（h）,Im（r）,Im（t）＞+＜Im（h）,Re（r）,Im（t）＞−＜Im（h）,Im（r）,Im（t）＞式中，Re（x）表示复数x的实部，Im（x）表示x的虚部，＜x,y,z＞=xyz。",得分函数的计算,包含,复数x的虚部
"其得分函数的计算如下：f（h,r,t）=＜Re（h）,Re（r）,Re（t）＞+＜Re（h）,Im（r）,Im（t）＞+＜Im（h）,Re（r）,Im（t）＞−＜Im（h）,Im（r）,Im（t）＞式中，Re（x）表示复数x的实部，Im（x）表示x的虚部，＜x,y,z＞=xyz。",得分函数的计算,包含,"＜Re（h）,Re（r）,Re（t）＞"
"其得分函数的计算如下：f（h,r,t）=＜Re（h）,Re（r）,Re（t）＞+＜Re（h）,Im（r）,Im（t）＞+＜Im（h）,Re（r）,Im（t）＞−＜Im（h）,Im（r）,Im（t）＞式中，Re（x）表示复数x的实部，Im（x）表示x的虚部，＜x,y,z＞=xyz。",得分函数的计算,包含,"＜Re（h）,Im（r）,Im（t）＞"
"其得分函数的计算如下：f（h,r,t）=＜Re（h）,Re（r）,Re（t）＞+＜Re（h）,Im（r）,Im（t）＞+＜Im（h）,Re（r）,Im（t）＞−＜Im（h）,Im（r）,Im（t）＞式中，Re（x）表示复数x的实部，Im（x）表示x的虚部，＜x,y,z＞=xyz。",得分函数的计算,包含,"＜Im（h）,Re（r）,Im（t）＞"
"其得分函数的计算如下：f（h,r,t）=＜Re（h）,Re（r）,Re（t）＞+＜Re（h）,Im（r）,Im（t）＞+＜Im（h）,Re（r）,Im（t）＞−＜Im（h）,Im（r）,Im（t）＞式中，Re（x）表示复数x的实部，Im（x）表示x的虚部，＜x,y,z＞=xyz。",得分函数的计算,包含,"−＜Im（h）,Im（r）,Im（t）＞"
除目前提到的表示学习方法，还有很多其他思路的表示学习方法，例如纯神经网络方法NTN[51]、ConvE[52]等，这里不再赘述。,表示学习方法,包含,纯神经网络方法NTN[51]
除目前提到的表示学习方法，还有很多其他思路的表示学习方法，例如纯神经网络方法NTN[51]、ConvE[52]等，这里不再赘述。,表示学习方法,包含,ConvE[52]
"3.典型工具简介或实验对比分析表6-6为常用知识图谱表示学习方法链接预测结果比较，采用的评价指标包括平均排序（Mean_Rank,MR）、倒数平均排序（Mean_Reciprocal_Rank,MRR）以及排序n以内的占比(Hit@n)。",知识图谱表示学习方法链接预测结果比较,包含,"平均排序(Mean_Rank,MR)"
"3.典型工具简介或实验对比分析表6-6为常用知识图谱表示学习方法链接预测结果比较，采用的评价指标包括平均排序（Mean_Rank,MR）、倒数平均排序（Mean_Reciprocal_Rank,MRR）以及排序n以内的占比(Hit@n)。",知识图谱表示学习方法链接预测结果比较,包含,"倒数平均排序(Mean_Reciprocal_Rank,MRR)"
表6-6常用知识图谱表示学习方法链接预测结果比较续表常用的关于知识图谱表示学习的工具包有清华开源的OpenKE，它涵盖了常见的表示学习模型，并有PyTorch、TensorFlow以及C++版本。,OpenKE,包含,常用的知识图谱表示学习的工具包
6.4知识图谱推理新进展6.4.1时序预测推理知识推理中的时序预测新应用以Chen等人[53]提出的模型为例。,知识推理中的时序预测新应用,包含,Chen等人[53]提出的模型
在描述逻辑中，本体流包含TBox（术语成分）和ABox（断言公理）。,本体流,包含,TBox
在描述逻辑中，本体流包含TBox（术语成分）和ABox（断言公理）。,本体流,包含,ABox
该模型被证明对概念漂移（即突然和不一致的预测变化）是稳健的，同时具有通用性和灵活性等特点，可用于增强基本的流学习算法。,概念漂移,包含,稳健的
该模型被证明对概念漂移（即突然和不一致的预测变化）是稳健的，同时具有通用性和灵活性等特点，可用于增强基本的流学习算法。,概念漂移,包含,通用性
该模型被证明对概念漂移（即突然和不一致的预测变化）是稳健的，同时具有通用性和灵活性等特点，可用于增强基本的流学习算法。,概念漂移,包含,灵活性
"具体而言，强化学习中智能体的状态被定义为当前节点实体和目标节点实体的联合表示st=（et,etarget−et）.智能体的动作则是在当前节点实体的出边（Outgoing_edge）中选择一个适当的边作为组成路径的关系。",强化学习中智能体的状态,包含,当前节点实体和目标节点实体的联合表示
与“事实判断”相比，“查询问答”无法预知答案对应的尾实体，需要从知识图谱中寻找可作为答案的尾实体。,“查询问答”,包含,无法预知答案对应的尾实体
智能体的当前状态与它所处的当前实体有关，其动作即该实体可选的出边。,智能体的当前状态,包含,它所处的当前实体
智能体的当前状态与它所处的当前实体有关，其动作即该实体可选的出边。,智能体的动作,包含,该实体可选的出边
尽管整个知识图谱中的关系总数可能繁多，但具体到某一实体，可选的出边往往减少一个或两个数量级，可大幅降低遍历的规模。,知识图谱,包含,出边
但事实上，对于某一个关系，其具有的三元组实例越少，其对知识图谱的补全越有利用的价值。,某一个关系,包含,三元组实例
当前主要的元学习方法分为三类，基于度量（Metric-Based）、基于模型（Model-Based）和基于优化（Optimization-Based）的方法。,元学习方法,包含,基于度量方法
当前主要的元学习方法分为三类，基于度量（Metric-Based）、基于模型（Model-Based）和基于优化（Optimization-Based）的方法。,元学习方法,包含,基于模型方法
当前主要的元学习方法分为三类，基于度量（Metric-Based）、基于模型（Model-Based）和基于优化（Optimization-Based）的方法。,元学习方法,包含,基于优化方法
关于元学习的研究，一开始主要应用于图像分类[55-57]，研究者近来尝试使用元学习的方法解决知识图谱中有关长尾关系的推理。,元学习的研究,包含,图像分类
把元学习应用于少样本知识图谱推理的研究还相对较少，该领域还有很多可以挖掘和研究的地方。,元学习,包含,少样本知识图谱推理
Takuo_Hamaguchi_[60]主要针对KG中的OOKB（out-of-knowledge-base）实体进行知识库补全等任务。,Takuo_Hamaguchi_,包含,知识库补全等任务
OOKB实体，即在训练过程中未被训练到的实体，无法得到其Embedding表示，从而无法预测其与知识库中其他实体之间的关系。,OOKB实体,包含,在训练过程中未被训练到的实体
而文中将知识库补全的任务定义为：基于知识库中已存在的三元组和当前出现的包含新实体的三元组，推理当前新实体与知识库中其他实体之间的关系。,知识库补全,包含,推理当前新实体与知识库中其他实体之间的关系
因此，这篇文献利用GNN中节点表示的方式，以OOKB实体分别为头实体、尾实体的三元组集合为周围邻居，对当前OOKB实体进行表示。,GNN中节点表示的方式,包含,以OOKB实体分别为头实体、尾实体的三元组集合为周围邻居，对当前OOKB实体进行表示
GNN模型的引入丰富了知识库中实体和关系元素的表达，尤其是在得到未知实体或关系的表示等方面具备一定的推理能力，针对目前在知识图谱表示学习和推理等方面遇到的问题，相信GNN一定能发挥出重要的作用。,GNN模型,包含,知识图谱表示学习和推理等方面遇到的问题
（1）基于演绎的知识图谱推理可能有以下发展趋势：●演绎推理方法的效率是阻碍它们被广泛应用的瓶颈之一，通过并行技术、模块化技术、递增式推理技术和其他优化技术，实现高效推理机是演绎推理研究的趋势。,基于演绎的知识图谱推理,包含,推理方法的效率
●目前的演绎推理方法在处理流数据和移动数据方面还缺少完善的理论以及实用化算法，如何处理流数据的动态性以及时序性是值得研究的方向。,目前的演绎推理方法,包含,处理流数据的动态性以及时序性
（2）基于归纳的知识图谱推理可能有以下发展趋势：●尽管归纳推理主要是基于对已有数据的观察总结，但在归纳推理中也将逐渐融入先验的语义信息，例如规则等，使得归纳推理不仅仅是基于大量数据的观察，同时也包含先验知识的约束，从而达到更精准的推理。,归纳推理,包含,对已有数据的观察总结
（2）基于归纳的知识图谱推理可能有以下发展趋势：●尽管归纳推理主要是基于对已有数据的观察总结，但在归纳推理中也将逐渐融入先验的语义信息，例如规则等，使得归纳推理不仅仅是基于大量数据的观察，同时也包含先验知识的约束，从而达到更精准的推理。,归纳推理,包含,先验知识的约束
●不同的归纳推理方法，例如基于图结构、基于规则学习和基于表示学习的推理应该互相融合，形成优势互补，完成更智能的推理。,归纳推理方法,包含,基于图结构推理
●不同的归纳推理方法，例如基于图结构、基于规则学习和基于表示学习的推理应该互相融合，形成优势互补，完成更智能的推理。,归纳推理方法,包含,基于规则学习推理
●不同的归纳推理方法，例如基于图结构、基于规则学习和基于表示学习的推理应该互相融合，形成优势互补，完成更智能的推理。,归纳推理方法,包含,基于表示学习推理
●任何知识图谱都具有不完整性，仅仅基于知识图谱本身的推理无法突破不完整性的限制，因此外部信息，例如文本、图像等信息可能是很好的补充。,知识图谱,包含,外部信息
