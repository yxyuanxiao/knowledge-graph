input,subject,relation,object
这样一来，即使在同一个领域内也往往存在着大量的本体。,本体,属于,同一个领域内也往往存在着大量的本体
这样一来，即使在同一个领域内也往往存在着大量的本体。,本体,实现,在同一领域内也往往存在着大量的本体
这样一来，即使在同一个领域内也往往存在着大量的本体。,本体,中文名,本体
然而，如果不同的系统采用的本体是异构的，它们之间的信息交互便无法正常进行。,本体,属于,异构的系统之间的信息交互
然而，如果不同的系统采用的本体是异构的，它们之间的信息交互便无法正常进行。,本体,实现,不同的系统采用的本体是异构的，它们之间的信息交互便无法正常进行
然而，如果不同的系统采用的本体是异构的，它们之间的信息交互便无法正常进行。,本体,中文名,本体
在实际的知识图谱应用中，本体异构造成了大量的信息交互问题。,本体异构,属于,信息交互问题
在实际的知识图谱应用中，本体异构造成了大量的信息交互问题。,本体异构,实现,大量的信息交互问题
因此，解决本体异构、消除应用系统间的互操作障碍是很多知识图谱应用面临的关键问题之一。,知识图谱应用,属于,解决本体异构、消除应用系统间的互操作障碍
因此，解决本体异构、消除应用系统间的互操作障碍是很多知识图谱应用面临的关键问题之一。,知识图谱应用,实现,很多知识图谱应用面临的关键问题之一
因此，解决本体异构、消除应用系统间的互操作障碍是很多知识图谱应用面临的关键问题之一。,知识图谱应用,中文名,本体异构
另一方面，知识图谱中的大量实例也存在异构问题，同名实例可能指代不同的实体，不同名实例可能指代同一个实体，大量的共指问题会给知识图谱的应用造成负面影响。,知识图谱中的实例,属于,异构问题
另一方面，知识图谱中的大量实例也存在异构问题，同名实例可能指代不同的实体，不同名实例可能指代同一个实体，大量的共指问题会给知识图谱的应用造成负面影响。,知识图谱,实现,同名实例可能指代不同的实体
另一方面，知识图谱中的大量实例也存在异构问题，同名实例可能指代不同的实体，不同名实例可能指代同一个实体，大量的共指问题会给知识图谱的应用造成负面影响。,知识图谱中的实例,中文名,同名实例可能指代不同的实体
因此，知识图谱应用还需要解决实例层的异构问题。,知识图谱应用,属于,实例层异构问题
因此，知识图谱应用还需要解决实例层的异构问题。,知识图谱应用,实现,实例层异构问题
知识融合是解决知识图谱异构问题的有效途径。,知识融合,属于,解决知识图谱异构问题的有效途径
知识融合是解决知识图谱异构问题的有效途径。,知识融合,实现,解决知识图谱异构问题的有效途径
知识融合是解决知识图谱异构问题的有效途径。,知识融合,中文名,解决知识图谱异构问题的有效途径
实际上，针对模型之间的异构问题的研究早在面向对象建模和数据库建模领域中就已经开展了[1]。,面向对象建模,属于,针对模型之间的异构问题的研究
实际上，针对模型之间的异构问题的研究早在面向对象建模和数据库建模领域中就已经开展了[1]。,面向对象建模和数据库建模领域,实现,针对模型之间的异构问题的研究
实际上，针对模型之间的异构问题的研究早在面向对象建模和数据库建模领域中就已经开展了[1]。,面向对象建模,中文名,针对模型之间的异构问题的研究
实际上，针对模型之间的异构问题的研究早在面向对象建模和数据库建模领域中就已经开展了[1]。,面向对象和数据库建模领域,中文名,针对模型之间的异构问题的研究
与这些模型相似，知识图谱之间的不匹配正是造成知识图谱异构的直接原因。,知识图谱之间的不匹配,属于,造成知识图谱异构
与这些模型相似，知识图谱之间的不匹配正是造成知识图谱异构的直接原因。,知识图谱,实现,异构
与这些模型相似，知识图谱之间的不匹配正是造成知识图谱异构的直接原因。,知识图谱之间的不匹配,中文名,造成知识图谱异构
不同的时期都存在着几种流行的语言，如早期有Ontolingua和Loom等本体语言，近年则有DAML+OIL、RDF(S)、OWL和OWL2等。,本体语言,属于,早期流行的语言
不同的时期都存在着几种流行的语言，如早期有Ontolingua和Loom等本体语言，近年则有DAML+OIL、RDF(S)、OWL和OWL2等。,本体语言,属于,近年流行的语言
不同的时期都存在着几种流行的语言，如早期有Ontolingua和Loom等本体语言，近年则有DAML+OIL、RDF(S)、OWL和OWL2等。,Ontolingua,实现,本体语言的特点
不同的时期都存在着几种流行的语言，如早期有Ontolingua和Loom等本体语言，近年则有DAML+OIL、RDF(S)、OWL和OWL2等。,Loom,实现,本体语言的特点
不同的时期都存在着几种流行的语言，如早期有Ontolingua和Loom等本体语言，近年则有DAML+OIL、RDF(S)、OWL和OWL2等。,本体语言,中文名,本体语言
当不同时期构建的知识或同一时期采用不同语言表示的知识进行交互时，首先面临着由于知识表示语言之间的不匹配所造成的异构问题[3]。,异构问题,属于,不同时期构建的知识或同一时期采用不同语言表示的知识进行交互时所面临的问题
当不同时期构建的知识或同一时期采用不同语言表示的知识进行交互时，首先面临着由于知识表示语言之间的不匹配所造成的异构问题[3]。,异构问题,实现,不同时期构建的知识或同一时期采用不同语言表示的知识进行交互时所面临的问题
当不同时期构建的知识或同一时期采用不同语言表示的知识进行交互时，首先面临着由于知识表示语言之间的不匹配所造成的异构问题[3]。,异构问题,中文名,不同时期构建的知识或同一时期采用不同语言表示的知识进行交互时所面临的问题
1.语法不匹配不同的知识描述语言常采用不同的语法。,知识描述语言,属于,不同的语法
1.语法不匹配不同的知识描述语言常采用不同的语法。,知识描述语言,实现,不同的知识描述语言常采用不同的语法
1.语法不匹配不同的知识描述语言常采用不同的语法。,知识描述语言,中文名,知识描述语言常采用不同的语法
近年来的本体语言基本采用XML的书写格式，而早期的本体语言则没有固定的格式可言。,本体语言,属于,采用XML的书写格式
近年来的本体语言基本采用XML的书写格式，而早期的本体语言则没有固定的格式可言。,本体语言,实现,早期的本体语言
近年来的本体语言基本采用XML的书写格式，而早期的本体语言则没有固定的格式可言。,本体语言,中文名,本体语言
一般来说，如果表示的成分在两种语言中都是存在的，则采用一个简单的重写机制就足以解决这类问题。,重写机制,属于,表示的成分在两种语言中都是存在的
一般来说，如果表示的成分在两种语言中都是存在的，则采用一个简单的重写机制就足以解决这类问题。,英文名,实现,
一般来说，如果表示的成分在两种语言中都是存在的，则采用一个简单的重写机制就足以解决这类问题。,属于,实现,表示的成分在两种语言中都是存在的
一般来说，如果表示的成分在两种语言中都是存在的，则采用一个简单的重写机制就足以解决这类问题。,重写机制,中文名,重写机制
但是，语法上的不匹配通常不会单独出现，而是与其他语言层上的差异同时出现。,语法上的不匹配,属于,其他语言层上的差异
但是，语法上的不匹配通常不会单独出现，而是与其他语言层上的差异同时出现。,SPO,实现,与其他语言层上的差异同时出现
因此，尽量将不同的语言转化为同样的语法格式能方便解决其他本体不匹配问题。,中文本体的转换,属于,解决其他本体不匹配问题
因此，尽量将不同的语言转化为同样的语法格式能方便解决其他本体不匹配问题。,中文本体的转换,实现,将不同的语言转化为同样的语法格式
2.逻辑表示不匹配不同语言的逻辑表示也可能存在着不匹配。,逻辑表示不匹配,属于,不同语言的逻辑表示
2.逻辑表示不匹配不同语言的逻辑表示也可能存在着不匹配。,逻辑表示不匹配不同语言的逻辑表示,实现,不匹配
这就是说，不同的语言可能采用不同的形式来表示逻辑意义上的等价结果。,等价结果,属于,不同的语言采用不同的形式来表示逻辑意义上的等价结果
这就是说，不同的语言可能采用不同的形式来表示逻辑意义上的等价结果。,等价结果,实现,不同的语言可能采用不同的形式来表示逻辑意义上的等价结果
相对而言，这类不匹配也容易解决，例如，通过定义从语言L1逻辑表示到语言L2的逻辑表示的转换规则。,从语言L1逻辑表示到语言L2的逻辑表示的转换规则,属于,不匹配
相对而言，这类不匹配也容易解决，例如，通过定义从语言L1逻辑表示到语言L2的逻辑表示的转换规则。,从语言L1逻辑表示到语言L2的逻辑表示的转换规则,实现,容易解决
3.原语的语义不匹配在语言层的另一个不匹配是语言原语的语义。,原语的语义不匹配,属于,语言层的另一个不匹配
3.原语的语义不匹配在语言层的另一个不匹配是语言原语的语义。,原语的语义不匹配,实现,语言原语的语义
3.原语的语义不匹配在语言层的另一个不匹配是语言原语的语义。,原语的语义不匹配,中文名,语义不匹配
尽管有时不同的语言使用同样名称的原语来进行本体构建，但它们的语义是有差异的。,本体构建,属于,不同的语言
尽管有时不同的语言使用同样名称的原语来进行本体构建，但它们的语义是有差异的。,本体构建,实现,相同的名称的原语
例如，在OWL_Lite和OWL_DL语言中，原语“Class”声明的对象只能作为本体中的概念，而在OWL_Full和RDF(S)中，“Class”声明的对象既可以作为一个类，也可以作为一个实例。,OWL_Lite,等价,“Class”声明的对象只能作为本体中的概念
例如，在OWL_Lite和OWL_DL语言中，原语“Class”声明的对象只能作为本体中的概念，而在OWL_Full和RDF(S)中，“Class”声明的对象既可以作为一个类，也可以作为一个实例。,OWL_DL语言,等价,“Class”声明的对象只能作为本体中的概念
例如，在OWL_Lite和OWL_DL语言中，原语“Class”声明的对象只能作为本体中的概念，而在OWL_Full和RDF(S)中，“Class”声明的对象既可以作为一个类，也可以作为一个实例。,OWL_Full,等价,“Class”声明的对象既可以作为一个类
例如，在OWL_Lite和OWL_DL语言中，原语“Class”声明的对象只能作为本体中的概念，而在OWL_Full和RDF(S)中，“Class”声明的对象既可以作为一个类，也可以作为一个实例。,RDF(S),等价,“Class”声明的对象既可以作为一个类也可以作为一个实例
有时，即使两个本体看起来使用同样的语法，但它们的语义是有差别的。,本体,属于,语法
有时，即使两个本体看起来使用同样的语法，但它们的语义是有差别的。,本体,实现,语义
例如，在OIL和RDF_Schema中，当定义一个关系时往往都需要声明关系的定义域，即<rdfs:domain>，但是OIL将<rdfs:domain>的声明解释为其中参数的交，而RDF_Schema则将它解释为这些参数的并。,OIL,等价,其中参数的交
例如，在OIL和RDF_Schema中，当定义一个关系时往往都需要声明关系的定义域，即<rdfs:domain>，但是OIL将<rdfs:domain>的声明解释为其中参数的交，而RDF_Schema则将它解释为这些参数的并。,RDF_Schema,等价,这些参数的并
因此，当采用不同语言的本体交互时，需要注意它们的原语表达的意义的差异。,本体交互,属于,采用不同语言的本体交互时，需要注意它们的原语表达的意义的差异
因此，当采用不同语言的本体交互时，需要注意它们的原语表达的意义的差异。,本体交互,实现,当采用不同语言的本体交互时，需要注意它们的原语表达的意义的差异
因此，当采用不同语言的本体交互时，需要注意它们的原语表达的意义的差异。,本体交互,中文名,本体交互
4.语言表达能力不匹配最后一种语言层的不匹配是指不同本体语言表达能力上的差异。,最后一种语言层的不匹配,属于,不同本体语言表达能力上的差异
4.语言表达能力不匹配最后一种语言层的不匹配是指不同本体语言表达能力上的差异。,最后一种语言层的不匹配,实现,语言表达能力不匹配
4.语言表达能力不匹配最后一种语言层的不匹配是指不同本体语言表达能力上的差异。,最后一种语言层的不匹配,中文名,不同本体语言表达能力上的差异
这种不匹配体现在一些本体语言能够表达的事情在另一些语言中不能表达出来。,本体语言,属于,能够表达事情在另一些语言中不能表达出来
这种不匹配体现在一些本体语言能够表达的事情在另一些语言中不能表达出来。,本体语言,实现,表达事情在另一些语言中不能表达出来
这种不匹配体现在一些本体语言能够表达的事情在另一些语言中不能表达出来。,本体语言,中文名,本体语言
这一类的不匹配对本体的互操作影响很大[4]。,不匹配,属于,本体的互操作
这一类的不匹配对本体的互操作影响很大[4]。,不匹配,实现,对本体的互操作影响很大
一般来说，当本体语言的表达能力不同时，为了方便解决本体之间的异构，需要将表达能力弱的语言向表达能力强的语言转换；但是，如果表达能力强的语言并不完全兼容表达能力弱的语言，这样的转换可能会造成信息的损失。,本体语言的表达能力,属于,将表达能力弱的语言向表达能力强的语言转换
一般来说，当本体语言的表达能力不同时，为了方便解决本体之间的异构，需要将表达能力弱的语言向表达能力强的语言转换；但是，如果表达能力强的语言并不完全兼容表达能力弱的语言，这样的转换可能会造成信息的损失。,本体语言的表达能力不同时,实现,将表达能力弱的语言向表达能力强的语言转换
一般来说，当本体语言的表达能力不同时，为了方便解决本体之间的异构，需要将表达能力弱的语言向表达能力强的语言转换；但是，如果表达能力强的语言并不完全兼容表达能力弱的语言，这样的转换可能会造成信息的损失。,本体语言的表达能力不同时,中文名,为了方便解决本体之间的异构
模型层次上的不匹配与使用的本体语言无关，它们既可以发生在以同一种语言表示的本体之间，也可以发生在使用不同语言的本体之间。,模型层次上的不匹配,属于,使用的本体语言无关
模型层次上的不匹配与使用的本体语言无关，它们既可以发生在以同一种语言表示的本体之间，也可以发生在使用不同语言的本体之间。,模型层次上的不匹配,实现,使用不同语言的本体之间
此外，在本体建模过程中需要从现实事物抽象出概念，并根据概念抽象层次的不同进行划分。,本体建模的五大用途或特点,属于,从现实事物抽象出概念并根据概念抽象层次的不同进行划分
此外，在本体建模过程中需要从现实事物抽象出概念，并根据概念抽象层次的不同进行划分。,本体建模的五大用途或特点,实现,根据概念抽象层次的不同进行划分
此外，在本体建模过程中需要从现实事物抽象出概念，并根据概念抽象层次的不同进行划分。,本体建模的五大用途或特点,中文名,从现实事物抽象出概念并根据概念抽象层次的不同进行划分
当不同的建模者对不同的概念进行划分时，可能会对一个概念的划分持有不同的观点。,概念的划分,属于,不同的建模者对不同的概念进行划分时，可能会对一个概念的划分持有不同的观点
当不同的建模者对不同的概念进行划分时，可能会对一个概念的划分持有不同的观点。,概念的划分,实现,当不同的建模者对不同的概念进行划分时，可能会对一个概念的划分持有不同的观点
当不同的建模者对不同的概念进行划分时，可能会对一个概念的划分持有不同的观点。,概念的划分,中文名,不同的建模者对不同的概念进行划分时，可能会对一个概念的划分持有不同的观点
例如，在考虑对动物相关的知识进行本体建模时，一些建模者将概念“动物”划分为“哺乳动物”和“鸟”两个子类，而另一些人则是把“动物”划分为“食肉动物”和“食草动物”。,概念“动物”,等价,“哺乳动物”
例如，在考虑对动物相关的知识进行本体建模时，一些建模者将概念“动物”划分为“哺乳动物”和“鸟”两个子类，而另一些人则是把“动物”划分为“食肉动物”和“食草动物”。,概念“动物”,等价,“鸟”
例如，在考虑对动物相关的知识进行本体建模时，一些建模者将概念“动物”划分为“哺乳动物”和“鸟”两个子类，而另一些人则是把“动物”划分为“食肉动物”和“食草动物”。,概念“动物”,等价,“食肉动物”
例如，在考虑对动物相关的知识进行本体建模时，一些建模者将概念“动物”划分为“哺乳动物”和“鸟”两个子类，而另一些人则是把“动物”划分为“食肉动物”和“食草动物”。,概念“动物”,等价,“食草动物”
最后，还存在将同一个概念定义在不同抽象层次上的不匹配。,概念定义,属于,将同一个概念定义在不同抽象层次上的不匹配
最后，还存在将同一个概念定义在不同抽象层次上的不匹配。,概念定义,实现,概念间的关系
例如，本体O1将人概念化为“Persons”，而本体O2没有“Persons”这样的概念，它用“Males”和“Females”来表示人。,O1,属于,将人概念化为“Persons”
例如，本体O1将人概念化为“Persons”，而本体O2没有“Persons”这样的概念，它用“Males”和“Females”来表示人。,O1,实现,“Persons”
例如，本体O1将人概念化为“Persons”，而本体O2没有“Persons”这样的概念，它用“Males”和“Females”来表示人。,O1,中文名,人概念
例如，本体O1将人概念化为“Persons”，而本体O2没有“Persons”这样的概念，它用“Males”和“Females”来表示人。,本体O1,等价,人
例如，本体O1将人概念化为“Persons”，而本体O2没有“Persons”这样的概念，它用“Males”和“Females”来表示人。,本体O2,等价,Males
例如，本体O1将人概念化为“Persons”，而本体O2没有“Persons”这样的概念，它用“Males”和“Females”来表示人。,本体O2,等价,Females
②模型的粒度，即本体对所建模的领域进行描述的详细程度，如有的本体仅仅列出概念，有的本体则进一步列出概念的属性，甚至概念之间所具有的各种关系等。,模型的粒度,属于,本体对所建模的领域进行描述的详细程度
②模型的粒度，即本体对所建模的领域进行描述的详细程度，如有的本体仅仅列出概念，有的本体则进一步列出概念的属性，甚至概念之间所具有的各种关系等。,模型的粒度,实现,列出概念
②模型的粒度，即本体对所建模的领域进行描述的详细程度，如有的本体仅仅列出概念，有的本体则进一步列出概念的属性，甚至概念之间所具有的各种关系等。,模型的粒度,实现,列出概念的属性
②模型的粒度，即本体对所建模的领域进行描述的详细程度，如有的本体仅仅列出概念，有的本体则进一步列出概念的属性，甚至概念之间所具有的各种关系等。,模型的粒度,实现,概念之间所具有的各种关系等
②模型的粒度，即本体对所建模的领域进行描述的详细程度，如有的本体仅仅列出概念，有的本体则进一步列出概念的属性，甚至概念之间所具有的各种关系等。,模型的粒度,中文名,本体对所建模的领域进行描述的详细程度
③本体建模的观点，这决定了本体从什么认识角度来描述领域内的知识。,本体建模的观点,属于,本体从什么认识角度来描述领域内的知识
③本体建模的观点，这决定了本体从什么认识角度来描述领域内的知识。,本体,实现,描述领域内的知识
③本体建模的观点，这决定了本体从什么认识角度来描述领域内的知识。,本体建模的观点,中文名,本体从什么认识角度来描述领域内的知识
从上述不同的维度进行本体建模所得到的结果都是有差异的。,本体建模,属于,从不同的维度进行本体建模所得到的结果都是有差异的
从上述不同的维度进行本体建模所得到的结果都是有差异的。,本体建模,实现,概念/产品
从上述不同的维度进行本体建模所得到的结果都是有差异的。,本体建模,中文名,从不同的维度进行本体建模所得到的结果都是有差异的
由于本体的建模反映了建模者的主观性，这一类的不匹配情况在实际应用中很普遍。,本体的建模,属于,反映主观性
由于本体的建模反映了建模者的主观性，这一类的不匹配情况在实际应用中很普遍。,本体的建模,实现,不匹配情况
由于本体的建模反映了建模者的主观性，这一类的不匹配情况在实际应用中很普遍。,本体的建模,中文名,反映主观性
不同的范例可用来表示相同的概念，这也就出现了不匹配。,范例,属于,表示相同的概念
不同的范例可用来表示相同的概念，这也就出现了不匹配。,不同的范例,实现,相同的概念
例如，对时间的表示可以采用基于时间间隔的方式，也可以使用基于时间点的方式[5]。,对时间的表示,属于,基于时间间隔的方式
例如，对时间的表示可以采用基于时间间隔的方式，也可以使用基于时间点的方式[5]。,对时间的表示,属于,基于时间点的方式
例如，对时间的表示可以采用基于时间间隔的方式，也可以使用基于时间点的方式[5]。,对时间的表示,实现,采用基于时间间隔的方式
例如，对时间的表示可以采用基于时间间隔的方式，也可以使用基于时间点的方式[5]。,对时间的表示,实现,采用基于时间点的方式
例如，对时间的表示可以采用基于时间间隔的方式，也可以使用基于时间点的方式[5]。,对时间的表示,中文名,基于时间间隔的方式
此外，在建模过程中使用不同的上层本体也往往会造成这一类的不匹配，因为不同上层本体往往对时间、行为、计划、因果和态度等概念有着不同的划分风格。,上层本体,属于,造成这一类的不匹配
此外，在建模过程中使用不同的上层本体也往往会造成这一类的不匹配，因为不同上层本体往往对时间、行为、计划、因果和态度等概念有着不同的划分风格。,建模过程中使用不同的上层本体,实现,造成这一类的不匹配
在本体建模中，对同一个概念的建模可以有几种选择。,对同一个概念的建模,属于,对本体建模
在本体建模中，对同一个概念的建模可以有几种选择。,对同一个概念的建模,实现,几种选择
例如，为了区别两个类，既可以使用一个合适的属性，也可以引入一个独立的新类。,区别两个类,属于,一个合适的属性
例如，为了区别两个类，既可以使用一个合适的属性，也可以引入一个独立的新类。,区别两个类,属于,引入一个独立的新类
例如，为了区别两个类，既可以使用一个合适的属性，也可以引入一个独立的新类。,区别两个类,实现,一个合适的属性
例如，为了区别两个类，既可以使用一个合适的属性，也可以引入一个独立的新类。,区别两个类,实现,引入一个独立的新类
例如，为了区别两个类，既可以使用一个合适的属性，也可以引入一个独立的新类。,区别两个类,中文名,一个合适的属性
例如，为了区别两个类，既可以使用一个合适的属性，也可以引入一个独立的新类。,区别两个类,中文名,引入一个独立的新类
然而，有的本体从高层到低层描述这种概念层次，有的则是从低层到高层来描述，这便造成了概念描述的不匹配。,本体,属于,从高层到低层描述这种概念层次
然而，有的本体从高层到低层描述这种概念层次，有的则是从低层到高层来描述，这便造成了概念描述的不匹配。,本体,属于,从低层到高层来描述
然而，有的本体从高层到低层描述这种概念层次，有的则是从低层到高层来描述，这便造成了概念描述的不匹配。,概念层次,实现,概念描述的不匹配
不同本体中含义上相同的概念常常由于建模者的习惯而被使用不同的名字表示。,本体中含义相同的概念,属于,不同的名字表示
不同本体中含义上相同的概念常常由于建模者的习惯而被使用不同的名字表示。,不同本体中含义上相同的概念,实现,不同的名字表示
另一类重要的建模术语不匹配是术语之间的同形异义现象。,不匹配,属于,术语之间的同形异义现象
另一类重要的建模术语不匹配是术语之间的同形异义现象。,不匹配,实现,术语之间的同形异义现象
另一类重要的建模术语不匹配是术语之间的同形异义现象。,不匹配,中文名,术语之间的同形异义现象
这种本体不匹配问题更加难以处理，往往需要考虑术语所处的上下文并借助人类的知识来解决。,本体不匹配问题,属于,难以处理
这种本体不匹配问题更加难以处理，往往需要考虑术语所处的上下文并借助人类的知识来解决。,本体不匹配问题,实现,考虑术语所处的上下文并借助人类的知识来解决
这种本体不匹配问题更加难以处理，往往需要考虑术语所处的上下文并借助人类的知识来解决。,本体不匹配问题,中文名,难以处理本体不匹配问题
最后的一种不匹配是由于本体表示中采用不同的编码格式造成的。,本体表示中采用不同的编码格式,属于,不匹配
最后的一种不匹配是由于本体表示中采用不同的编码格式造成的。,本体表示中采用不同的编码格式,实现,不同的编码格式造成的
这样的不匹配种类很多，没有通用的自动识别和发现算法。,自动识别和发现算法,属于,没有通用的自动识别和发现算法
这样的不匹配种类很多，没有通用的自动识别和发现算法。,自动识别和发现算法,实现,没有通用的自动识别和发现算法
这样的不匹配种类很多，没有通用的自动识别和发现算法。,自动识别和发现算法,中文名,没有通用的自动识别和发现算法
但是，如果能发现这种不匹配，对它的处理则是很容易的，一般只需要做一个转换就能消除。,SPO,属于,三元组抽取
但是，如果能发现这种不匹配，对它的处理则是很容易的，一般只需要做一个转换就能消除。,SPO,实现,消除不匹配
但是，如果能发现这种不匹配，对它的处理则是很容易的，一般只需要做一个转换就能消除。,SPO,中文名,三元组抽取
不同的系统都使用这个本体，这样便消除了由本体异构导致的互操作问题。,本体语义交互,属于,不同的系统
不同的系统都使用这个本体，这样便消除了由本体异构导致的互操作问题。,本体语义交互,实现,消除由本体异构导致的互操作问题
不同的系统都使用这个本体，这样便消除了由本体异构导致的互操作问题。,本体语义交互,中文名,本体语义交互
显然，在本体集成的过程中产生了新的本体，因此也有人将本体集成看作一种生成新本体的过程。,本体集成,属于,生成新本体的过程
显然，在本体集成的过程中产生了新的本体，因此也有人将本体集成看作一种生成新本体的过程。,本体集成,实现,产生新的本体
此外，集成过程通常利用了多个现有本体，因此这还是一种本体的重用[10]。,集成本体,属于,本体的重用
此外，集成过程通常利用了多个现有本体，因此这还是一种本体的重用[10]。,集成本体,实现,本体的重用
这样的集成方法虽然看起来很有效，但在实际应用中往往存在明显的缺点。,集成方法,属于,缺点
这样的集成方法虽然看起来很有效，但在实际应用中往往存在明显的缺点。,这样的集成方法,实现,缺点
首先，使用这些异构本体的系统往往有着不同的功能和侧重点，这些系统之间通常不是等价或可相互替代的，某些系统能处理一些特定和深入的问题，某些系统则可能处理全面和基础的问题。,异构本体,属于,不同的功能和侧重点
首先，使用这些异构本体的系统往往有着不同的功能和侧重点，这些系统之间通常不是等价或可相互替代的，某些系统能处理一些特定和深入的问题，某些系统则可能处理全面和基础的问题。,异构本体的系统,实现,处理特定和深入的问题
首先，使用这些异构本体的系统往往有着不同的功能和侧重点，这些系统之间通常不是等价或可相互替代的，某些系统能处理一些特定和深入的问题，某些系统则可能处理全面和基础的问题。,异构本体的系统,实现,处理全面和基础的问题
首先，使用这些异构本体的系统往往有着不同的功能和侧重点，这些系统之间通常不是等价或可相互替代的，某些系统能处理一些特定和深入的问题，某些系统则可能处理全面和基础的问题。,异构本体,中文名,不同的功能和侧重点
首先，使用这些异构本体的系统往往有着不同的功能和侧重点，这些系统之间通常不是等价或可相互替代的，某些系统能处理一些特定和深入的问题，某些系统则可能处理全面和基础的问题。,使用这些异构本体的系统,等价,不同的功能和侧重点
这样，集成后的本体对于其中的一些系统来说可能过于庞大，况且它们往往只使用该集成本体的一部分。,集成后的本体,属于,一些系统
这样，集成后的本体对于其中的一些系统来说可能过于庞大，况且它们往往只使用该集成本体的一部分。,集成后的本体,实现,对于其中的一些系统来说可能过于庞大
这样，集成后的本体对于其中的一些系统来说可能过于庞大，况且它们往往只使用该集成本体的一部分。,集成后的本体,中文名,集成本体
所以，从这些方面能看出单本体的集成缺乏灵活性。,单本体的集成,属于,缺乏灵活性
所以，从这些方面能看出单本体的集成缺乏灵活性。,单本体的集成,实现,缺乏灵活性
这种方法首先抽取异构本体之间的共同知识，根据它建立一个全局本体。,建立全局本体,属于,抽取异构本体之间的共同知识
这种方法首先抽取异构本体之间的共同知识，根据它建立一个全局本体。,建立全局本体,实现,建立一个全局本体
同时，各个系统可以拥有自己的本体，称为局部本体。,本体,属于,局部本体
同时，各个系统可以拥有自己的本体，称为局部本体。,本体,实现,各个系统
"局部本体既可以在全局本体的基础上根据自己的需要进行扩充，也可以直接建立自己特有的本体，但无论哪种方式，都需要建立局部本体与全局本体之间的映射[12,13]。",局部本体,属于,建立局部本体与全局本体之间的映射
"局部本体既可以在全局本体的基础上根据自己的需要进行扩充，也可以直接建立自己特有的本体，但无论哪种方式，都需要建立局部本体与全局本体之间的映射[12,13]。",局部本体,实现,根据自己的需要进行扩充
"局部本体既可以在全局本体的基础上根据自己的需要进行扩充，也可以直接建立自己特有的本体，但无论哪种方式，都需要建立局部本体与全局本体之间的映射[12,13]。",局部本体,中文名,建立局部本体与全局本体之间的映射
这样，局部本体侧重于特定的知识，而全局本体则保证不同系统间异构的部分能进行交互。,局部本体,属于,特定的知识
这样，局部本体侧重于特定的知识，而全局本体则保证不同系统间异构的部分能进行交互。,局部本体,实现,不同系统间异构的部分能进行交互
这种方法既避免了局部本体存在过多的冗余，本体规模不会过于庞大，同时也达到了解决本体间异构的目的。,本体集成,属于,解决本体间异构的方法
这种方法既避免了局部本体存在过多的冗余，本体规模不会过于庞大，同时也达到了解决本体间异构的目的。,本体集成,实现,避免局部本体存在过多的冗余
这种方法既避免了局部本体存在过多的冗余，本体规模不会过于庞大，同时也达到了解决本体间异构的目的。,本体集成,中文名,避免局部本体存在过多的冗余
每个局部本体可以独立开发，对它们进行修改不会影响其他的系统，只要保证与全局本体一致就可以。,局部本体,属于,独立开发
每个局部本体可以独立开发，对它们进行修改不会影响其他的系统，只要保证与全局本体一致就可以。,局部本体,实现,对其他系统的修改
但是全局本体—局部本体的本体集成方法也并不完美。,本体集成方法,属于,全局本体—局部本体的本体集成方法
但是全局本体—局部本体的本体集成方法也并不完美。,本体集成方法,实现,把全局本体与局部本体进行集成
但是全局本体—局部本体的本体集成方法也并不完美。,本体集成方法,中文名,全局本体与局部本体的本体集成方法
但总的来说，全局本体—局部本体的集成方法较单本体的集成方法灵活。,全局本体—局部本体的集成方法,属于,较单本体的集成方法灵活
但总的来说，全局本体—局部本体的集成方法较单本体的集成方法灵活。,全局本体—局部本体的集成方法,实现,较单本体的集成方法灵活
但总的来说，全局本体—局部本体的集成方法较单本体的集成方法灵活。,全局本体—局部本体的集成方法,中文名,较单本体的集成方法灵活
一方面，在很多本体集成过程中，映射可看作集成的子过程。,本体集成,属于,集成的子过程
一方面，在很多本体集成过程中，映射可看作集成的子过程。,本体集成,实现,映射
在单本体的本体集成中，需要分析不同本体之间的映射，才能够将它们集成为一个新的本体；在基于全局本体—局部本体的集成过程中，需要在局部本体和全局本体之间建立映射。,单本体的本体集成,属于,分析不同本体之间的映射
在单本体的本体集成中，需要分析不同本体之间的映射，才能够将它们集成为一个新的本体；在基于全局本体—局部本体的集成过程中，需要在局部本体和全局本体之间建立映射。,基于全局本体—局部本体的集成,实现,在局部本体和全局本体之间建立映射
此外，集成的本体对于不同的应用不具有通用性，缺乏灵活性。,本体,属于,不同的应用不具有通用性，缺乏灵活性
此外，集成的本体对于不同的应用不具有通用性，缺乏灵活性。,集成的本体,实现,不同的应用不具有通用性，缺乏灵活性
此外，集成的本体对于不同的应用不具有通用性，缺乏灵活性。,本体,中文名,本体
因此，本体集成不适合解决语义Web中分布和动态的多本体应用问题。,本体集成,属于,解决语义Web中分布和动态的多本体应用问题
因此，本体集成不适合解决语义Web中分布和动态的多本体应用问题。,本体集成,实现,不适合解决语义Web中分布和动态的多本体应用问题
因此，本体集成不适合解决语义Web中分布和动态的多本体应用问题。,本体集成,中文名,不适合解决语义Web中分布和动态的多本体应用问题
实际上，大多应用只需要实现本体间的互操作就可以满足需求，完全的集成是没有必要的。,本体间的互操作,属于,实现
实际上，大多应用只需要实现本体间的互操作就可以满足需求，完全的集成是没有必要的。,应用,实现,本体间的互操作
本体映射通过建立本体间的映射规则达到本体互操作，其形式比较灵活，更能适应分布动态的环境。,本体映射,属于,建立本体间的映射规则达到本体互操作
本体映射通过建立本体间的映射规则达到本体互操作，其形式比较灵活，更能适应分布动态的环境。,本体映射,实现,建立本体间的映射规则达到本体互操作
本体映射通过建立本体间的映射规则达到本体互操作，其形式比较灵活，更能适应分布动态的环境。,本体映射,中文名,建立本体间的映射规则达到本体互操作
1.映射的对象角度通过这个角度的分类，明确映射应该建立在异构本体的哪些成分之间。,映射的对象角度,属于,建立异构本体的成分之间
1.映射的对象角度通过这个角度的分类，明确映射应该建立在异构本体的哪些成分之间。,映射,实现,对象角度的分类
本体间的不匹配是造成本体异构的根本原因，这种不匹配可分为语言层和模型层两个层次。,本体间的不匹配,属于,造成本体异构的根本原因
本体间的不匹配是造成本体异构的根本原因，这种不匹配可分为语言层和模型层两个层次。,本体间的不匹配,实现,划分本体间的不匹配可分为语言层和模型层两个层次
本体间的不匹配是造成本体异构的根本原因，这种不匹配可分为语言层和模型层两个层次。,本体间的不匹配,中文名,本体异构
由于不同本体语言之间表达能力上的差异，这种转换有时会造成本体信息的损失。,本体语言之间表达能力上的差异,属于,造成本体信息的损失
由于不同本体语言之间表达能力上的差异，这种转换有时会造成本体信息的损失。,本体语言之间表达能力上的差异,实现,转换
因此，语言间的转换应该尽可能指向表达能力强的语言，以减少信息的损失。,语言间的转换,属于,指向表达能力强的语言
因此，语言间的转换应该尽可能指向表达能力强的语言，以减少信息的损失。,语言间的转换,实现,信息的损失
而实际上，通常的本体映射很少考虑语言层次上的异构。,本体映射,属于,考虑语言层次上的异构
而实际上，通常的本体映射很少考虑语言层次上的异构。,本体映射,实现,考虑语言层次上的异构
将不同语言表示的本体转换为相同的表示形式能方便映射处理。,本体转换,属于,将不同语言表示的本体转换为相同的表示形式
将不同语言表示的本体转换为相同的表示形式能方便映射处理。,本体转换,实现,方便映射处理
通常，这种转换带来的信息损失不应该对映射结果造成明显的影响。,映射,属于,转换带来的信息损失不应该对映射结果造成明显的影响。
通常，这种转换带来的信息损失不应该对映射结果造成明显的影响。,映射,实现,通常，这种转换带来的信息损失不应该对映射结果造成明显的影响。
通常，这种转换带来的信息损失不应该对映射结果造成明显的影响。,映射,中文名,转换带来的信息损失不应该对映射结果造成明显的影响。
建立异构本体的概念之间的映射是最基本的映射，因为概念是本体中最基本的成分，没有概念，其他的本体成分无从谈起。,建立异构本体的概念之间的映射,属于,最基本的映射
建立异构本体的概念之间的映射是最基本的映射，因为概念是本体中最基本的成分，没有概念，其他的本体成分无从谈起。,建立异构本体的概念之间的映射,实现,概念之间的映射
不同本体之间的实例也会出现异构，例如不同的实例名实际上表示同一个对象。,异构,属于,不同本体之间的实例
不同本体之间的实例也会出现异构，例如不同的实例名实际上表示同一个对象。,不同本体之间的实例,实现,实例名实际上表示同一个对象
为了检查实例之间是否等价，目前的方法基于属性匹配或逻辑推理[14]。,检查实例之间是否等价,属于,基于属性匹配或逻辑推理
为了检查实例之间是否等价，目前的方法基于属性匹配或逻辑推理[14]。,检查实例之间是否等价,实现,基于属性匹配或逻辑推理
为了检查实例之间是否等价，目前的方法基于属性匹配或逻辑推理[14]。,检查实例之间是否等价,中文名,基于属性匹配或逻辑推理
为了检查实例之间是否等价，目前的方法基于属性匹配或逻辑推理[14]。,检查实例之间是否等价,等价,基于属性匹配或逻辑推理
但是，逻辑推理的方法通常很耗时，而属性匹配的方法又很可能得到不确定的答案。,属性匹配,属于,逻辑推理的方法
但是，逻辑推理的方法通常很耗时，而属性匹配的方法又很可能得到不确定的答案。,属性匹配,实现,很耗时
XuBaowen等人提出了一种检查实例等价的框架[15]，这种方法同时使用了属性匹配和逻辑推理两种方法，并利用一种基于不相交集合并的算法来加速推理过程。,XuBaowen等人,等价,检查实例等价的框架
但总的来说，由于实例之间的映射情况比其他对象的映射简单，但是实例的数目太多，处理起来非常耗时，因此很多映射工作并不着重考虑实例上的映射。,实例间的映射,属于,其他对象的映射
但总的来说，由于实例之间的映射情况比其他对象的映射简单，但是实例的数目太多，处理起来非常耗时，因此很多映射工作并不着重考虑实例上的映射。,实例上的映射,实现,其他对象的映射
公理是本体中的一个重要成分，它是对其他本体成分的约束和限制。,公理,属于,本体中的一个重要成分
公理是本体中的一个重要成分，它是对其他本体成分的约束和限制。,公理,实现,对其他本体成分的约束和限制
通常，一个公理由一些操作符和本体成分组合而成。,公理,属于,本体成分组合而成
通常，一个公理由一些操作符和本体成分组合而成。,公理,实现,一些操作符
通常，一个公理由一些操作符和本体成分组合而成。,公理,中文名,公理由
因此，如果两个本体使用的表示语言都支持同样的操作符，那么公理之间的映射便可以转换为其他成分之间的映射。,本体公理之间的映射,属于,其他成分之间的映射
因此，如果两个本体使用的表示语言都支持同样的操作符，那么公理之间的映射便可以转换为其他成分之间的映射。,公理之间的映射,实现,其他成分之间的映射
除非有特殊的要求，一般不考虑针对实例或公理之间的映射。,SPO,属于,概念/SPO
除非有特殊的要求，一般不考虑针对实例或公理之间的映射。,针对实例或公理之间的映射,实现,不考虑
除非有特殊的要求，一般不考虑针对实例或公理之间的映射。,SPO,中文名,三元组
确定在本体的何种成分之间建立映射并不足够，还需要进一步明确这样的映射具有什么功能。,映射,属于,在本体的何种成分之间建立映射并不足够，还需要进一步明确这样的映射具有什么功能。
确定在本体的何种成分之间建立映射并不足够，还需要进一步明确这样的映射具有什么功能。,在本体的何种成分之间建立映射并不足够，还需要进一步明确这样的映射具有什么功能。,实现,明确这样的映射具有什么功能。
确定在本体的何种成分之间建立映射并不足够，还需要进一步明确这样的映射具有什么功能。,映射,中文名,在本体的何种成分之间建立映射并不足够，还需要进一步明确这样的映射具有什么功能。
现有大多数本体映射研究的问题在于只考虑几种最基本和常见的映射功能，如概念间的等价和包含，以及关系间的等价等，而没有充分考虑异构本体间各种有用的映射功能。,本体映射,等价,几种最基本和常见的映射功能
这11种桥基本能描述异构本体间具有的映射功能。,桥,属于,本体间具有的映射功能
这11种桥基本能描述异构本体间具有的映射功能。,桥,实现,异构本体间具有的映射功能
最基本的映射功能是等价映射，是为了建立不同本体的成分之间的等价关系。,等价映射,属于,建立不同本体的成分之间的等价关系
最基本的映射功能是等价映射，是为了建立不同本体的成分之间的等价关系。,等价映射,实现,映射功能
最基本的映射功能是等价映射，是为了建立不同本体的成分之间的等价关系。,等价映射,等价,建立不同本体的成分之间的等价关系
等价映射声明了概念之间和关系之间的对应，异构本体的等价成分之间在互操作过程中可以直接相互替代。,等价映射,等价,概念之间和关系之间的对应
同形异义的映射能够指出表示名称相同的本体成分实际上含义是不同的。,同形异义的映射,属于,指出表示名称相同的本体成分实际上含义是不同的
同形异义的映射能够指出表示名称相同的本体成分实际上含义是不同的。,同形异义的映射,实现,表示名称相同的本体成分实际上含义是不同的
概念上的部分映射则表示了来自不同概念间的个体具有整体—部分关系。,整体—部分关系,属于,概念上的部分映射
概念上的部分映射则表示了来自不同概念间的个体具有整体—部分关系。,整体—部分关系,实现,来自不同概念间的个体具有整体—部分关系
概念上的部分映射则表示了来自不同概念间的个体具有整体—部分关系。,整体—部分关系,中文名,整体—部分关系
此外，通过一些特殊的连接映射，还能将不同的本体概念相互联系起来。,连接映射,属于,将不同的本体概念相互联系起来
此外，通过一些特殊的连接映射，还能将不同的本体概念相互联系起来。,连接映射,实现,不同的本体概念相互联系起来
从功能上归纳和区分上述映射具有重要的意义。,映射,属于,从功能上归纳和区分上述
从功能上归纳和区分上述映射具有重要的意义。,上述映射,实现,从功能上归纳和区分
其次，区分具体的映射功能对于实际应用来说非常重要，不同功能的映射在处理本体互操作中扮演的角色会有不同，有的映射仅仅为了建立本体之间的数据转换的规则，有的映射还能用于进行跨本体的推理和查询应用。,映射功能,属于,建立本体之间的数据转换的规则
其次，区分具体的映射功能对于实际应用来说非常重要，不同功能的映射在处理本体互操作中扮演的角色会有不同，有的映射仅仅为了建立本体之间的数据转换的规则，有的映射还能用于进行跨本体的推理和查询应用。,映射,实现,建立本体之间的数据转换的规则
其次，区分具体的映射功能对于实际应用来说非常重要，不同功能的映射在处理本体互操作中扮演的角色会有不同，有的映射仅仅为了建立本体之间的数据转换的规则，有的映射还能用于进行跨本体的推理和查询应用。,映射,实现,进行跨本体的推理和查询应用
本体间的映射还具有复杂和简单之分，这需要同时考虑映射涉及的对象和映射具有的功能。,本体间的映射,属于,复杂映射
本体间的映射还具有复杂和简单之分，这需要同时考虑映射涉及的对象和映射具有的功能。,本体间的映射,属于,简单映射
本体间的映射还具有复杂和简单之分，这需要同时考虑映射涉及的对象和映射具有的功能。,本体间的映射,实现,同时考虑映射涉及的对象和映射具有的功能
本体间的映射还具有复杂和简单之分，这需要同时考虑映射涉及的对象和映射具有的功能。,本体间的映射,中文名,复杂映射
实际上，复杂映射和简单映射的界限很难界定。,复杂映射,属于,概念/映射
实际上，复杂映射和简单映射的界限很难界定。,复杂映射,实现,查询映射中概念和属性之间的对应关系
实际上，复杂映射和简单映射的界限很难界定。,复杂映射,中文名,查询映射中概念和属性之间的对应关系
通常，将那些基本的、必要的、组成简单的和发现过程相对容易的映射称作简单映射；将那些不直观的、组成复杂并且发现过程相对困难的映射称为复杂映射。,简单映射,属于,基本的、必要的、组成简单的和发现过程相对容易的映射
通常，将那些基本的、必要的、组成简单的和发现过程相对容易的映射称作简单映射；将那些不直观的、组成复杂并且发现过程相对困难的映射称为复杂映射。,简单映射,实现,组成简单的和发现过程相对容易的映射
通常，将那些基本的、必要的、组成简单的和发现过程相对容易的映射称作简单映射；将那些不直观的、组成复杂并且发现过程相对困难的映射称为复杂映射。,复杂映射,实现,不直观的、组成复杂并且发现过程相对困难的映射
通常，将那些基本的、必要的、组成简单的和发现过程相对容易的映射称作简单映射；将那些不直观的、组成复杂并且发现过程相对困难的映射称为复杂映射。,简单映射,中文名,基本的、必要的、组成简单的和发现过程相对容易的映射
通常，将那些基本的、必要的、组成简单的和发现过程相对容易的映射称作简单映射；将那些不直观的、组成复杂并且发现过程相对困难的映射称为复杂映射。,复杂映射,中文名,不直观的、组成复杂并且发现过程相对困难的映射
这里的复杂映射同时考虑映射对象和映射功能。,复杂映射,属于,映射对象和映射功能
这里的复杂映射同时考虑映射对象和映射功能。,复杂映射,实现,同时考虑映射对象和映射功能
从映射对象上，将那些包含复杂概念的映射看作是复杂映射，这里的复杂概念指通过概念的并、交和非等算子构成的复合概念，涉及这一类复杂概念的映射寻找方法相对单个的原子概念来说较为困难。,涉及这一类复杂概念的映射,属于,寻找方法相对单个的原子概念来说较为困难
从映射对象上，将那些包含复杂概念的映射看作是复杂映射，这里的复杂概念指通过概念的并、交和非等算子构成的复合概念，涉及这一类复杂概念的映射寻找方法相对单个的原子概念来说较为困难。,复杂映射,实现,将那些包含复杂概念的映射看作
从映射对象上，将那些包含复杂概念的映射看作是复杂映射，这里的复杂概念指通过概念的并、交和非等算子构成的复合概念，涉及这一类复杂概念的映射寻找方法相对单个的原子概念来说较为困难。,复杂映射,中文名,涉及这一类复杂概念的映射寻找方法相对单个的原子概念来说较为困难
从映射对象上，将那些包含复杂概念的映射看作是复杂映射，这里的复杂概念指通过概念的并、交和非等算子构成的复合概念，涉及这一类复杂概念的映射寻找方法相对单个的原子概念来说较为困难。,涉及这一类复杂概念的映射,等价,寻找方法相对单个的原子概念来说较为困难
而由于关系的映射发现方法通常都不容易，因此无论是原子关系还是复杂关系上的映射均看作复杂映射。,映射发现方法,属于,不容易
而由于关系的映射发现方法通常都不容易，因此无论是原子关系还是复杂关系上的映射均看作复杂映射。,关系的映射,实现,原子关系上的映射
而由于关系的映射发现方法通常都不容易，因此无论是原子关系还是复杂关系上的映射均看作复杂映射。,映射发现方法,中文名,不容易
从功能上看，除概念和关系上的等价映射以及概念上的上义和下义外，其余的映射功能都属于复杂映射。,映射功能,属于,复杂映射
从功能上看，除概念和关系上的等价映射以及概念上的上义和下义外，其余的映射功能都属于复杂映射。,概念等价映射,实现,概念上等价映射上的等价映射以及概念上等价映射上的等价映射以及概念上上义和下义
从功能上看，除概念和关系上的等价映射以及概念上的上义和下义外，其余的映射功能都属于复杂映射。,映射功能,中文名,概念和关系上的等价映射以及概念和关系上的等价映射以及概念和关系上上义和下义
从功能上看，除概念和关系上的等价映射以及概念上的上义和下义外，其余的映射功能都属于复杂映射。,复杂映射,等价,概念和关系上的等价映射以及概念上的上义和下义
基于这种思想，本体映射的分类如表5-1所示，其中“+”表示这种映射存在，“×”表示这种映射不存在，背景为深色表示这种映射是复杂映射。,本体映射的分类,等价,背景为深色表示这种映射是复杂映射。
从表中可以看出，存在的本体映射中大部分都属于复杂映射。,本体映射,属于,复杂映射
从表中可以看出，存在的本体映射中大部分都属于复杂映射。,本体映射,实现,查询本体映射
接下来从这些层次入手，逐步阐述映射的发现、表示和应用问题。,映射的发现、表示和应用问题,属于,这些层次
接下来从这些层次入手，逐步阐述映射的发现、表示和应用问题。,映射的发现、表示和应用问题,实现,逐步阐述
接下来从这些层次入手，逐步阐述映射的发现、表示和应用问题。,映射的发现、表示和应用问题,中文名,这些层次入手，逐步阐述映射的发现、表示和应用问题
尽管本体间的映射可以通过手工建立，但非常耗时，而且很容易出错[18]。,本体间的映射,属于,手工建立
尽管本体间的映射可以通过手工建立，但非常耗时，而且很容易出错[18]。,本体间的映射,实现,通过手工建立
因此，目前的研究侧重于开发合理的映射发现方法和工具，采用自动或半自动的方式来构建。,映射发现,属于,开发合理的映射发现方法和工具
因此，目前的研究侧重于开发合理的映射发现方法和工具，采用自动或半自动的方式来构建。,构建,实现,采用自动或半自动的方式来构建
因此，目前的研究侧重于开发合理的映射发现方法和工具，采用自动或半自动的方式来构建。,映射发现,中文名,开发合理的映射发现方法和工具
尽管不同的本体映射方法使用的技术不同，但过程基本是相似的。,本体映射方法,属于,不同的本体映射方法使用的技术
尽管不同的本体映射方法使用的技术不同，但过程基本是相似的。,本体映射方法,实现,过程的相似
待映射的本体不一定都要转换为统一的本体语言格式，但是要保证本体中需要进行映射的成分能够被方便获取。,待映射的本体,属于,进行映射的成分
待映射的本体不一定都要转换为统一的本体语言格式，但是要保证本体中需要进行映射的成分能够被方便获取。,待映射的本体,实现,保证本体中需要进行映射的成分能够被方便获取
当然，如果映射比较简单或者难以找到合适的映射发现算法，也可以通过人工来发现本体间的映射。,本体间的映射发现,属于,映射发现算法
当然，如果映射比较简单或者难以找到合适的映射发现算法，也可以通过人工来发现本体间的映射。,本体间的映射发现,实现,人工来发现本体间的映射
当然，如果映射比较简单或者难以找到合适的映射发现算法，也可以通过人工来发现本体间的映射。,本体间的映射发现,中文名,本体间的映射发现算法
当本体之间的映射被找到后，需要将这些映射合理地表示起来。,本体之间的映射,属于,表示
当本体之间的映射被找到后，需要将这些映射合理地表示起来。,本体之间的映射,实现,合理地表示起来
在发现映射后，需要根据映射的类型，借助工具将发现的映射合理表示和组织。,根据映射的类型，借助工具将发现的映射合理表示和组织,属于,在发现映射后，根据映射的类型
在发现映射后，需要根据映射的类型，借助工具将发现的映射合理表示和组织。,根据映射的类型，借助工具将发现的映射合理表示和组织,实现,根据映射的类型，借助工具将发现的映射合理表示和组织
在发现映射后，需要根据映射的类型，借助工具将发现的映射合理表示和组织。,根据映射的类型，借助工具将发现的映射合理表示和组织,中文名,根据映射的类型，借助工具将发现的映射合理表示和组织
同时，不同的映射发现方法能处理的映射类型和具体过程都有很大差别[17]。,映射发现方法,属于,处理的映射类型和具体过程都有很大差别
同时，不同的映射发现方法能处理的映射类型和具体过程都有很大差别[17]。,映射发现方法,实现,处理的映射类型和具体过程都有很大差别
同时，不同的映射发现方法能处理的映射类型和具体过程都有很大差别[17]。,映射发现方法,中文名,处理的映射类型和具体过程都有很大差别
根据使用技术的不同，下面分别介绍一些典型的本体映射工作。,本体映射工作,属于,根据使用技术的不同
根据使用技术的不同，下面分别介绍一些典型的本体映射工作。,本体映射工作,实现,根据使用技术的不同，下面分别介绍一些典型的本体映射工作。
根据使用技术的不同，下面分别介绍一些典型的本体映射工作。,本体映射工作,中文名,根据使用技术的不同分别介绍一些典型的本体映射工作
很多映射工作可能同时采用了多种映射发现技术，如果其中的某一种技术较为突出，则将这个工作划分到这一种技术的分类下；如果几种技术的重要程度比较均衡，则将这样的工作划分为综合方法。,一种技术的分类,属于,多种映射发现技术
很多映射工作可能同时采用了多种映射发现技术，如果其中的某一种技术较为突出，则将这个工作划分到这一种技术的分类下；如果几种技术的重要程度比较均衡，则将这样的工作划分为综合方法。,这样的工作,实现,划分到这一种技术的分类下
很多映射工作可能同时采用了多种映射发现技术，如果其中的某一种技术较为突出，则将这个工作划分到这一种技术的分类下；如果几种技术的重要程度比较均衡，则将这样的工作划分为综合方法。,一种技术的分类,中文名,多种映射发现技术
这里先介绍这种方法的思想，然后探讨一些典型和相关的工作。,本体论,属于,概念/产品
这里先介绍这种方法的思想，然后探讨一些典型和相关的工作。,本体论,实现,概念/产品
这里先介绍这种方法的思想，然后探讨一些典型和相关的工作。,本体论,中文名,概念/产品
比较本体间的术语的方法又可分为基于字符串的方法和基于语言的方法。,比较本体间的术语的方法,属于,基于字符串的方法
比较本体间的术语的方法又可分为基于字符串的方法和基于语言的方法。,比较本体间的术语的方法,属于,基于语言的方法
比较本体间的术语的方法又可分为基于字符串的方法和基于语言的方法。,比较本体间的术语的方法,实现,基于字符串的方法
比较本体间的术语的方法又可分为基于字符串的方法和基于语言的方法。,比较本体间的术语的方法,实现,基于语言的方法
比较本体间的术语的方法又可分为基于字符串的方法和基于语言的方法。,比较本体间的术语的方法,中文名,基于字符串的方法
基于字符串的方法直接比较表示本体成分的术语的字符串结构。,基于字符串的方法直接比较表示本体成分的术语的字符串结构,属于,基于字符串的方法直接比较表示本体成分的术语
基于字符串的方法直接比较表示本体成分的术语的字符串结构。,基于字符串的方法直接比较表示本体成分的术语的字符串结构,实现,直接比较表示本体成分的术语的字符串结构
字符串比较的方法有很多，Cohen_W等人系统地分析和比较了各种字符串比较技术[21]。,字符串比较的方法,属于,分析比较各种字符串比较技术
字符串比较的方法有很多，Cohen_W等人系统地分析和比较了各种字符串比较技术[21]。,字符串比较的方法,实现,分析和比较各种字符串比较技术
字符串比较的方法有很多，Cohen_W等人系统地分析和比较了各种字符串比较技术[21]。,字符串比较的方法,中文名,比较各种字符串比较技术
在进行严格字符串比较之前，需要对字符串进行规范化，这能提高后续比较的结果。,规范化,属于,严格字符串比较之前，需要对字符串进行规范化
在进行严格字符串比较之前，需要对字符串进行规范化，这能提高后续比较的结果。,严格字符串比较之前，需要对字符串进行规范化,实现,提高后续比较的结果
在进行严格字符串比较之前，需要对字符串进行规范化，这能提高后续比较的结果。,规范化,中文名,对字符串进行规范化
这些规范化操作主要针对拉丁语系，对于其他的语言来说，规范化过程会有所不同。,规范化操作,属于,拉丁语系
这些规范化操作主要针对拉丁语系，对于其他的语言来说，规范化过程会有所不同。,规范化操作,实现,对于其他的语言来说，规范化过程会有所不同
在规范字符串的基础上，能进一步度量不同字符串间的相似程度。,相似度量,属于,规范字符串
在规范字符串的基础上，能进一步度量不同字符串间的相似程度。,相似度量,实现,度量不同字符串间的相似程度
常用的字符串度量方法有：汉明距离、子串相似度、编辑距离和路径距离等。,常用的字符串度量方法,属于,字符串度量方法
常用的字符串度量方法有：汉明距离、子串相似度、编辑距离和路径距离等。,编辑距离,实现,字符串度量
常用的字符串度量方法有：汉明距离、子串相似度、编辑距离和路径距离等。,编辑距离,中文名,字符串度量方法
"如果两个字符串完全相同，它们间的相似度为1；如果字符串间不存在任何相似，则相似度为0；如果字符串间存在部分相似，则相似度为区间(0,1)中的某个值。",相似度,属于,字符串间不存在任何相似
"如果两个字符串完全相同，它们间的相似度为1；如果字符串间不存在任何相似，则相似度为0；如果字符串间存在部分相似，则相似度为区间(0,1)中的某个值。",相似度,实现,如果两个字符串完全相同
定义5.2任意两字符串s和t，如果存在两个字符串p和q，且s=p+t+q或t=p+s+q，那么称t是s的子串或s是t的子串。,子串,属于,任意两字符串s和t
定义5.2任意两字符串s和t，如果存在两个字符串p和q，且s=p+t+q或t=p+s+q，那么称t是s的子串或s是t的子串。,子串,实现,s=p+t+q或t=p+s+q
定义5.2任意两字符串s和t，如果存在两个字符串p和q，且s=p+t+q或t=p+s+q，那么称t是s的子串或s是t的子串。,子串,等价,两字符串s和t
还可进一步精确度量两字符串包含共同部分的比例，即子串相似度。,子串相似度,属于,精确度量两字符串包含共同部分的比例
还可进一步精确度量两字符串包含共同部分的比例，即子串相似度。,子串相似度,实现,进一步精确度量两字符串包含共同部分的比例，即子串相似度
定义5.3子串相似度度量任意两个字符串s和t间的相似度δ，令x为s和t的最大共同子串，则它们的子串相似度为：字符串间的相似度还能通过编辑距离来度量。,子串相似度度量,属于,任意两个字符串s和t间的相似度δ
定义5.3子串相似度度量任意两个字符串s和t间的相似度δ，令x为s和t的最大共同子串，则它们的子串相似度为：字符串间的相似度还能通过编辑距离来度量。,编辑距离,实现,字符串间的相似度
两字符串之间的编辑距离是指修改其中一个使之与另一个相同所需要的最小操作代价。,编辑距离,属于,计算两个字符串之间编辑操作的最小数量
两字符串之间的编辑距离是指修改其中一个使之与另一个相同所需要的最小操作代价。,编辑距离,实现,计算两个字符串之间编辑操作的最小数量
两字符串之间的编辑距离是指修改其中一个使之与另一个相同所需要的最小操作代价。,编辑距离,中文名,编辑两个字符串之间最小操作数量
显然，编辑距离越大，表示两字符串的相似程度越小。,编辑距离,属于,相似程度越小
显然，编辑距离越大，表示两字符串的相似程度越小。,编辑距离,实现,两字符串的相似程度越小
路径比较便是这类方法中的一种。,路径比较,属于,方法
路径比较便是这类方法中的一种。,路径比较,实现,比较两个路径
例如，比较两个概念的相似度时，可以将它们的所有父概念集中起来，并在相似度计算中考虑这些路径上的概念。,相似度计算,属于,比较两个概念的相似度
例如，比较两个概念的相似度时，可以将它们的所有父概念集中起来，并在相似度计算中考虑这些路径上的概念。,相似度计算,实现,将它们的所有父概念集中起来
例如，比较两个概念的相似度时，可以将它们的所有父概念集中起来，并在相似度计算中考虑这些路径上的概念。,相似度计算,中文名,比较两个概念的相似度
"定义5.5给定两个字符串序列和，它们之间的路径距离计算如下：有式中，δ’是某种字符串度量函数，并且λ∈[0,1]；当比较的两条路径出现空路径时，。",路径距离,属于,给定两个字符串序列和它们之间的路径距离计算
"定义5.5给定两个字符串序列和，它们之间的路径距离计算如下：有式中，δ’是某种字符串度量函数，并且λ∈[0,1]；当比较的两条路径出现空路径时，。",路径距离,实现,当比较的两条路径出现空路径时，
基于语言的方法依靠自然语言处理技术寻找概念或关系之间的联系。,基于语言的方法,属于,寻找概念或关系之间的联系
基于语言的方法依靠自然语言处理技术寻找概念或关系之间的联系。,基于语言的方法,实现,依靠自然语言处理技术
这类方法又可分为内部方法和外部方法，前者使用语言的内部属性，如形态和语法特点，后者则利用外部的资源，如词典等。,内部方法,属于,语言内部属性
这类方法又可分为内部方法和外部方法，前者使用语言的内部属性，如形态和语法特点，后者则利用外部的资源，如词典等。,内部方法,实现,使用语言的内部属性
它寻找同一字符串的不同语言形态，如Apple和Apples等。,SPO,属于,概念/查询相似度
它寻找同一字符串的不同语言形态，如Apple和Apples等。,SPO,实现,寻找同一字符串的不同语言形态
寻找词形变化的算法很多，最著名的是Porter_M_F提出的Stemming算法[22]。,Porter_M_F,属于,寻找词形变化的算法
寻找词形变化的算法很多，最著名的是Porter_M_F提出的Stemming算法[22]。,Porter_M_F,实现,Stemming算法
寻找词形变化的算法很多，最著名的是Porter_M_F提出的Stemming算法[22]。,Porter_M_F,中文名,Porter_M_F
例如，使用WordNet能判断两个术语是否有同义或上下义关系。,WordNet,属于,判断两个术语是否有同义或上下义关系
例如，使用WordNet能判断两个术语是否有同义或上下义关系。,WordNet,实现,能判断两个术语是否有同义或上下义关系
尽管基于术语的相似度度量方法很多，但是根据它很难得到比较好的映射结果，一般仅能判断概念或关系之间等价的可能程度，而对于发现其他功能的映射来说，基于术语的方法难以达到满意的效果。,基于术语的相似度度量方法,等价,根据它很难得到比较好的映射结果
基于结构的方法又可分为内部结构和外部结构，前者考虑本体的概念或关系的属性和属性值的数据类型等，后者则考虑与其他成分间的联系。,基于结构的方法,属于,内部结构
基于结构的方法又可分为内部结构和外部结构，前者考虑本体的概念或关系的属性和属性值的数据类型等，后者则考虑与其他成分间的联系。,基于结构的方法,属于,外部结构
基于结构的方法又可分为内部结构和外部结构，前者考虑本体的概念或关系的属性和属性值的数据类型等，后者则考虑与其他成分间的联系。,内部结构,实现,考虑本体的概念或关系的属性和属性值的数据类型等
基于结构的方法又可分为内部结构和外部结构，前者考虑本体的概念或关系的属性和属性值的数据类型等，后者则考虑与其他成分间的联系。,外部结构,实现,考虑与其他成分间的联系
基于结构的方法又可分为内部结构和外部结构，前者考虑本体的概念或关系的属性和属性值的数据类型等，后者则考虑与其他成分间的联系。,基于结构的方法,中文名,内部结构
通常，具有相同属性或者属性的数据类型相同的概念之间的相似度可能性较大。,相似度,属于,概念之间的相似度
通常，具有相同属性或者属性的数据类型相同的概念之间的相似度可能性较大。,相似度,实现,具有相同属性或者属性的数据类型相同的概念
通常，具有相同属性或者属性的数据类型相同的概念之间的相似度可能性较大。,相似度,中文名,概念之间的相似度
有一些常用来判断本体成分相似的准则，这些准则包括：(C1)直接超类或所有的超类相似；(C2)兄弟相似；(C3)直接子类或所有的子类相似；(C4)所有或大部分后继（不一定是子类，可能通过其他关系连接）相似；(C5)所有或大部分的叶子成分相似；(C6)从根节点到当前节点的路径上的实体都相似。,本体成分相似的准则,属于,判断本体成分相似的准则
有一些常用来判断本体成分相似的准则，这些准则包括：(C1)直接超类或所有的超类相似；(C2)兄弟相似；(C3)直接子类或所有的子类相似；(C4)所有或大部分后继（不一定是子类，可能通过其他关系连接）相似；(C5)所有或大部分的叶子成分相似；(C6)从根节点到当前节点的路径上的实体都相似。,本体成分相似的准则,实现,(C1)直接超类或所有的超类相似；(C2)兄弟相似；(C3)直接子类或所有的子类相似；(C4)所有或大部分后继（不一定是子类，可能通过其他关系连接）相似；(C5)所有或大部分的叶子成分相似；(C6)从根节点到当前节点的路径上的实体都相似。
如果概念A和B通过关系R建立联系，并且概念A’和B’间具有关系R'，如果已知B和B’以及R和R’分别相似，则可以推出概念A和A’也相似[24]。,关系R,属于,建立联系
如果概念A和B通过关系R建立联系，并且概念A’和B’间具有关系R'，如果已知B和B’以及R和R’分别相似，则可以推出概念A和A’也相似[24]。,关系R',实现,推出概念A和A’也相似
基于结构的方法难以解决这种不同划分下的子类之间的相似度问题。,基于结构的方法,属于,难以解决这种不同划分下的子类之间的相似度问题
基于结构的方法难以解决这种不同划分下的子类之间的相似度问题。,基于结构的方法,实现,不同划分下的子类之间的相似度问题
目前，PROMPT的这些工具已集成到Protégé系统中。,PROMPT,属于,Protégé
目前，PROMPT的这些工具已集成到Protégé系统中。,PROMPT,实现,集成到Protégé系统中
"为了发现本体间的映射，Noy_N_F等人于1999年就开发了SMART算法[26,27]，该方法通过比较概念名的相似性，识别异构本体间的等价概念。",SMART算法,等价,比较概念名的相似性
图中通过一条边连接的两节点称为相邻节点。,相邻节点,属于,一条边连接的两节点
图中通过一条边连接的两节点称为相邻节点。,相邻节点,实现,通过一条边连接的两节点称为
图中通过一条边连接的两节点称为相邻节点。,相邻节点,中文名,通过一条边连接的两节点称为
对所有起始节点和终止节点间的全部路径，算法重复这个过程，并累计概念对上的相似度分数。,概念对上的相似度分数,属于,算法
对所有起始节点和终止节点间的全部路径，算法重复这个过程，并累计概念对上的相似度分数。,概念对上的相似度分数,实现,对所有起始节点和终止节点间的全部路径
对所有起始节点和终止节点间的全部路径，算法重复这个过程，并累计概念对上的相似度分数。,概念对上的相似度分数,中文名,概念对上的相似度分数上的相似度分数
因此，根据最初给定的相关术语对的小集合，AnchorPROMPT算法能够产生本体间大量可能的语义相似术语对。,AnchorPROMPT算法,属于,产生本体间大量可能的语义相似术语对
因此，根据最初给定的相关术语对的小集合，AnchorPROMPT算法能够产生本体间大量可能的语义相似术语对。,AnchorPROMPT算法,实现,给定的相关术语对的小集合
因此，根据最初给定的相关术语对的小集合，AnchorPROMPT算法能够产生本体间大量可能的语义相似术语对。,AnchorPROMPT算法,中文名,产生本体间大量可能的语义相似术语对
这样的术语对利用基本的术语比较技术能很容易识别出来。,基本的术语比较技术,属于,识别出来
这样的术语对利用基本的术语比较技术能很容易识别出来。,基本的术语比较技术,实现,利用基本的术语比较技术能很容易识别出来
这样的术语对利用基本的术语比较技术能很容易识别出来。,基本的术语比较技术,中文名,利用基本的术语比较技术能很容易识别出来
根据输入的相关术语对，算法能寻找到相关术语对之间的路径集合。,算法,属于,寻找相关术语对之间的路径集合
根据输入的相关术语对，算法能寻找到相关术语对之间的路径集合。,算法,实现,寻找到相关术语对之间的路径集合
对于上面的两对相关术语，在本体O1中存在一条“TRIAL”和“PERSON”之间的路径，在本体O2中也存在二条从“Trial”到“Person”之间的路径。,TRIAL,属于,本体O1
对于上面的两对相关术语，在本体O1中存在一条“TRIAL”和“PERSON”之间的路径，在本体O2中也存在二条从“Trial”到“Person”之间的路径。,TRIAL,实现,路径
在实际应用中，这样的路径数目可能有很多，为了减少大量的比较操作，可以通过预先定义路径长度来限制路径的总数，如规定只考虑长度小于5的路径等。,路径长度限制,属于,预先定义路径长度
在实际应用中，这样的路径数目可能有很多，为了减少大量的比较操作，可以通过预先定义路径长度来限制路径的总数，如规定只考虑长度小于5的路径等。,路径长度限制,实现,减少大量的比较操作
"在这个例子中，算法增加这两对概念的相似度分数，即概念对(PROTOCOL,Design)和(STUDY-SITE,Blinding)。",概念对,等价,"(PROTOCOL,Design)"
"在这个例子中，算法增加这两对概念的相似度分数，即概念对(PROTOCOL,Design)和(STUDY-SITE,Blinding)。",概念对,等价,"(STUDY-SITE,Blinding)"
AnchorPROMPT算法重复以上过程，直到并行遍历完相关术语对之间的这种路径，每次遍历都累加符合条件的概念对的相似度分数。,AnchorPROMPT算法,属于,并行遍历相关术语对之间的这种路径，每次遍历都累加符合条件的概念对的相似度分数
AnchorPROMPT算法重复以上过程，直到并行遍历完相关术语对之间的这种路径，每次遍历都累加符合条件的概念对的相似度分数。,AnchorPROMPT算法,实现,累加符合条件的概念对的相似度分数
AnchorPROMPT算法重复以上过程，直到并行遍历完相关术语对之间的这种路径，每次遍历都累加符合条件的概念对的相似度分数。,AnchorPROMPT算法,中文名,并行遍历相关术语对之间的这种路径，每次遍历都累加符合条件的概念对的相似度分数
结果，经常出现在相同位置的术语对间的相似度分数往往最高。,相似度分数,属于,经常出现在相同位置的术语对间的相似度分数
结果，经常出现在相同位置的术语对间的相似度分数往往最高。,相似度分数,实现,计算相似度
结果，经常出现在相同位置的术语对间的相似度分数往往最高。,相似度分数,中文名,相似度
在遍历本体图中的路径时，AnchorPROMPT区别对待连接概念间的继关系和普通关系同样看待，承关系与其他普通关系，因为如把概念间的AnchorPROMPT的方法不能很好地利用这种继承关系。,AnchorPROMPT,属于,区别对待连接概念间的继关系和普通关系同样看待，承关系与其他普通关系
在遍历本体图中的路径时，AnchorPROMPT区别对待连接概念间的继关系和普通关系同样看待，承关系与其他普通关系，因为如把概念间的AnchorPROMPT的方法不能很好地利用这种继承关系。,AnchorPROMPT,实现,把概念间的AnchorPROMPT的方法不能很好地利用这种继承关系
在遍历本体图中的路径时，AnchorPROMPT区别对待连接概念间的继关系和普通关系同样看待，承关系与其他普通关系，因为如把概念间的AnchorPROMPT的方法不能很好地利用这种继承关系。,AnchorPROMPT,等价,区别对待连接概念间的继关系和普通关系
AnchorPROMPT算法将这种通过Is-a关系连接的概念作为一个等价组看待。,AnchorPROMPT算法,等价,将这种通过Is-a关系连接的概念作为一个等价组看待
考虑图5-5中从的路径，其中将“PROTOCOL”和“EXECUTED-PROTOCOL”作为一个等价组，并用括号来做区别，这样的一条路径写为Path:Trial→POPULATION→CROSSOVER。,PROTOCOL,等价,EXECUTED-PROTOCOL
"[EXECUTED-PROTOCOL,PROTOCOL]→TREATMENT-CROSSOVER_TRIAL到这样，AnchorPROMPT将等价组看作路径上的单个节点。",EXECUTED-PROTOCOL,属于,到这样
"[EXECUTED-PROTOCOL,PROTOCOL]→TREATMENT-CROSSOVER_TRIAL到这样，AnchorPROMPT将等价组看作路径上的单个节点。",AnchorPROMPT,实现,将等价组看作路径上的单个节点。
"[EXECUTED-PROTOCOL,PROTOCOL]→TREATMENT-CROSSOVER_TRIAL到这样，AnchorPROMPT将等价组看作路径上的单个节点。",EXECUTED-PROTOCOL,中文名,到这样
"[EXECUTED-PROTOCOL,PROTOCOL]→TREATMENT-CROSSOVER_TRIAL到这样，AnchorPROMPT将等价组看作路径上的单个节点。",EXECUTED-PROTOCOL,等价,TREATMENT-CROSSOVER_TRIAL
等价组节点的入边是其中每个成员的入边的并；相似地，它的出边是每个成员的出边的并。,等价组节点的入边,属于,其中每个成员的入边的并
等价组节点的入边是其中每个成员的入边的并；相似地，它的出边是每个成员的出边的并。,等价组节点的出边,属于,每个成员的出边的并
等价组节点的入边是其中每个成员的入边的并；相似地，它的出边是每个成员的出边的并。,等价组的入边,等价,其中每个成员的入边的并
等价组节点的入边是其中每个成员的入边的并；相似地，它的出边是每个成员的出边的并。,等价组的出边,等价,每个成员的出边的并
显然图5-5中等价组节点有两条入边和一条出边。,等价组节点,属于,图5-5
显然图5-5中等价组节点有两条入边和一条出边。,等价组节点,实现,两条入边和一条出边
等价组的大小是节点中包括的概念总数，但对于AnchorPROMPT算法来说，它将这些概念视为一个节点。,等价组,属于,节点中包括的概念总数
等价组的大小是节点中包括的概念总数，但对于AnchorPROMPT算法来说，它将这些概念视为一个节点。,AnchorPROMPT算法,实现,将概念视为一个节点
等价组的大小是节点中包括的概念总数，但对于AnchorPROMPT算法来说，它将这些概念视为一个节点。,等价组,中文名,节点中包括的概念总数
等价组的大小是节点中包括的概念总数，但对于AnchorPROMPT算法来说，它将这些概念视为一个节点。,AnchorPROMPT算法,中文名,将这些概念视为一个节点
等价组的大小是节点中包括的概念总数，但对于AnchorPROMPT算法来说，它将这些概念视为一个节点。,等价组的大小,等价,节点中包括的概念总数
步骤2：从步骤1生成的路径集合中，生成所有可能的等长路径对的集合，每一对路径中的一条来自O1，另一条来自O2。,O1,等价,生成所有可能的等长路径对的集合
步骤2：从步骤1生成的路径集合中，生成所有可能的等长路径对的集合，每一对路径中的一条来自O1，另一条来自O2。,O2,等价,生成所有可能的等长路径对的集合
步骤3：在步骤2生成的路径对基础上，对于路径中处于相同位置的节点对N1和N2，为节点中的所有概念对之间的相似度分加上一个常数X。,相似度分,属于,为节点中的所有概念对之间的相似度分加上一个常数X
步骤3：在步骤2生成的路径对基础上，对于路径中处于相同位置的节点对N1和N2，为节点中的所有概念对之间的相似度分加上一个常数X。,相似度分,实现,为节点中的所有概念对之间的相似度分加上一个常数X
步骤3：在步骤2生成的路径对基础上，对于路径中处于相同位置的节点对N1和N2，为节点中的所有概念对之间的相似度分加上一个常数X。,相似度分,中文名,相似度分
当进行比较的节点包含等价组时，增加相似度分数的情况有所不同。,增加相似度分数,属于,比较的节点包含等价组时
当进行比较的节点包含等价组时，增加相似度分数的情况有所不同。,增加相似度分数,实现,不同
当进行比较的节点包含等价组时，增加相似度分数的情况有所不同。,增加相似度分数,中文名,不同
根据上述算法，AnchorPROMPT算法生成很多可能的相似术语对，将这些术语对的相似分数进行排序，去除一些相似分数较低的术语对，就得到语义相关的术语对。,AnchorPROMPT,属于,相似算法
根据上述算法，AnchorPROMPT算法生成很多可能的相似术语对，将这些术语对的相似分数进行排序，去除一些相似分数较低的术语对，就得到语义相关的术语对。,去除一些相似分数较低的术语对,实现,AnchorPROMPT算法生成很多可能的相似术语对
根据上述算法，AnchorPROMPT算法生成很多可能的相似术语对，将这些术语对的相似分数进行排序，去除一些相似分数较低的术语对，就得到语义相关的术语对。,相似算法,中文名,AnchorPROMPT
试验表明，当等价组大小最大值为0（0是一个特殊的标记，表示算法不区分概念间的继承关系和普通关系）或1（节点只包含单个概念，但区分概念间的继承关系和普通关系）时，87%的试验没有任何结果，不生成任何映射。,等价组大小最大值,等价,0
试验表明，当等价组大小最大值为0（0是一个特殊的标记，表示算法不区分概念间的继承关系和普通关系）或1（节点只包含单个概念，但区分概念间的继承关系和普通关系）时，87%的试验没有任何结果，不生成任何映射。,等价组大小最大值,等价,1
当等价组的最大尺寸为2时，只有12%的试验没有结果。,等价组,属于,当等价组的最大尺寸为2时
当等价组的最大尺寸为2时，只有12%的试验没有结果。,等价组,实现,只有12%的试验没有结果
因此，在随后的试验中设定等价组的最大尺寸大小为2。,等价组,属于,设定等价组的最大尺寸大小
因此，在随后的试验中设定等价组的最大尺寸大小为2。,等价组,实现,设定等价组的最大尺寸大小
因此，在随后的试验中设定等价组的最大尺寸大小为2。,等价组,中文名,等价组
为评价等价组成员如何打分合理而做了两类试验。,为评价等价组成员如何打分合理而做的两类试验。,属于,为评价等价组成员如何打分合理而做的两类试验
为评价等价组成员如何打分合理而做了两类试验。,为评价等价组成员如何打分合理而做的两类试验。,实现,为评价等价组成员如何打分合理而做的两类试验
为评价等价组成员如何打分合理而做了两类试验。,为评价等价组成员如何打分合理而做的两类试验。,中文名,为评价等价组成员如何打分合理而做的两类试验
第一类试验中对节点中的所有成员都加X分；而在第二类试验中为等价组中的成员只加X/3或X/2的分数不等。,等价组,属于,第二类试验中为等价组中的成员只加X/3或X/2的分数不等
第一类试验中对节点中的所有成员都加X分；而在第二类试验中为等价组中的成员只加X/3或X/2的分数不等。,等价组中成员只加X/3或X/2的分数不等,实现,第二类试验中对节点中的所有成员都加X分
第一类试验中对节点中的所有成员都加X分；而在第二类试验中为等价组中的成员只加X/3或X/2的分数不等。,第二类试验中为等价组中的成员,等价,为等价组中的成员只加X/3或X/2的分数不等
试验结果表明，对等价组成员打分不同能将结果的准确率提高14%。,对等价组成员打分不同,属于,将结果的准确率提高14%
试验结果表明，对等价组成员打分不同能将结果的准确率提高14%。,对等价组成员打分不同,实现,准确率的提高
试验结果表明，对等价组成员打分不同能将结果的准确率提高14%。,对等价组成员打分不同,中文名,将结果的准确率提高14%
在大量的试验中表明，并非输入的锚数量越多和规定的最大路径长度越大能得到越好的映射结果，算法执行结果的正确率总体提高不明显，但运行时间明显增长[29]。,输入的锚数量越多,属于,得到越好的映射结果
在大量的试验中表明，并非输入的锚数量越多和规定的最大路径长度越大能得到越好的映射结果，算法执行结果的正确率总体提高不明显，但运行时间明显增长[29]。,规定的最大路径长度越大,属于,得到越好的映射结果
在大量的试验中表明，并非输入的锚数量越多和规定的最大路径长度越大能得到越好的映射结果，算法执行结果的正确率总体提高不明显，但运行时间明显增长[29]。,算法执行结果的正确率,实现,总体提高不明显
在大量的试验中表明，并非输入的锚数量越多和规定的最大路径长度越大能得到越好的映射结果，算法执行结果的正确率总体提高不明显，但运行时间明显增长[29]。,运行时间,实现,明显增长
在大量的试验中表明，并非输入的锚数量越多和规定的最大路径长度越大能得到越好的映射结果，算法执行结果的正确率总体提高不明显，但运行时间明显增长[29]。,输入的锚数量越多和规定的最大路径长度越大,中文名,得到越好的映射结果
试验表明，当最大长度路径设为2时，能获得最好的正确率。,最大长度路径,属于,获得最好的正确率
试验表明，当最大长度路径设为2时，能获得最好的正确率。,最大长度路径,实现,获得最好的正确率
当限制路径最大长度为3时，平均正确率为61%；当最大长度提高到4时，正确率只有少量的提升，达到65%。,限制路径最大长度,属于,正确率
当限制路径最大长度为3时，平均正确率为61%；当最大长度提高到4时，正确率只有少量的提升，达到65%。,限制路径最大长度,实现,平均正确率
在实际应用中，随着路径的过长，这个假设的可行性就越小，因此生成结果的精度反而会降低。,生成结果的精度,属于,假设的缺陷
在实际应用中，随着路径的过长，这个假设的可行性就越小，因此生成结果的精度反而会降低。,路径的过长,实现,生成结果的精度反而会降低
在实际应用中，随着路径的过长，这个假设的可行性就越小，因此生成结果的精度反而会降低。,生成结果的精度,中文名,准确性
两个不相关的术语可能出现在某一对路径的相同位置，但对于所有的路径来说，这两个不相关的术语总出现在不同路径对的同一位置上的概率很小。,两个不相关的术语,属于,某一对路径
两个不相关的术语可能出现在某一对路径的相同位置，但对于所有的路径来说，这两个不相关的术语总出现在不同路径对的同一位置上的概率很小。,两个不相关的术语可能出现在某一对路径的相同位置,实现,对于所有的路径来说，这两个不相关的术语总出现在不同路径对的同一位置上的概率很小
试验中可以设定一个相似度分数的阈值，便于去掉相似度分数小于阈值的术语对。,去除相似度分数小于阈值的术语对,属于,设定一个相似度分数的阈值
试验中可以设定一个相似度分数的阈值，便于去掉相似度分数小于阈值的术语对。,去除相似度分数小于阈值的术语对,实现,设定一个相似度分数的阈值
试验表明，AnchorPROMPT的确可以去除大多数的这类术语对。,AnchorPROMPT,属于,去除大多数的这类术语对
试验表明，AnchorPROMPT的确可以去除大多数的这类术语对。,AnchorPROMPT,实现,去除大多数的这类术语对
AnchorPROMPT的映射发现方法并非适用于所有的本体。,AnchorPROMPT的映射发现方法,属于,不适用于所有的本体
AnchorPROMPT的映射发现方法并非适用于所有的本体。,AnchorPROMPT的映射发现方法,实现,映射发现方法并非适用于所有的本体
AnchorPROMPT的映射发现方法并非适用于所有的本体。,AnchorPROMPT的映射发现方法,中文名,映射发现方法并非适用于所有的本体
当两个本体间的结构差别很大时，该方法处理的效果并不好。,本体间结构差别很大时该方法处理的效果并不好,属于,当两个本体间的结构差别很大时，该方法处理的效果并不好。
当两个本体间的结构差别很大时，该方法处理的效果并不好。,本体间结构差别很大时该方法处理的效果并不好,实现,当两个本体间的结构差别很大时，该方法处理的效果并不好。
当两个本体间的结构差别很大时，该方法处理的效果并不好。,本体间结构差别很大时该方法处理的效果并不好,中文名,当两个本体间的结构差别很大时，该方法处理的效果并不好。
由AnchorPROMPT算法的过程可以看出，该算法只能发现异构本体原子概念间的等价映射，以及少量原子关系间的等价映射。,AnchorPROMPT算法,等价,发现异构本体原子概念间的等价映射
由AnchorPROMPT算法的过程可以看出，该算法只能发现异构本体原子概念间的等价映射，以及少量原子关系间的等价映射。,AnchorPROMPT算法,等价,少量原子关系间的等价映射
然后以这些初始的术语相似为基础，执行合并算法完成本体合并的任务。,合并算法,属于,本体合并的任务
然后以这些初始的术语相似为基础，执行合并算法完成本体合并的任务。,初始的术语相似,实现,本体合并的任务
然后以这些初始的术语相似为基础，执行合并算法完成本体合并的任务。,合并算法,中文名,本体合并的任务
步骤2：从合并建议列表中选择一条建议（也可以由用户直接定义一条合并操作），系统执行建议的合并操作，并自动发现由于这样的操作对整个合并建议列表产生的变化，即实现建议列表的更新，然后系统自动判断新的本体合并建议列表中的冲突和潜在的其他问题，并寻找可能的解决方案，经过这些处理，系统生成新的且无冲突的建议列表。,系统实现建议列表的更新,实现,建议列表的更新
②当在本体间拷贝属性时，如果被拷贝属性的值域和定义域中包含概念，且这些概念并不在本体中存在时，便出现了不一致问题。,不一致问题,属于,当在本体间拷贝属性时，如果被拷贝属性的值域和定义域中包含概念，且这些概念并不在本体中存在时，便出现了不一致问题。
②当在本体间拷贝属性时，如果被拷贝属性的值域和定义域中包含概念，且这些概念并不在本体中存在时，便出现了不一致问题。,不一致问题,实现,当在本体间拷贝属性时，如果被拷贝属性的值域和定义域中包含概念，且这些概念并不在本体中存在时，便出现了不一致问题。
②当在本体间拷贝属性时，如果被拷贝属性的值域和定义域中包含概念，且这些概念并不在本体中存在时，便出现了不一致问题。,不一致问题,中文名,当在本体间拷贝属性时，如果被拷贝属性的值域和定义域中包含概念，且这些概念并不在本体中存在时，便出现了不一致问题。
在这种情况下可以考虑删除这些概念或为本体增加这些概念来解决。,本体,属于,概念或本体增加这些概念
在这种情况下可以考虑删除这些概念或为本体增加这些概念来解决。,删除概念,实现,解决
对于这种问题，iPROMPT建议用户删除一些多余的概念来避免冗余。,iPROMPT,属于,建议避免冗余
对于这种问题，iPROMPT建议用户删除一些多余的概念来避免冗余。,iPROMPT,实现,建议用户删除一些多余的概念
对于这种问题，iPROMPT建议用户删除一些多余的概念来避免冗余。,iPROMPT,中文名,建议避免冗余
总的来说，在发现本体映射的过程中，iPROMPT主要利用术语相关性计算方法寻找本体间概念或概念的相关属性的映射，因此，它只能发现有限的概念间或属性间的等价映射。,iPROMPT,等价,寻找本体间概念或概念的相关属性的映射
MAFRA引入了语义桥和以服务为中心的思想。,MAFRA,属于,语义桥
MAFRA引入了语义桥和以服务为中心的思想。,MAFRA,实现,以服务为中心的思想
MAFRA引入了语义桥和以服务为中心的思想。,MAFRA,中文名,语义桥
语义桥提供异构本体间数据（主要是实例和属性值）转换的机制，并利用映射提供基于分布式本体的服务。,语义桥,属于,异构本体间数据（主要是实例和属性值）转换的机制并利用映射提供基于分布式本体的服务
语义桥提供异构本体间数据（主要是实例和属性值）转换的机制，并利用映射提供基于分布式本体的服务。,语义桥,实现,异构本体间数据（主要是实例和属性值）转换的机制并利用映射提供基于分布式本体的服务
语义桥提供异构本体间数据（主要是实例和属性值）转换的机制，并利用映射提供基于分布式本体的服务。,语义桥,中文名,异构本体间数据（主要是实例和属性值）转换的机制并利用映射提供基于分布式本体的服务
MAFRA的正规化过程还包括一些词语方面的处理，如消除常见词和扩展缩写等。,MAFRA的正规化过程,属于,词语方面的处理
MAFRA的正规化过程还包括一些词语方面的处理，如消除常见词和扩展缩写等。,MAFRA的正规化过程,实现,消除常见词和扩展缩写
MAFRA的正规化过程还包括一些词语方面的处理，如消除常见词和扩展缩写等。,MAFRA的正规化过程,中文名,正规化过程
根据本体成分间的相似度，利用语义桥来表示本体映射。,本体映射,属于,利用语义桥来表示本体映射
根据本体成分间的相似度，利用语义桥来表示本体映射。,本体成分间的相似度,实现,利用语义桥来表示本体映射
还能利用推理建立一些隐含的语义桥。,SPO,属于,推理机制
还能利用推理建立一些隐含的语义桥。,SPO,实现,建立一些隐含的语义桥
在获得本体间交互的请求时，利用语义桥中的映射规则完成实例转换或属性转换。,语义桥,属于,本体间交互的请求
在获得本体间交互的请求时，利用语义桥中的映射规则完成实例转换或属性转换。,语义桥,实现,实例转换或属性转换
垂直方向四个模块具体包括：①演化。,垂直方向四个模块,中文名,演化
当本体发生变化时，对生成的“语义桥”进行维护，即同步更新语义桥。,同步更新语义桥,属于,对生成的“语义桥”进行维护
当本体发生变化时，对生成的“语义桥”进行维护，即同步更新语义桥。,本体发生变化时,实现,同步更新语义桥
当本体发生变化时，对生成的“语义桥”进行维护，即同步更新语义桥。,同步更新语义桥,中文名,对生成的“语义桥”进行维护
对于某些本体成分可能存在多个不同的映射建议，此时一般通过多个用户协商，选择一致的映射方案。,映射建议,属于,多个不同的映射建议
对于某些本体成分可能存在多个不同的映射建议，此时一般通过多个用户协商，选择一致的映射方案。,对于某些本体成分可能存在多个不同的映射建议,实现,通过多个用户协商，选择一致的映射方案
对于某些本体成分可能存在多个不同的映射建议，此时一般通过多个用户协商，选择一致的映射方案。,映射建议,中文名,对于某些本体成分可能存在多个不同的映射建议
因此，MAFRA更多只是一个处理异构本体映射的框架。,MAFRA,属于,处理异构本体映射的框架
因此，MAFRA更多只是一个处理异构本体映射的框架。,MAFRA,实现,处理异构本体映射
因此，MAFRA更多只是一个处理异构本体映射的框架。,MAFRA,中文名,处理异构本体映射的框架
为了使异构本体具有统一格式，ONION采用图的形式表示本体，具体保存时采用的格式。,ONION,属于,图的形式表示本体
为了使异构本体具有统一格式，ONION采用图的形式表示本体，具体保存时采用的格式。,ONION,实现,统一格式
本体映射的生成是半自动的，生成算法将可能的映射结果提供给专家，专家可以通过设定相似度阈值或直接选择的形式来接受、修改或改变建议。,本体映射的生成,属于,半自动
本体映射的生成是半自动的，生成算法将可能的映射结果提供给专家，专家可以通过设定相似度阈值或直接选择的形式来接受、修改或改变建议。,本体映射的生成,实现,可能的映射结果提供给专家
本体映射的生成是半自动的，生成算法将可能的映射结果提供给专家，专家可以通过设定相似度阈值或直接选择的形式来接受、修改或改变建议。,本体映射的生成,中文名,生成算法
专家还可以添加新的映射，以补充算法无法生成的映射规则。,专家,属于,添加新的映射
专家还可以添加新的映射，以补充算法无法生成的映射规则。,专家,实现,补充算法无法生成的映射规则
ONION的映射生成过程同时使用了术语匹配和本体图匹配。,本体图匹配,属于,映射生成过程
ONION的映射生成过程同时使用了术语匹配和本体图匹配。,本体图匹配,实现,术语匹配
“窗口算法”虽然降低了比较过程的时间复杂度，但同时也可能造成映射的遗漏。,窗口算法,属于,比较过程的时间复杂度
“窗口算法”虽然降低了比较过程的时间复杂度，但同时也可能造成映射的遗漏。,窗口算法,实现,降低比较过程的时间复杂度
“窗口算法”虽然降低了比较过程的时间复杂度，但同时也可能造成映射的遗漏。,窗口算法,中文名,降低比较过程的时间复杂度
ONION的映射发现算法分为非迭代算法和迭代算法两种。,映射发现算法,属于,非迭代算法
ONION的映射发现算法分为非迭代算法和迭代算法两种。,映射发现算法,属于,迭代算法
ONION的映射发现算法分为非迭代算法和迭代算法两种。,非迭代算法的映射发现算法,实现,英文名
ONION的映射发现算法分为非迭代算法和迭代算法两种。,非迭代算法的映射发现算法,中文名,属于
在这个过程中，专家可以事先设定一些阈值，使算法自动去除一些不可能的相似度结果。,相似度算法,属于,自动去除一些不可能的相似度结果
在这个过程中，专家可以事先设定一些阈值，使算法自动去除一些不可能的相似度结果。,相似度算法,实现,事先设定一些阈值
在这个过程中，专家可以事先设定一些阈值，使算法自动去除一些不可能的相似度结果。,相似度算法,中文名,自动去除一些不可能相似度结果
因此，迭代算法一般以基本匹配器生成的结果为基础，再进行子图匹配。,迭代算法,属于,基本匹配器生成的结果再进行子图匹配
因此，迭代算法一般以基本匹配器生成的结果为基础，再进行子图匹配。,迭代算法,实现,以基本匹配器生成的结果为基础，再进行子图匹配
因此，迭代算法一般以基本匹配器生成的结果为基础，再进行子图匹配。,迭代算法,中文名,基本匹配器生成的结果再进行子图匹配
ONION算法的试验结果表明，采用这种方法得到的映射精度在56%～73%之间，映射结果的召回率为50%～90%。,ONION算法,属于,概念/技术映射
ONION算法的试验结果表明，采用这种方法得到的映射精度在56%～73%之间，映射结果的召回率为50%～90%。,ONION算法,实现,概念/技术映射的精度
试验还表明，在映射发现过程中采用多种策略能提高精度。,映射发现,属于,多种策略能提高精度
试验还表明，在映射发现过程中采用多种策略能提高精度。,映射发现,实现,精度
ONION中寻找的映射是原子概念之间的等价关系，属于本体间的简单映射。,ONION中寻找的映射,属于,本体间的简单映射
ONION中寻找的映射是原子概念之间的等价关系，属于本体间的简单映射。,ONION中寻找的映射,实现,原子概念之间的等价关系
同义词集是语义相同或相近词的分组[38]。,同义词集,属于,语义相同或相近词的分组
同义词集是语义相同或相近词的分组[38]。,同义词集,实现,语义相同或相近词的分组
同义词集是语义相同或相近词的分组[38]。,同义词集,中文名,语义相同或相近词的分组
基于同名或同义词集的概念在多数情况下具有相同或是相近的含义，因此，这里将概念的名称作为相似度首要考虑的要素。,相似度,中文名,概念的名称作为相似度
以上的两种相似度都是基于概念自身的，上下文的相似度是由当前概念的语义邻居结构的相似度决定的。,相似度,属于,基于概念自身的相似度
以上的两种相似度都是基于概念自身的，上下文的相似度是由当前概念的语义邻居结构的相似度决定的。,相似度,实现,上下文的相似度
以上的两种相似度都是基于概念自身的，上下文的相似度是由当前概念的语义邻居结构的相似度决定的。,相似度,中文名,基于概念自身的相似度
"定义5.6概念Co的语义邻居概念集N(Co,r)={Ci|∀i,d(Co,Ci)≤r}。","概念Co的语义邻居概念集N(Co,r)",属于,"{Ci|∀i,d(Co,Ci)≤r}。"
"定义5.6概念Co的语义邻居概念集N(Co,r)={Ci|∀i,d(Co,Ci)≤r}。","概念Co的语义邻居概念集N(Co,r)",实现,"{Ci|∀i,d(Co,Ci)≤r}。"
"定义5.6概念Co的语义邻居概念集N(Co,r)={Ci|∀i,d(Co,Ci)≤r}。","概念Co的语义邻居概念集N(Co,r)",中文名,"概念Co的语义邻居概念集N(Co,r)={Ci|∀i,d(Co,Ci)≤r}。"
式中，d表示概念间的距离，其数值为联系两概念的最短的关系数目。,d,属于,概念间距离
式中，d表示概念间的距离，其数值为联系两概念的最短的关系数目。,d,实现,联系两概念的最短的关系数目
d≤r表明与当前的概念在语义距离上小于某一定常数。,d≤r,属于,与当前的概念在语义距离上小于某一定常数。
d≤r表明与当前的概念在语义距离上小于某一定常数。,d≤r,实现,与当前的概念在语义距离上小于某一定常数。
"计算采用Tverski_A定义的非对称的相似度度量[39]：式中，a、b是待度量概念元素；Ai和Bi,i∈{w,u,n}分别对应概念的同义词集、特征集或语义邻居集；||表示取集合的势；表示两集合的并集；/表示两集合的差集；α(a,b)由a、b所在类结构层次决定.式中，depth()是当前概念在层次结构中的深度，定义为从当前概念到顶层概念的最短路径长度。",计算采用Tverski_A定义的非对称的相似度度量,等价,非对称的相似度度量
该方法利用概念间的相似度辅助本体映射的生成。,概念间的相似度辅助本体映射的生成,属于,本体映射的生成
该方法利用概念间的相似度辅助本体映射的生成。,概念间的相似度辅助本体映射的生成,实现,本体映射的生成
该方法利用概念间的相似度辅助本体映射的生成。,概念间的相似度辅助本体映射的生成,中文名,概念间的相似度辅助本体映射的生成
通常，如果两概念在三种相似度或总相似度中具有较高的值，它们相同的可能就很大。,相似度,属于,概念或概念组成元素
通常，如果两概念在三种相似度或总相似度中具有较高的值，它们相同的可能就很大。,相似度,实现,判断两个概念是否相同或相似
通常，如果两概念在三种相似度或总相似度中具有较高的值，它们相同的可能就很大。,相似度,中文名,判断两个概念是否相同或相似
②更值得关注的结论是，在同一本体中，父概念与子概念的相似度通常小于子概念与父概念的相似度[38]，该结论可推广到不同本体中概念间存在父子关联的判别中。,概念间存在父子关联的判别,属于,不同本体中概念间存在父子关联的判别中
②更值得关注的结论是，在同一本体中，父概念与子概念的相似度通常小于子概念与父概念的相似度[38]，该结论可推广到不同本体中概念间存在父子关联的判别中。,同一本体中，父概念与子概念的相似度,实现,同一本体中，父概念与子概念的相似度通常小于子概念与父概念的相似度
②更值得关注的结论是，在同一本体中，父概念与子概念的相似度通常小于子概念与父概念的相似度[38]，该结论可推广到不同本体中概念间存在父子关联的判别中。,同一本体中，父概念与子概念的相似度,中文名,同一本体中，父概念与子概念的相似度通常小于子概念与父概念的相似度
根据上面的相似度量方法和分析，该方法得到生成概念上的等价关系和上/下义关系两种映射。,等价关系,等价,上/下义关系两种映射
"定义5.7如果不同本体中两概念的互相相似度都大于定常数，那么这两概念是等价的，表示为(Oa:Ci,Ob:Cj))。",Oa,等价,Ci
"定义5.7如果不同本体中两概念的互相相似度都大于定常数，那么这两概念是等价的，表示为(Oa:Ci,Ob:Cj))。",Ob,等价,Cj
式中，AddBridge表示添加一个映射的操作，BCequal表示两个概念等价。,AddBridge,属于,添加一个映射的操作
式中，AddBridge表示添加一个映射的操作，BCequal表示两个概念等价。,AddBridge,实现,添加一个映射的操作
式中，isa表示两概念具有上义和下义关系。,isa,属于,两概念具有上义和下义关系
式中，isa表示两概念具有上义和下义关系。,isa,实现,两概念具有上义和下义关系
S-Match是一个本体匹配系统，能发现异构本体间的映射[40]。,S-Match,属于,本体匹配系统
S-Match是一个本体匹配系统，能发现异构本体间的映射[40]。,S-Match,实现,发现异构本体间的映射
S-Match是一个本体匹配系统，能发现异构本体间的映射[40]。,S-Match,中文名,本体匹配系统
S-Match基于本体抽象层的概念继承结构树，不考虑本体中的实例。,S-Match,属于,基于本体抽象层的概念继承结构树，不考虑本体中的实例。
S-Match基于本体抽象层的概念继承结构树，不考虑本体中的实例。,S-Match,实现,基于本体抽象层的概念继承结构树，不考虑本体中的实例。
S-Match基于本体抽象层的概念继承结构树，不考虑本体中的实例。,S-Match,中文名,基于本体抽象层的概念继承结构树，不考虑本体中的实例。
然后，用户协调两本体的匹配过程，这种方法使用三个外部库。,用户协调两本体的匹配过程,属于,外部库
然后，用户协调两本体的匹配过程，这种方法使用三个外部库。,用户协调两本体的匹配过程,实现,使用三个外部库
第二个库由强语义的元素层次匹配器组成，当前使用的是WordNet。,第二个库,属于,强语义的元素层次匹配器
第二个库由强语义的元素层次匹配器组成，当前使用的是WordNet。,第二个库,实现,WordNet
第三个库是由结构层次的强语义匹配器组成的。,结构层次的强语义匹配器,属于,第三个库
第三个库是由结构层次的强语义匹配器组成的。,结构层次的强语义匹配器,实现,强语义匹配
第三个库是由结构层次的强语义匹配器组成的。,结构层次的强语义匹配器,中文名,强语义匹配器组成的
其中的思想是将自然语言表示的节点标签转换为一种内部的形式化形式，以此为基础计算每个标签的含义。,概念/spo,属于,将自然语言表示的节点标签转换为一种内部的形式化形式
其中的思想是将自然语言表示的节点标签转换为一种内部的形式化形式，以此为基础计算每个标签的含义。,概念/spo,实现,计算每个标签的含义
其中的思想是将自然语言表示的节点标签转换为一种内部的形式化形式，以此为基础计算每个标签的含义。,概念/spo,中文名,将自然语言表示的节点标签转换为一种内部的形式化形式
扩展节点标签的含义，通过捕获树结构中的知识，定义节点中概念的上下文。,扩展节点标签的含义,属于,捕获树结构中的知识
扩展节点标签的含义，通过捕获树结构中的知识，定义节点中概念的上下文。,扩展节点标签的含义,实现,定义节点中概念的上下文
步骤3：对所有T1和T2中的标签对，计算标签间的关系。,T1,属于,步骤
步骤3：对所有T1和T2中的标签对，计算标签间的关系。,计算标签间的关系,实现,步骤3：对所有T1和T2中的标签对，计算标签间的关系。
步骤3：对所有T1和T2中的标签对，计算标签间的关系。,T1,中文名,概念/产品
Cupid系统实现了一个通用的模式匹配算法[41]，它综合使用了语言和结构的匹配技术，并在预定义词典的帮助下，计算相似度获得映射结果。,Cupid系统,实现,一个通用的模式匹配算法
该方法输入图格式的模式，图节点表示模式中的元素。,图节点,属于,输入图模式的元素
该方法输入图格式的模式，图节点表示模式中的元素。,该方法,实现,输入图格式的模式，图节点表示模式中的元素。
该方法输入图格式的模式，图节点表示模式中的元素。,该方法,中文名,输入图格式的模式，图节点表示模式中的元素。
"与其他的混合方法比较[42],Cupid得到更好的映射结果。",Cupid,属于,混合方法的比较
"与其他的混合方法比较[42],Cupid得到更好的映射结果。",Cupid,实现,得到更好的映射结果
Chimaera是一个合并和测试大本体的环境[43]。,Chimaera,属于,合并和测试大本体的环境
Chimaera是一个合并和测试大本体的环境[43]。,Chimaera,实现,合并和测试大本体的环境
Chimaera是一个合并和测试大本体的环境[43]。,Chimaera,中文名,查玛尔
Chimaera能识别术语间是否包含或不相关等简单的映射关系。,Chimaera,属于,识别术语间是否包含或不相关等简单的映射关系
Chimaera能识别术语间是否包含或不相关等简单的映射关系。,Chimaera,实现,能识别术语间是否包含或不相关等简单的映射关系
Chimaera能识别术语间是否包含或不相关等简单的映射关系。,Chimaera,中文名,奇美拉
它认为不同系统的用户如果在一些基本词汇上达成一致，便能确保不同源本体间的信息查询相互兼容。,OWL_2_QL,属于,OWL_2
它认为不同系统的用户如果在一些基本词汇上达成一致，便能确保不同源本体间的信息查询相互兼容。,不同系统的用户,实现,信息查询相互兼容
COMA是一个模式匹配系统[45]，它是一种综合的通用匹配器。,COMA,属于,模式匹配系统
COMA是一个模式匹配系统[45]，它是一种综合的通用匹配器。,COMA,实现,综合的通用匹配器
它的匹配库是可扩展的，目前该系统包含6个单独的匹配器、5个混合匹配器和1个面向重用的匹配器，它们大多数的实现基于字符串技术。,匹配器,属于,实现基于字符串技术
它的匹配库是可扩展的，目前该系统包含6个单独的匹配器、5个混合匹配器和1个面向重用的匹配器，它们大多数的实现基于字符串技术。,匹配器,实现,可扩展
面向重用的匹配器则力图重用其他匹配器得到的结果来得到更好的映射。,面向重用的匹配器,属于,其他匹配器得到的结果来得到更好的映射
面向重用的匹配器则力图重用其他匹配器得到的结果来得到更好的映射。,面向重用的匹配器,实现,重用其他匹配器得到的结果来得到更好的映射
面向重用的匹配器则力图重用其他匹配器得到的结果来得到更好的映射。,面向重用的匹配器,中文名,面向重用的匹配器
COMA支持在匹配过程中与用户进行交互，提高匹配结果的准确率。,COMA,属于,匹配过程中与用户进行交互，提高匹配结果的准确率
COMA支持在匹配过程中与用户进行交互，提高匹配结果的准确率。,COMA,实现,在匹配过程中与用户进行交互，提高匹配结果的准确率
COMA支持在匹配过程中与用户进行交互，提高匹配结果的准确率。,COMA,中文名,匹配过程中与用户进行交互，提高匹配结果的准确率
ASCO原型依靠识别不同本体间相关元素对的算法[46]来发现映射，这些元素对可以是概念对，也可以是关系对。,ASCO原型,属于,识别不同本体间相关元素对的算法
ASCO原型依靠识别不同本体间相关元素对的算法[46]来发现映射，这些元素对可以是概念对，也可以是关系对。,ASCO原型,实现,发现映射
该方法的匹配过程分为几个阶段：语言阶段应用语言处理技术和字符串比较度量元素间关系，并利用词汇数据库来计算概念或关系间的相似度；结构阶段利用概念和关系的结构计算概念或关系间的相似度。,匹配过程,属于,应用语言处理技术和字符串比较度量元素间关系，并利用词汇数据库来计算概念或关系间的相似度
该方法的匹配过程分为几个阶段：语言阶段应用语言处理技术和字符串比较度量元素间关系，并利用词汇数据库来计算概念或关系间的相似度；结构阶段利用概念和关系的结构计算概念或关系间的相似度。,匹配过程,实现,利用概念和关系的结构计算概念或关系间的相似度
该方法的匹配过程分为几个阶段：语言阶段应用语言处理技术和字符串比较度量元素间关系，并利用词汇数据库来计算概念或关系间的相似度；结构阶段利用概念和关系的结构计算概念或关系间的相似度。,匹配过程,中文名,应用语言处理技术和字符串比较度量元素间关系，并利用词汇数据库来计算概念或关系间的相似度
尽管基于术语和结构的本体映射探索不少，但是总的来说取得的映射结果都不够让人满意，大多数的工作只能发现简单概念间的等价和包含映射，以及原子关系之间的等价。,本体映射,等价,发现简单概念间的等价和包含映射
尽管基于术语和结构的本体映射探索不少，但是总的来说取得的映射结果都不够让人满意，大多数的工作只能发现简单概念间的等价和包含映射，以及原子关系之间的等价。,本体映射,等价,原子关系之间的等价
这一类方法大部分基于一些直观的思想，缺乏理论的依据和支持，因此适用范围窄，取得的映射结果质量低。,这一类方法,属于,缺乏理论的依据和支持
这一类方法大部分基于一些直观的思想，缺乏理论的依据和支持，因此适用范围窄，取得的映射结果质量低。,这一类方法,实现,适用范围窄
这一类方法大部分基于一些直观的思想，缺乏理论的依据和支持，因此适用范围窄，取得的映射结果质量低。,这一类方法,实现,取得的映射结果质量低
这一类方法大部分基于一些直观的思想，缺乏理论的依据和支持，因此适用范围窄，取得的映射结果质量低。,这一类方法,中文名,缺乏理论的依据和支持取得的映射结果质量低适用范围窄
当两概念等价时，显然有AB=A=B。,A,属于,等价关系
当两概念等价时，显然有AB=A=B。,AB=A=B,实现,等价
当两概念等价时，显然有AB=A=B。,等价关系,中文名,等价关系
当两概念等价时，显然有AB=A=B。,AB,等价,A
当两概念等价时，显然有AB=A=B。,AB,等价,B
定义5.9对称差分表示两集合的相似度，如果x和y是两个概念对应的实例集合，则它们的对称差分相似度为可见，对称差分值越大，概念间的差异越大。,对称差分表示两集合的相似度,属于,概念对应的实例集合
定义5.9对称差分表示两集合的相似度，如果x和y是两个概念对应的实例集合，则它们的对称差分相似度为可见，对称差分值越大，概念间的差异越大。,对称差分表示两集合的相似度,实现,概念间的差异
定义5.9对称差分表示两集合的相似度，如果x和y是两个概念对应的实例集合，则它们的对称差分相似度为可见，对称差分值越大，概念间的差异越大。,对称差分表示两集合的相似度,中文名,概念对应的实例集合
此外，还可以根据实例集合的概率解释来计算相似度，在随后的方法中将详细介绍。,实例集合的概率解释,属于,计算相似度的方法
此外，还可以根据实例集合的概率解释来计算相似度，在随后的方法中将详细介绍。,实例集合的概率解释,实现,根据实例集合的概率解释来计算相似度
此外，还可以根据实例集合的概率解释来计算相似度，在随后的方法中将详细介绍。,实例集合的概率解释,中文名,根据实例集合的概率解释来计算相似度
常用的连接聚合度量包括单连接、全连接、平均连接和Haussdorf距离。,连接聚合度量,属于,常用的连接聚合度量
常用的连接聚合度量包括单连接、全连接、平均连接和Haussdorf距离。,连接聚合度量,实现,单连接
常用的连接聚合度量包括单连接、全连接、平均连接和Haussdorf距离。,连接聚合度量,实现,全连接
常用的连接聚合度量包括单连接、全连接、平均连接和Haussdorf距离。,连接聚合度量,实现,平均连接
常用的连接聚合度量包括单连接、全连接、平均连接和Haussdorf距离。,连接聚合度量,实现,Haussdorf距离
常用的连接聚合度量包括单连接、全连接、平均连接和Haussdorf距离。,连接聚合度量,中文名,常用的连接聚合度量
其中，Haussdorf距离度量两个集合之间的最大距离。,Haussdorf距离度量,属于,两个集合之间的最大距离
其中，Haussdorf距离度量两个集合之间的最大距离。,Haussdorf距离度量,实现,两个集合之间的最大距离
其中，Haussdorf距离度量两个集合之间的最大距离。,哈斯距离度量,中文名,两个集合之间的最大距离
基于实例的映射发现方法很多采用机器学习技术来发现异构本体间映射。,基于实例的映射发现方法,属于,采用机器学习技术来发现异构本体间映射
基于实例的映射发现方法很多采用机器学习技术来发现异构本体间映射。,基于实例的映射发现方法,实现,发现异构本体间映射
基于实例的映射发现方法很多采用机器学习技术来发现异构本体间映射。,基于实例的映射发现方法,中文名,基于实例的映射发现方法
训练完成后，训练结果用于发现异构本体间的映射。,发现异构本体间的映射,属于,训练完成后训练结果
训练完成后，训练结果用于发现异构本体间的映射。,发现异构本体间的映射,实现,训练完成后训练结果用于发现异构本体间的映射
训练完成后，训练结果用于发现异构本体间的映射。,发现异构本体间的映射,中文名,训练完成后训练结果用于发现异构本体间的映射
常用的机器学习算法包括形式化概念分析[48]、贝叶斯学习[49]和神经网络[50]等。,常用的机器学习算法,属于,形式化概念分析
常用的机器学习算法包括形式化概念分析[48]、贝叶斯学习[49]和神经网络[50]等。,常用的机器学习算法,属于,贝叶斯学习
常用的机器学习算法包括形式化概念分析[48]、贝叶斯学习[49]和神经网络[50]等。,常用的机器学习算法,属于,神经网络
常用的机器学习算法包括形式化概念分析[48]、贝叶斯学习[49]和神经网络[50]等。,形式化概念分析,实现,形式化概念分析算法
常用的机器学习算法包括形式化概念分析[48]、贝叶斯学习[49]和神经网络[50]等。,贝叶斯学习,实现,贝叶斯学习算法
常用的机器学习算法包括形式化概念分析[48]、贝叶斯学习[49]和神经网络[50]等。,神经网络,实现,神经网络算法
常用的机器学习算法包括形式化概念分析[48]、贝叶斯学习[49]和神经网络[50]等。,常用的机器学习算法,中文名,形式化概念分析算法
常用的机器学习算法包括形式化概念分析[48]、贝叶斯学习[49]和神经网络[50]等。,常用的机器学习算法,中文名,贝叶斯学习算法
常用的机器学习算法包括形式化概念分析[48]、贝叶斯学习[49]和神经网络[50]等。,常用的机器学习算法,中文名,神经网络算法
GLUE是对半自动模式发现系统LSD的一个改进[53]。,GLUE,属于,对半自动模式发现系统LSD的一个改进
GLUE是对半自动模式发现系统LSD的一个改进[53]。,GLUE,实现,半自动模式发现系统LSD
GLUE认为概念分类是本体中最重要的部分，它着重寻找分类本体概念之间的1∶1映射。,概念分类,属于,本体中最重要的部分
GLUE认为概念分类是本体中最重要的部分，它着重寻找分类本体概念之间的1∶1映射。,GLUE,实现,寻找分类本体概念之间的1∶1映射
该方法还能扩充为发现关系之间的映射以及处理更复杂的映射形式（如1∶n或n∶1）[54]。,发现关系之间的映射,属于,扩充为发现关系之间的映射以及处理更复杂的映射形式（如1∶n或n∶1）
该方法还能扩充为发现关系之间的映射以及处理更复杂的映射形式（如1∶n或n∶1）[54]。,发现关系之间的映射,实现,扩充为发现关系之间的映射以及处理更复杂的映射形式（如1∶n或n∶1）
GLUE的目的是根据分类本体寻找本体间1∶1的映射。,GLUE,属于,根据分类本体寻找本体间1∶1的映射
GLUE的目的是根据分类本体寻找本体间1∶1的映射。,GLUE,实现,根据分类本体寻找本体间1∶1的映射
GLUE定义了4种概念的联合概率分布。,GLUE,属于,概念的联合概率分布
GLUE定义了4种概念的联合概率分布。,GLUE,实现,定义四种概念的联合概率分布
它利用A的实例训练一个匹配器，然后用该匹配器去判断B的实例。,A,属于,利用实例训练匹配器
它利用A的实例训练一个匹配器，然后用该匹配器去判断B的实例。,A,实现,判断B的实例
然而，本体中的信息类型多种多样，单个学习器无法有效利用各种类型的信息。,学习器,属于,信息类型多种多样
然而，本体中的信息类型多种多样，单个学习器无法有效利用各种类型的信息。,单个学习器,实现,有效利用各种类型的信息
GLUE利用领域约束条件和通用启发式规则来提高映射结果的精度。,GLUE,属于,提高映射结果的精度
GLUE利用领域约束条件和通用启发式规则来提高映射结果的精度。,GLUE,实现,利用领域约束条件和通用启发式规则来提高映射结果的精度
一个领域约束的例子是“如果概念X匹配Professor以及概念Y是X的祖先，那么Y不可能匹配概念Assistant-Professor”；一个启发式规则如“两个概念的邻居都是匹配的，那么这两个概念很可能也匹配”。,一个领域约束的例子,属于,“如果概念X匹配Professor以及概念Y是X的祖先，那么Y不可能匹配概念Assistant-Professor”
一个领域约束的例子是“如果概念X匹配Professor以及概念Y是X的祖先，那么Y不可能匹配概念Assistant-Professor”；一个启发式规则如“两个概念的邻居都是匹配的，那么这两个概念很可能也匹配”。,一个启发式规则,属于,“两个概念的邻居都是匹配的，那么这两个概念很可能也匹配”
一个领域约束的例子是“如果概念X匹配Professor以及概念Y是X的祖先，那么Y不可能匹配概念Assistant-Professor”；一个启发式规则如“两个概念的邻居都是匹配的，那么这两个概念很可能也匹配”。,一个领域约束的例子,实现,“如果概念X匹配Professor以及概念Y是X的祖先，那么Y不可能匹配概念Assistant-Professor”
一个领域约束的例子是“如果概念X匹配Professor以及概念Y是X的祖先，那么Y不可能匹配概念Assistant-Professor”；一个启发式规则如“两个概念的邻居都是匹配的，那么这两个概念很可能也匹配”。,一个领域约束的例子,中文名,“如果概念X匹配Professor以及概念Y是X的祖先，那么Y不可能匹配概念Assistant-Professor”
一个领域约束的例子是“如果概念X匹配Professor以及概念Y是X的祖先，那么Y不可能匹配概念Assistant-Professor”；一个启发式规则如“两个概念的邻居都是匹配的，那么这两个概念很可能也匹配”。,一个启发式规则,中文名,“两个概念的邻居都是匹配的，那么这两个概念很可能也匹配”
很多本体相似度定义过于依赖概念本身和它的语法表示，与这些方法不同，GLUE定义了更精确的相似度表示。,GLUE,属于,本体相似度的定义
很多本体相似度定义过于依赖概念本身和它的语法表示，与这些方法不同，GLUE定义了更精确的相似度表示。,GLUE,实现,更精确的相似度表示
GLUE将概念视为实例的集合，并认为该实例集合是无限大的全体实例集中的一个子集。,GLUE,属于,将概念视为实例的集合
GLUE将概念视为实例的集合，并认为该实例集合是无限大的全体实例集中的一个子集。,GLUE,实现,认为该实例集合是无限大的全体实例集中的一个子集
"以P(A,)为例，它表示从全体实例集中随机选择一个实例，该实例属于A但不属于B的概率，概率的值为属于A但不属于B的实例占全体实例集的比例。","P(A,)",属于,属于A但不属于B的概率
"以P(A,)为例，它表示从全体实例集中随机选择一个实例，该实例属于A但不属于B的概率，概率的值为属于A但不属于B的实例占全体实例集的比例。","P(A,)",实现,从全体实例集中随机选择一个实例，该实例属于A但不属于B的概率，概率的值为属于A但不属于B的实例占全体实例集的比例
"以P(A,)为例，它表示从全体实例集中随机选择一个实例，该实例属于A但不属于B的概率，概率的值为属于A但不属于B的实例占全体实例集的比例。","P(A,)",等价,从全体实例集中随机选择一个实例，该实例属于A但不属于B的概率
第一个相似度度量函数是基于Jaccard系数[55]：当A与B不相关时，该相似度取得最小值0；当A和B是等价概念时，该相似度取得最大值1。,相似度度量函数,属于,基于Jaccard系数
第一个相似度度量函数是基于Jaccard系数[55]：当A与B不相关时，该相似度取得最小值0；当A和B是等价概念时，该相似度取得最大值1。,相似度度量函数,实现,当A与B不相关时，该相似度取得最小值0
第一个相似度度量函数是基于Jaccard系数[55]：当A与B不相关时，该相似度取得最小值0；当A和B是等价概念时，该相似度取得最大值1。,相似度度量函数,中文名,基于Jaccard系数
这符合这样的直觉：A最特化的双亲是包含A的最小集；或者说在A的所有父概念中，它与直接父概念的相似度最大。,A,属于,最特化的双亲
这符合这样的直觉：A最特化的双亲是包含A的最小集；或者说在A的所有父概念中，它与直接父概念的相似度最大。,A,实现,在A的所有父概念中，它与直接父概念的相似度最大
类似于“最特化双亲”，还可以定义“最泛化孩子”的相似度度量。,最泛化孩子,属于,相似度度量
类似于“最特化双亲”，还可以定义“最泛化孩子”的相似度度量。,类似于“最特化双亲”，还可以定义“最泛化孩子”的相似度度量。,实现,
类似于“最特化双亲”，还可以定义“最泛化孩子”的相似度度量。,最泛化孩子,中文名,相似度度量
然后利用机器学习技术计算每对概念的联合概率分布。,概念/三元组,属于,利用机器学习技术计算每对概念的联合概率分布
然后利用机器学习技术计算每对概念的联合概率分布。,概念/三元组,实现,利用机器学习技术计算每对概念的联合概率分布
然后利用机器学习技术计算每对概念的联合概率分布。,概念/三元组,中文名,概念/三元组
分布评估使用一组基本学习器和一个元学习器。,分布评估,属于,基本学习器和一个元学习器
分布评估使用一组基本学习器和一个元学习器。,分布评估,实现,一组基本学习器
放松标记模块利用相似度矩阵以及领域特定的约束和启发式知识，寻找满足领域约束和常识知识的映射，输出最终的映射结果。,放松标记模块,属于,寻找满足领域约束和常识知识的映射，输出最终的映射结果。
放松标记模块利用相似度矩阵以及领域特定的约束和启发式知识，寻找满足领域约束和常识知识的映射，输出最终的映射结果。,放松标记模块,实现,利用相似度矩阵以及领域特定的约束和启发式知识，寻找满足领域约束和常识知识的映射
放松标记模块利用相似度矩阵以及领域特定的约束和启发式知识，寻找满足领域约束和常识知识的映射，输出最终的映射结果。,放松标记模块,中文名,利用相似度矩阵以及领域特定的约束和启发式知识寻找满足领域约束和常识知识的映射，输出最终的映射结果。
"考虑计算P(A,B)的值，其中A∈O1且B∈O2，这个联合概率分布是同时属于A和B的实例数与全体实例总数的比值。",联合概率分布,属于,同时属于A和B的实例数与全体实例总数的比值
"考虑计算P(A,B)的值，其中A∈O1且B∈O2，这个联合概率分布是同时属于A和B的实例数与全体实例总数的比值。",联合概率分布,实现,"计算P(A,B)的值"
"考虑计算P(A,B)的值，其中A∈O1且B∈O2，这个联合概率分布是同时属于A和B的实例数与全体实例总数的比值。",联合概率分布,中文名,属于联合概率分布
通常这个比值是无法计算的，因为不可能知道全体实例。,SPO,属于,三元组抽取
通常这个比值是无法计算的，因为不可能知道全体实例。,SPO,实现,计算这个比值
"因此，必须基于现有的数据来估计P(A,B)，即利用两个本体的输入实例。",本体,属于,"估计P(A,B)"
"因此，必须基于现有的数据来估计P(A,B)，即利用两个本体的输入实例。","基于现有的数据来估计P(A,B)",实现,两个本体的输入实例
"因此，必须基于现有的数据来估计P(A,B)，即利用两个本体的输入实例。","基于现有的数据来估计P(A,B)",中文名,"基于现有的数据来估计P(A,B)"
注意，两个本体的实例可以重叠，但没有必要必须那样。,本体,属于,OIAIA
注意，两个本体的实例可以重叠，但没有必要必须那样。,本体,实现,两个本体的实例可以重叠
注意，两个本体的实例可以重叠，但没有必要必须那样。,本体,中文名,本体实例重叠
Ui表示本体Oi的实例集合，它是全体实例中的本体Oi对应部分的抽样。,Ui,属于,本体Oi的实例集合
Ui表示本体Oi的实例集合，它是全体实例中的本体Oi对应部分的抽样。,Ui,实现,全体实例中的本体Oi对应部分的抽样
N(Ui)是Ui中实例的数目，公式来估计：是同时属于A和B的实例数目。,N(Ui),属于,估计公式来估计实例的数目
N(Ui)是Ui中实例的数目，公式来估计：是同时属于A和B的实例数目。,同时属于A和B的实例数目,实现,估计公式来估计
例如，为了计算的数值，需要知道U2中的每个实例s是否同时属于A和B；由于B是O2的概念，属于B的那部分实例是很容易得到的，因为这已在本体中明确说明；而A并不在本体O2中，因此只需要判断O2中的实例s是否属于A。,A,属于,O2
例如，为了计算的数值，需要知道U2中的每个实例s是否同时属于A和B；由于B是O2的概念，属于B的那部分实例是很容易得到的，因为这已在本体中明确说明；而A并不在本体O2中，因此只需要判断O2中的实例s是否属于A。,查询属于A和B的实例,实现,判断O2中的实例s是否属于A
特别地，将O1的实例集合U1划分为属于A的实例集和不属于A的实例集。,O1,属于,A
特别地，将O1的实例集合U1划分为属于A的实例集和不属于A的实例集。,将O1的实例集合U1划分为属于A的实例集,实现,属于
特别地，将O1的实例集合U1划分为属于A的实例集和不属于A的实例集。,属于A的实例集,中文名,属于A的实例集合U1
这里规定置信度大于0.5就表示“是”。,置信度,属于,判断“是”或“不是”一个概念或产品的规定
这里规定置信度大于0.5就表示“是”。,置信度,实现,判断“是”或“不是”一个概念或产品的规定
这里规定置信度大于0.5就表示“是”。,置信度,中文名,判断“是”或“不是”一个概念或产品的规定
常用的分类学习器很多，GLUE使用的分类学习器将在随后部分介绍。,分类学习器,属于,常用的分类学习器
常用的分类学习器很多，GLUE使用的分类学习器将在随后部分介绍。,GLUE,实现,分类学习器介绍的将在随后部分
常用的分类学习器很多，GLUE使用的分类学习器将在随后部分介绍。,分类学习器,中文名,常用的分类学习器
基于上述思想，通过学习的方法得到和等参数，就能估计A和B的联合概率分布。,A,属于,学习得到和等参数
基于上述思想，通过学习的方法得到和等参数，就能估计A和B的联合概率分布。,A,实现,估计A和B的联合概率分布
●划分本体O1的实例集合U1为和，分别表示属于A和不属于A的实例集合，如图5-9（a）和图5-9（b）所示。,O1,属于,A
●划分本体O1的实例集合U1为和，分别表示属于A和不属于A的实例集合，如图5-9（a）和图5-9（b）所示。,U1,实现,划分本体O1的实例集合U1为
●划分本体O1的实例集合U1为和，分别表示属于A和不属于A的实例集合，如图5-9（a）和图5-9（b）所示。,O1,中文名,本体O1
●划分本体O2的实例集合U2为和，分别表示属于B和不属于B的实例集合，如图5-9（d）和图5-9（e）所示。,O2,属于,划分本体O2的实例集合U2为
●划分本体O2的实例集合U2为和，分别表示属于B和不属于B的实例集合，如图5-9（d）和图5-9（e）所示。,O2的实例集合U2,实现,属于B的实例集合
●划分本体O2的实例集合U2为和，分别表示属于B和不属于B的实例集合，如图5-9（d）和图5-9（e）所示。,O2的实例集合U2,中文名,属于B的实例集合
●重复（a）～（d），得到集合和。,集合和,属于,SPO三元组
●重复（a）～（d），得到集合和。,集合和,实现,从input中抽取出符合schema定义的spo关系三元组，不存在的关系返回空列表。请按照JSON字符串的格式回答。
●重复（a）～（d），得到集合和。,集合和,中文名,SPO三元组
类似地，可以计算出其他3种联合概率分布。,联合概率分布,属于,概念/概率分布
类似地，可以计算出其他3种联合概率分布。,联合概率分布,实现,计算其他3种联合概率分布
训练实例分类器的过程可根据不同类型的信息，如可以利用词语出现的频率、实例名和实例属性的赋值格式等。,训练实例分类器,属于,根据不同类型的信息
训练实例分类器的过程可根据不同类型的信息，如可以利用词语出现的频率、实例名和实例属性的赋值格式等。,训练实例分类器的过程,实现,可根据不同类型的信息
训练实例分类器的过程可根据不同类型的信息，如可以利用词语出现的频率、实例名和实例属性的赋值格式等。,训练实例分类器的过程,中文名,根据不同类型的信息
"在分布估计阶段，系统会训练多个基本学习器L1,…,Lk。",基本学习器L1,属于,分布估计阶段
"在分布估计阶段，系统会训练多个基本学习器L1,…,Lk。",分布估计阶段,实现,"训练多个基本学习器L1,…,Lk"
"在分布估计阶段，系统会训练多个基本学习器L1,…,Lk。",分布估计阶段,中文名,在分布估计阶段
每种学习器利用来自实例数据中某种类型的信息进行分类学习训练。,学习器,属于,分类学习训练
每种学习器利用来自实例数据中某种类型的信息进行分类学习训练。,学习器,实现,利用来自实例数据中某种类型的信息进行分类学习训练
每种学习器利用来自实例数据中某种类型的信息进行分类学习训练。,学习器,中文名,分类学习训练
与采用单个学习器的方法相比，多策略的学习方法能得到较高的分类准确率，并可以得到较好的联合分布近似值。,多策略的学习方法,属于,得到较高的分类准确率
与采用单个学习器的方法相比，多策略的学习方法能得到较高的分类准确率，并可以得到较好的联合分布近似值。,多策略的学习方法,属于,较好的联合分布近似值
与采用单个学习器的方法相比，多策略的学习方法能得到较高的分类准确率，并可以得到较好的联合分布近似值。,多策略的学习方法,实现,较高的分类准确率
与采用单个学习器的方法相比，多策略的学习方法能得到较高的分类准确率，并可以得到较好的联合分布近似值。,多策略的学习方法,实现,较好的联合分布近似值
与采用单个学习器的方法相比，多策略的学习方法能得到较高的分类准确率，并可以得到较好的联合分布近似值。,多策略的学习方法,中文名,得到较高的分类准确率
与采用单个学习器的方法相比，多策略的学习方法能得到较高的分类准确率，并可以得到较好的联合分布近似值。,多策略的学习方法,中文名,较好的联合分布近似值
目前实现的GLUE系统中有2个基本分类学习器：内容学习器和名字学习器。,内容学习器,属于,实现GLUE系统的分类学习器
目前实现的GLUE系统中有2个基本分类学习器：内容学习器和名字学习器。,名字学习器,实现,实现GLUE系统的分类学习器
目前实现的GLUE系统中有2个基本分类学习器：内容学习器和名字学习器。,内容学习器,中文名,内容学习器
目前实现的GLUE系统中有2个基本分类学习器：内容学习器和名字学习器。,名字学习器,中文名,名字学习器
此外，还有1个元学习器将基本学习器的结果进行线性合并。,元学习器,属于,基本学习器的结果进行线性合并
此外，还有1个元学习器将基本学习器的结果进行线性合并。,元学习器,实现,基本学习器的结果进行线性合并
内容学习器和名字学习器的细节如下：（a）内容学习器。,内容学习器,属于,SPO三元组抽取
内容学习器和名字学习器的细节如下：（a）内容学习器。,内容学习器,实现,细节抽取
内容学习器和名字学习器的细节如下：（a）内容学习器。,内容学习器,中文名,内容学习器
一个实例通常由名将这些信息都作为实例的文本内容。,实例,属于,一个实例通常由名将这些信息都作为实例的文本内容。
一个实例通常由名将这些信息都作为实例的文本内容。,实例,实现,名将这些信息都作为实例的文本内容。
一个实例通常由名将这些信息都作为实例的文本内容。,实例,中文名,一个实例通常由名将这些信息都作为实例的文本内容。
例如，实字、属性集合以及属性值组成。,SPO,属于,概念/三元组抽取
例如，实字、属性集合以及属性值组成。,SPO,实现,概念/三元组抽取
内容学习器采用贝叶斯学习技术[56]，这是最流行和有效的分类法之一。,内容学习器,属于,贝叶斯学习技术
内容学习器采用贝叶斯学习技术[56]，这是最流行和有效的分类法之一。,内容学习器,实现,分类法
"它采用分词和抽取词干技术将每个输入实例的文本内容表示为一组标记，即输入实例的内容表示为d={w1,…,wk}，其中的wj是标记。",内容表示的标记,属于,"输入实例的内容表示为d={w1,…,wk}"
"它采用分词和抽取词干技术将每个输入实例的文本内容表示为一组标记，即输入实例的内容表示为d={w1,…,wk}，其中的wj是标记。",分词和抽取词干技术,实现,将每个输入实例的文本内容表示为一组标记
"它采用分词和抽取词干技术将每个输入实例的文本内容表示为一组标记，即输入实例的内容表示为d={w1,…,wk}，其中的wj是标记。",内容表示的标记,中文名,内容表示的标记
其中，P(d)是一个常量，而P(d|A)和P(A)能通过训练实例来估计。,P(d),属于,常量
其中，P(d)是一个常量，而P(d|A)和P(A)能通过训练实例来估计。,P(d|A),实现,通过训练实例来估计
其中，P(d)是一个常量，而P(d|A)和P(A)能通过训练实例来估计。,P(d|A),中文名,通过训练实例来估计
特别地，P(A)被估计为属于A的实例占全部训练实例的比例。,P(A),属于,属于A的实例占全部训练实例的比例
特别地，P(A)被估计为属于A的实例占全部训练实例的比例。,P(A),实现,属于A的实例占全部训练实例的比例
特别地，P(A)被估计为属于A的实例占全部训练实例的比例。,P(A),中文名,属于A的实例占全部训练实例的比例
因此，只需要计算P(d|A)就可以得到P(A|d)。,p(d|A),属于,计算P(d|A)
因此，只需要计算P(d|A)就可以得到P(A|d)。,P(d|A),实现,P(A|d)
"为计算P(d|A)，假设实例的内容d中的标记wj是独立的，这样便有：P(d|A)=P(w1|A)P(w2|A)···P(wk|A)式中，P(wj|A)可用n(wj,A)/n(A)来估计，n(A)表示在属于A的训练实例中，所有标记出现的总次数，n(wj,A)则表示标记wj出现在属于A的训练实例中的次数。",P(d|A),属于,计算P(d|A)
"为计算P(d|A)，假设实例的内容d中的标记wj是独立的，这样便有：P(d|A)=P(w1|A)P(w2|A)···P(wk|A)式中，P(wj|A)可用n(wj,A)/n(A)来估计，n(A)表示在属于A的训练实例中，所有标记出现的总次数，n(wj,A)则表示标记wj出现在属于A的训练实例中的次数。",P(wj|A),实现,"n(wj,A)/n(A)"
"为计算P(d|A)，假设实例的内容d中的标记wj是独立的，这样便有：P(d|A)=P(w1|A)P(w2|A)···P(wk|A)式中，P(wj|A)可用n(wj,A)/n(A)来估计，n(A)表示在属于A的训练实例中，所有标记出现的总次数，n(wj,A)则表示标记wj出现在属于A的训练实例中的次数。",P(d|A),中文名,计算P(d|A)
注意，尽管标记独立假设在很多时候并不成立，但贝叶斯学习技术往往在很多领域都取得了不错的效果，这种现象的相关解释见文献[60]。,贝叶斯学习技术,属于,很多领域都取得了不错的效果
注意，尽管标记独立假设在很多时候并不成立，但贝叶斯学习技术往往在很多领域都取得了不错的效果，这种现象的相关解释见文献[60]。,标记独立假设,实现,在很多领域都取得了不错的效果
相似于内容学习器，但名字学习器利用实例的全名而不是实例的内容来进行分类预测。,名字学习器,属于,内容学习器
相似于内容学习器，但名字学习器利用实例的全名而不是实例的内容来进行分类预测。,名字学习器,实现,分类预测
相似于内容学习器，但名字学习器利用实例的全名而不是实例的内容来进行分类预测。,名字学习器,等价,内容学习器
这里的实例全名是指从根节点直到实例所在位置的路径上所有概念名的连接。,实例全名,属于,从根节点直到实例所在位置的路径上所有概念名的连接
这里的实例全名是指从根节点直到实例所在位置的路径上所有概念名的连接。,实例全名,实现,从根节点直到实例所在位置的路径上所有概念名的连接
基本学习器的预测结果通过元学习器来合并。,基本学习器,属于,元学习器
基本学习器的预测结果通过元学习器来合并。,基本学习器的预测结果,实现,合并
例如，假设内容学习器和名字学习器的权重分别是0.6和0.4；对于本体O2中的实例s4，如果内容学习器预测它属于A的概率为0.8，属于的概率为0.2，名字学习器预测它属于A的概率为0.3，属于的概率为0.7，则元学习器预测s4属于A的概率为0.8×0.6+0.3×0.4=0.6，属于的概率为0.4。,元学习器,属于,预测s4属于A的概率
例如，假设内容学习器和名字学习器的权重分别是0.6和0.4；对于本体O2中的实例s4，如果内容学习器预测它属于A的概率为0.8，属于的概率为0.2，名字学习器预测它属于A的概率为0.3，属于的概率为0.7，则元学习器预测s4属于A的概率为0.8×0.6+0.3×0.4=0.6，属于的概率为0.4。,内容学习器,实现,预测属于A的概率
例如，假设内容学习器和名字学习器的权重分别是0.6和0.4；对于本体O2中的实例s4，如果内容学习器预测它属于A的概率为0.8，属于的概率为0.2，名字学习器预测它属于A的概率为0.3，属于的概率为0.7，则元学习器预测s4属于A的概率为0.8×0.6+0.3×0.4=0.6，属于的概率为0.4。,名字学习器,实现,预测属于A的概率
这种基本学习器的权重往往由人工给定，但也可以使用机器学习的方法自动设置[57]。,基本学习器,属于,权重自动设置
这种基本学习器的权重往往由人工给定，但也可以使用机器学习的方法自动设置[57]。,基本学习器的权重,实现,人工给定
这种基本学习器的权重往往由人工给定，但也可以使用机器学习的方法自动设置[57]。,基本学习器,中文名,权重自动设置
放松标记是一种解决图中节点的标签分配问题的有效技术。,放松标记,属于,解决图中节点的标签分配问题的有效技术
放松标记是一种解决图中节点的标签分配问题的有效技术。,放松标记,实现,解决图中节点的标签分配问题的有效技术
该方法的思想是节点的标签通常受其邻居的特征影响。,A-priori,属于,概念/实现A-priori
该方法的思想是节点的标签通常受其邻居的特征影响。,概念/实现A-priori,实现,节点的标签通常受其邻居的特征影响。
该方法的思想是节点的标签通常受其邻居的特征影响。,A-priori,中文名,概念/实现A-priori
基于这种观察，放松标记技术将节点邻居对其标签的影响用公式量化。,放松标记技术,属于,节点邻居对其标签的影响
基于这种观察，放松标记技术将节点邻居对其标签的影响用公式量化。,放松标记技术,实现,用公式量化
放松标记技术已成功用于计算机视觉和自然语言处理等领域中的相似匹配。,放松标记技术,属于,相似匹配
放松标记技术已成功用于计算机视觉和自然语言处理等领域中的相似匹配。,放松标记技术,实现,计算机视觉
放松标记技术已成功用于计算机视觉和自然语言处理等领域中的相似匹配。,放松标记技术,实现,自然语言处理
放松标记技术已成功用于计算机视觉和自然语言处理等领域中的相似匹配。,放松标记技术,中文名,相似匹配技术
约束又可分为领域独立约束和领域依赖约束两种。,约束,属于,领域独立约束
约束又可分为领域独立约束和领域依赖约束两种。,约束,属于,领域依赖约束
约束又可分为领域独立约束和领域依赖约束两种。,约束,实现,领域独立约束的查询功能
约束又可分为领域独立约束和领域依赖约束两种。,约束,实现,领域依赖约束的查询功能
约束又可分为领域独立约束和领域依赖约束两种。,约束,中文名,领域独立约束
领域独立约束表示相关节点间交互的通用知识，其中最常用的两种约束是邻居约束和并集约束。,领域独立约束,属于,相关节点间交互的通用知识
领域独立约束表示相关节点间交互的通用知识，其中最常用的两种约束是邻居约束和并集约束。,领域独立约束,实现,邻居约束
领域独立约束表示相关节点间交互的通用知识，其中最常用的两种约束是邻居约束和并集约束。,领域独立约束,中文名,相关节点间交互的通用知识
邻居约束是指“两节点的邻居匹配，则两节点也匹配”；并集约束指“如果节点X的全部孩子匹配Y，那么节点X也匹配Y”；该约束适用于分类本体，它基于这样的事实，即X是它的所有孩子的并集。,邻居约束,属于,分类本体的约束
邻居约束是指“两节点的邻居匹配，则两节点也匹配”；并集约束指“如果节点X的全部孩子匹配Y，那么节点X也匹配Y”；该约束适用于分类本体，它基于这样的事实，即X是它的所有孩子的并集。,并集约束,实现,“如果节点X的全部孩子匹配Y，那么节点X也匹配Y”
邻居约束是指“两节点的邻居匹配，则两节点也匹配”；并集约束指“如果节点X的全部孩子匹配Y，那么节点X也匹配Y”；该约束适用于分类本体，它基于这样的事实，即X是它的所有孩子的并集。,并集约束,中文名,“如果节点X的全部孩子匹配Y，那么节点X也匹配Y”
邻居约束是指“两节点的邻居匹配，则两节点也匹配”；并集约束指“如果节点X的全部孩子匹配Y，那么节点X也匹配Y”；该约束适用于分类本体，它基于这样的事实，即X是它的所有孩子的并集。,并集约束,等价,“如果节点X的全部孩子匹配Y，那么节点X也匹配Y”
领域依赖约束表示特定节点间交互的用户知识，在GLUE系统中，它可分为包含、频率和邻近三种。,领域依赖约束,属于,特定节点间交互的用户知识
领域依赖约束表示特定节点间交互的用户知识，在GLUE系统中，它可分为包含、频率和邻近三种。,领域依赖约束,实现,特定节点间交互的用户知识
领域依赖约束表示特定节点间交互的用户知识，在GLUE系统中，它可分为包含、频率和邻近三种。,领域依赖约束,中文名,节点间交互的用户知识
GLUE利用这些限制进一步寻找正确的映射或去除不太可能的映射。,GLUE,属于,寻找正确的映射或去除不太可能的映射
GLUE利用这些限制进一步寻找正确的映射或去除不太可能的映射。,GLUE,实现,进一步寻找正确的映射或去除不太可能的映射
GLUE系统的实验结果表明，对于1∶1的映射，正确率为66%～97%。,GLUE系统,属于,实验结果
GLUE系统的实验结果表明，对于1∶1的映射，正确率为66%～97%。,GLUE系统的正确率,实现,对于1∶1的映射
在基本学习器中，内容学习器的正确率为52%～83%，而名字学习器的正确率很低，只有12%～15%。,内容学习器,属于,基本学习器
在基本学习器中，内容学习器的正确率为52%～83%，而名字学习器的正确率很低，只有12%～15%。,内容学习器,实现,正确率52%～83%
在基本学习器中，内容学习器的正确率为52%～83%，而名字学习器的正确率很低，只有12%～15%。,内容学习器,中文名,内容学习器
在半数的实验中，元学习器只少量提高正确率，在另一半的实验中，正确率提高了6%～15%。,元学习器,属于,提高正确率
在半数的实验中，元学习器只少量提高正确率，在另一半的实验中，正确率提高了6%～15%。,元学习器,实现,在半数的实验中，正确率提高了6%～15%
在半数的实验中，元学习器只少量提高正确率，在另一半的实验中，正确率提高了6%～15%。,元学习器,中文名,在半数的实验中，正确率提高了6%～15%
放松标记能进一步提高3%～18%的正确率，只有一个实验例外。,放松标记,属于,提高正确率
放松标记能进一步提高3%～18%的正确率，只有一个实验例外。,放松标记,实现,进一步提高3%～18%的正确率
其次，利用放松标签进行优化的时候可能没有考虑全局的知识，因此优化的映射结果对整个本体来说并不是最佳的。,利用放松标签进行优化,属于,考虑全局的知识
其次，利用放松标签进行优化的时候可能没有考虑全局的知识，因此优化的映射结果对整个本体来说并不是最佳的。,利用放松标签进行优化,实现,优化的映射结果对整个本体来说并不是最佳的
其次，利用放松标签进行优化的时候可能没有考虑全局的知识，因此优化的映射结果对整个本体来说并不是最佳的。,利用放松标签进行优化,中文名,考虑全局的知识
第三，在实现中使用的两个基本学习器是通用的文本分类器，使用适合待映射本体的特定学习器可以得到更好的正确率。,实现,属于,通用的文本分类器
第三，在实现中使用的两个基本学习器是通用的文本分类器，使用适合待映射本体的特定学习器可以得到更好的正确率。,在实现中使用的两个基本学习器,实现,通用的文本分类器
第三，在实现中使用的两个基本学习器是通用的文本分类器，使用适合待映射本体的特定学习器可以得到更好的正确率。,在实现中使用的两个基本学习器,实现,使用适合待映射本体的特定学习器
最后，有些节点的描述过于含糊，机器很难判断与之相关的映射。,节点的描述,属于,很难判断与之相关的映射
最后，有些节点的描述过于含糊，机器很难判断与之相关的映射。,节点的描述,实现,机器很难判断与之相关的映射
CGLUE中的复杂映射形式如A=X1op1X2op2…opn-1Xn，其中A是O1中的概念，Xi是O2中的概念，opi是算子。,CGLUE中的复杂映射形式,属于,复杂映射形式
CGLUE中的复杂映射形式如A=X1op1X2op2…opn-1Xn，其中A是O1中的概念，Xi是O2中的概念，opi是算子。,CGLUE中的复杂映射形式,实现,复杂映射形式
这种1∶n的映射可扩展为m∶n的形式，如A1op1A2=X1op1X2op2X3。,m∶n,属于,1∶n的映射
这种1∶n的映射可扩展为m∶n的形式，如A1op1A2=X1op1X2op2X3。,m∶n,实现,A1op1A2=X1op1X2op2X3
由于将概念看作实例的集合，因此opi可以是并、差和补等集合运算符。,opi,属于,集合运算符
由于将概念看作实例的集合，因此opi可以是并、差和补等集合运算符。,opi,实现,并集合运算符
由于将概念看作实例的集合，因此opi可以是并、差和补等集合运算符。,opi,实现,差集合运算符
由于将概念看作实例的集合，因此opi可以是并、差和补等集合运算符。,opi,实现,补集合运算符
由于将概念看作实例的集合，因此opi可以是并、差和补等集合运算符。,opi,中文名,并集合运算符
"CGLUE还进一步假设概念D的孩子C1,C2,…,Ck要满足条件,1≤i,j≤k,i≠j，且。",CGLUE,属于,概念/产品
"CGLUE还进一步假设概念D的孩子C1,C2,…,Ck要满足条件,1≤i,j≤k,i≠j，且。",CGLUE,实现,概念/产品
"CGLUE还进一步假设概念D的孩子C1,C2,…,Ck要满足条件,1≤i,j≤k,i≠j，且。",CGLUE,中文名,概念/产品
CGLUE将复合概念都可以重写为概念并的形式，便于统一处理。,CGLUE,属于,复合概念
CGLUE将复合概念都可以重写为概念并的形式，便于统一处理。,CGLUE,实现,统一处理复合概念
CGLUE将复合概念都可以重写为概念并的形式，便于统一处理。,CGLUE,中文名,概念并的形式
由于概念并组合的数目是指数级的，上面的“暴力”方法是不实用的。,概念并组合,属于,概念/组合
由于概念并组合的数目是指数级的，上面的“暴力”方法是不实用的。,概念并组合,实现,索引
由于概念并组合的数目是指数级的，上面的“暴力”方法是不实用的。,概念并组合,中文名,概念并组合
因此需要考虑从巨量的候选复合概念中搜索A的近似。,A的近似,属于,搜索A的近似
因此需要考虑从巨量的候选复合概念中搜索A的近似。,从巨量的候选复合概念中搜索A的近似,实现,考虑
令初始候选集合S为O2的全部原子概念集合。,S,属于,初始候选集合
令初始候选集合S为O2的全部原子概念集合。,S,实现,O2的全部原子概念集合
循环：（a）计算A和S中每个候选对象的相似度分数。,循环,属于,相似度计算
循环：（a）计算A和S中每个候选对象的相似度分数。,循环,实现,计算A和S中每个候选对象的相似度分数
（b）令new_highest_sim为S中对象的最高相似度分数。,S,属于,SPO三元组
（b）令new_highest_sim为S中对象的最高相似度分数。,new_highest_sim,实现,返回空列表
（b）令new_highest_sim为S中对象的最高相似度分数。,S,中文名,SPO三元组
（d）否则，选择C中有最高分的k个候选对象。,选择C中有最高分的k个候选对象,属于,否则
（d）否则，选择C中有最高分的k个候选对象。,选择C中有最高分的k个候选对象,实现,否则，选择C中有最高分的k个候选对象。
（d）否则，选择C中有最高分的k个候选对象。,选择C中有最高分的k个候选对象,中文名,否则，选择C中有最高分的k个候选对象。
在步骤2（c）中，ε最初设置为0。,ε,属于,步骤2（c）
在步骤2（c）中，ε最初设置为0。,ε,实现,步骤2（c）中，ε最初设置为0。
在步骤2（c）中，ε最初设置为0。,ε,中文名,ε
在步骤2（d）中，对于选择的k个候选对象，算法将它们与O2中的节点分别进行并操作，这样一共产生k|O2|个新候的选对象；接着，去除前面使用的候选对象。,并操作,属于,对于选择的k个候选对象
在步骤2（d）中，对于选择的k个候选对象，算法将它们与O2中的节点分别进行并操作，这样一共产生k|O2|个新候的选对象；接着，去除前面使用的候选对象。,并操作,实现,去除前面使用的候选对象
因为每个候选对象只是O2概念的并，去除过程很快。,O2,属于,概念
因为每个候选对象只是O2概念的并，去除过程很快。,O2,实现,快速
实验还表明，CGLUE能帮助用户确定52%～84%的正确1∶1映射。,CGLUE,属于,概念/产品
实验还表明，CGLUE能帮助用户确定52%～84%的正确1∶1映射。,CGLUE,实现,帮助用户确定52%～84%的正确1∶1映射
实验还表明，CGLUE能帮助用户确定52%～84%的正确1∶1映射。,CGLUE,中文名,概念/产品
GLUE是早期经典的本体映射工作之一，该方法取得的结果较早期大多的映射发现技术更好。,GLUE,属于,早期经典的本体映射工作之一
GLUE是早期经典的本体映射工作之一，该方法取得的结果较早期大多的映射发现技术更好。,GLUE,实现,较好的结果
GLUE是早期经典的本体映射工作之一，该方法取得的结果较早期大多的映射发现技术更好。,GLUE,中文名,本体映射工作
扩展后的CGLUE系统还能进一步发现概念间1∶n类型的映射。,CGLUE,属于,发现概念间1∶n类型的映射
扩展后的CGLUE系统还能进一步发现概念间1∶n类型的映射。,CGLUE,实现,进一步发现概念间1∶n类型的映射
尽管GLUE取得了很多不错的映射结果，但该方法还存在一些不足。,GLUE,属于,映射方法
尽管GLUE取得了很多不错的映射结果，但该方法还存在一些不足。,GLUE,实现,取得很多不错的映射结果
尽管GLUE取得了很多不错的映射结果，但该方法还存在一些不足。,GLUE,中文名,映射方法
在本体查询系统中，信息源和查询都是针对特定本体的。,信息源,属于,本体查询系统
在本体查询系统中，信息源和查询都是针对特定本体的。,查询,实现,针对特定本体的
不同的信息系统可能使用不同的本体，一个查询用某个本体中的词汇表达，但系统可能使用另一个本体，因而无法回答这个查询。,本体,属于,不同的信息系统
不同的信息系统可能使用不同的本体，一个查询用某个本体中的词汇表达，但系统可能使用另一个本体，因而无法回答这个查询。,查询,实现,某个本体中的词汇表达
一般地，如果S是基于本体O的信息源，则S只能回答关于O的查询。,S,属于,基于本体O的信息源
一般地，如果S是基于本体O的信息源，则S只能回答关于O的查询。,S的回答查询,实现,基于本体O的信息源
一般地，如果S是基于本体O的信息源，则S只能回答关于O的查询。,S,中文名,基于本体O的信息源
当不存在一个全局本体时，异构查询问题通常需要在这两个本体之间解决。,异构查询问题,属于,不存在一个全局本体时解决异构查询问题通常
当不存在一个全局本体时，异构查询问题通常需要在这两个本体之间解决。,异构查询问题,实现,在这两个本体之间解决
当不存在一个全局本体时，异构查询问题通常需要在这两个本体之间解决。,异构查询问题,中文名,不存在一个全局本体时解决异构查询问题
查询重写的理想目标是把关于O1的查询重写为关于O2的解释相同的查询，这样系统才能准确地给出查询结果。,查询重写,等价,把关于O1的查询重写为关于O2的解释相同的查询
但是对于O1中的很多查询，可能不存在关于O2的解释相同的查询，或者找到这样的查询所需的时间是不可接受的，因此常常需要重写为解释近似于原查询的查询。,重写为解释近似于原查询的查询,属于,查找相似查询
但是对于O1中的很多查询，可能不存在关于O2的解释相同的查询，或者找到这样的查询所需的时间是不可接受的，因此常常需要重写为解释近似于原查询的查询。,对于O1中的很多查询,实现,查找相似查询
但是对于O1中的很多查询，可能不存在关于O2的解释相同的查询，或者找到这样的查询所需的时间是不可接受的，因此常常需要重写为解释近似于原查询的查询。,重写为解释近似于原查询的查询,中文名,重写为解释近似于原查询的查询
令Q为关于O1的查询，R是重写Q得到的关于O2的近似查询，称R是Q在O2中的近似；令O2中全部概念的集合为T，则也称R是Q在T中的近似。,Q,属于,关于O1的查询
令Q为关于O1的查询，R是重写Q得到的关于O2的近似查询，称R是Q在O2中的近似；令O2中全部概念的集合为T，则也称R是Q在T中的近似。,R,属于,关于O2的近似查询
令Q为关于O1的查询，R是重写Q得到的关于O2的近似查询，称R是Q在O2中的近似；令O2中全部概念的集合为T，则也称R是Q在T中的近似。,Q在O2中的近似,实现,R
令Q为关于O1的查询，R是重写Q得到的关于O2的近似查询，称R是Q在O2中的近似；令O2中全部概念的集合为T，则也称R是Q在T中的近似。,Q在T中的近似,中文名,R
R作为Q在T中的近似，它在信息源S中的查全率和查准率可定义为：查全率和查准率决定了近似的质量，较好的近似有较高的查全率和查准率。,R,属于,Q在T中的近似
R作为Q在T中的近似，它在信息源S中的查全率和查准率可定义为：查全率和查准率决定了近似的质量，较好的近似有较高的查全率和查准率。,R在信息源S中的查全率和查准率,实现,查全率和查准率
R作为Q在T中的近似，它在信息源S中的查全率和查准率可定义为：查全率和查准率决定了近似的质量，较好的近似有较高的查全率和查准率。,R在信息源S中的查全率和查准率,中文名,近似的质量
"如果在所有S中都有recall(Q,R)=1，则近似查询结果包括了所有原查询的结果，称R是完备的；如果在所有S中都有precision(Q,R)=1，则所有近似查询结果都是原查询的结果，称R是正确的。",完备的,等价,所有原查询的结果
"如果在所有S中都有recall(Q,R)=1，则近似查询结果包括了所有原查询的结果，称R是完备的；如果在所有S中都有precision(Q,R)=1，则所有近似查询结果都是原查询的结果，称R是正确的。",正确的,等价,所有近似查询的结果
查询间的蕴涵关系可用来寻找完备或正确的近似，如果QR，那么R一定是完备的，称R是Q在T中的一个上近似；反之，如果RQ，那么R一定是正确的，称R是Q在T中的一个下近似。,上近似,属于,查询间的蕴涵关系
查询间的蕴涵关系可用来寻找完备或正确的近似，如果QR，那么R一定是完备的，称R是Q在T中的一个上近似；反之，如果RQ，那么R一定是正确的，称R是Q在T中的一个下近似。,下近似,实现,查询间的蕴涵关系
定义5.11令C为O1中概念，T为O2中全部概念的集合。,O1,属于,C
定义5.11令C为O1中概念，T为O2中全部概念的集合。,O2,实现,T
"因为非算子可以通过将查询化为否定正规形式（NegationNormal_Form,NNF）消去[58]。",非算子,属于,"将查询化为否定正规形式（NegationNormal_Form,NNF）消去"
"因为非算子可以通过将查询化为否定正规形式（NegationNormal_Form,NNF）消去[58]。",非算子,实现,消去
任何查询都可以在线性时间内通过反复应用以下公式改写为等价的NNF在NNF中，非算子只作用于单个概念，可以将其看作一个新的概念进行处理。,非算子,属于,在线性时间内通过反复应用以下公式改写为等价的NNF
任何查询都可以在线性时间内通过反复应用以下公式改写为等价的NNF在NNF中，非算子只作用于单个概念，可以将其看作一个新的概念进行处理。,非算子,实现,可以将概念看作一个新的概念进行处理
任何查询都可以在线性时间内通过反复应用以下公式改写为等价的NNF在NNF中，非算子只作用于单个概念，可以将其看作一个新的概念进行处理。,非算子,等价,将概念看作一个新的概念进行处理
这样概念数目最多翻倍，但所有非算子都被消去。,SPO,属于,概念
这样概念数目最多翻倍，但所有非算子都被消去。,SPO,实现,概念数目最多翻倍
这样概念数目最多翻倍，但所有非算子都被消去。,SPO,中文名,SPO三元组抽取
"Akahani_J等人对定义5.10和定义5.11进行了扩展[59]，改写为T中概念D属于O1中概念C在T中最小上界lub(C,T)，当且仅当CD，且不存在A∈T满足CAD;T中概念D属于O1中概念C在T中最大下界glb(C,T)，当且仅当DC，且不存在A∈T满足DAC。",T中概念D,属于,O1中概念C
"Akahani_J等人对定义5.10和定义5.11进行了扩展[59]，改写为T中概念D属于O1中概念C在T中最小上界lub(C,T)，当且仅当CD，且不存在A∈T满足CAD;T中概念D属于O1中概念C在T中最大下界glb(C,T)，当且仅当DC，且不存在A∈T满足DAC。","T中概念D属于O1中概念C在T中最小上界lub(C,T)",实现,当且仅当CD且不存在A∈T满足CAD
"Akahani_J等人对定义5.10和定义5.11进行了扩展[59]，改写为T中概念D属于O1中概念C在T中最小上界lub(C,T)，当且仅当CD，且不存在A∈T满足CAD;T中概念D属于O1中概念C在T中最大下界glb(C,T)，当且仅当DC，且不存在A∈T满足DAC。","T中概念D属于O1中概念C在T中最大下界glb(C,T)",中文名,当且仅当DC且不存在A∈T满足DAC
上述扩展定义去除了最小上界和最大下界中的大量冗余成员，提高了效率。,扩展定义,属于,去除了最小上界和最大下界
上述扩展定义去除了最小上界和最大下界中的大量冗余成员，提高了效率。,扩展定义,实现,提高效率
但由于最小上界和最大下界是T的子集，本身不会很大，效果并不明显。,最小上界,属于,T的子集
但由于最小上界和最大下界是T的子集，本身不会很大，效果并不明显。,最大下界,属于,T的子集
但由于最小上界和最大下界是T的子集，本身不会很大，效果并不明显。,最小上界和最大下界,实现,T
但由于最小上界和最大下界是T的子集，本身不会很大，效果并不明显。,最小上界,中文名,最大下界
但由于最小上界和最大下界是T的子集，本身不会很大，效果并不明显。,最大下界,中文名,最小上界
在生成概念的近似过程中，该方法首先找到概念在系统本体中的超类和子类，然后生成概念的最小上界和最大下界，并将上界的合取作为概念的上近似，下界的析取作为概念的下近似。,近似概念,属于,找到概念在系统本体中的超类和子类
在生成概念的近似过程中，该方法首先找到概念在系统本体中的超类和子类，然后生成概念的最小上界和最大下界，并将上界的合取作为概念的上近似，下界的析取作为概念的下近似。,近似概念,属于,生成概念的最小上界和最大下界
在生成概念的近似过程中，该方法首先找到概念在系统本体中的超类和子类，然后生成概念的最小上界和最大下界，并将上界的合取作为概念的上近似，下界的析取作为概念的下近似。,近似概念,实现,找到概念在系统本体中的超类和子类
在生成概念的近似过程中，该方法首先找到概念在系统本体中的超类和子类，然后生成概念的最小上界和最大下界，并将上界的合取作为概念的上近似，下界的析取作为概念的下近似。,近似概念,实现,生成概念的最小上界和最大下界
在生成概念的近似过程中，该方法首先找到概念在系统本体中的超类和子类，然后生成概念的最小上界和最大下界，并将上界的合取作为概念的上近似，下界的析取作为概念的下近似。,概念的近似,等价,找到概念在系统本体中的超类和子类
在生成概念的近似过程中，该方法首先找到概念在系统本体中的超类和子类，然后生成概念的最小上界和最大下界，并将上界的合取作为概念的上近似，下界的析取作为概念的下近似。,概念的近似,等价,生成概念的最小上界和最大下界
在生成概念的近似过程中，该方法首先找到概念在系统本体中的超类和子类，然后生成概念的最小上界和最大下界，并将上界的合取作为概念的上近似，下界的析取作为概念的下近似。,概念的近似,等价,将上界的合取作为概念的上近似
在生成概念的近似过程中，该方法首先找到概念在系统本体中的超类和子类，然后生成概念的最小上界和最大下界，并将上界的合取作为概念的上近似，下界的析取作为概念的下近似。,概念的近似,等价,下界的析取作为概念的下近似
但这种方法无法得到概念的最佳近似，近似的质量有时是不可接受的。,概念的近似,属于,无法得到概念的最佳近似
但这种方法无法得到概念的最佳近似，近似的质量有时是不可接受的。,概念的近似,实现,但这种方法无法得到概念的最佳近似
同样，如果概念远大于它的子类，那么它的下近似可能过小；最坏情况是找不到概念的子类，那么下近似的查询结果就会返回空集。,下近似,等价,找不到概念的子类
异构本体常常有全异的概念集合和概念层次，因此最坏的情况也时常会出现。,异构本体,属于,全异的概念集合
异构本体常常有全异的概念集合和概念层次，因此最坏的情况也时常会出现。,异构本体,属于,概念层次
异构本体常常有全异的概念集合和概念层次，因此最坏的情况也时常会出现。,异构本体,实现,最坏的情况也时常会出现
异构本体常常有全异的概念集合和概念层次，因此最坏的情况也时常会出现。,异构本体,中文名,异构本体
如果考虑这些蕴涵关系，也许可以提高近似查询的质量。,蕴涵关系,属于,近似查询的质量
如果考虑这些蕴涵关系，也许可以提高近似查询的质量。,近似查询,实现,提高
"例如，令O1,O2为本体，C为O1中概念，T是O2中所有概念的集合，且T中没有概念能蕴涵C或被C蕴涵，则现有方法对C求上近似会返回全集top，下近似返回空集bot。",上近似,属于,现有方法对C求上近似
"例如，令O1,O2为本体，C为O1中概念，T是O2中所有概念的集合，且T中没有概念能蕴涵C或被C蕴涵，则现有方法对C求上近似会返回全集top，下近似返回空集bot。",下近似,实现,现有方法对C求下近似
"例如，令O1,O2为本体，C为O1中概念，T是O2中所有概念的集合，且T中没有概念能蕴涵C或被C蕴涵，则现有方法对C求上近似会返回全集top，下近似返回空集bot。",上近似,中文名,全集top
"例如，令O1,O2为本体，C为O1中概念，T是O2中所有概念的集合，且T中没有概念能蕴涵C或被C蕴涵，则现有方法对C求上近似会返回全集top，下近似返回空集bot。",下近似,中文名,空集bot
"例如，令O1,O2为本体，C为O1中概念，T是O2中所有概念的集合，且T中没有概念能蕴涵C或被C蕴涵，则现有方法对C求上近似会返回全集top，下近似返回空集bot。",O1,等价,本体
"例如，令O1,O2为本体，C为O1中概念，T是O2中所有概念的集合，且T中没有概念能蕴涵C或被C蕴涵，则现有方法对C求上近似会返回全集top，下近似返回空集bot。",O2,等价,本体
"但如果T中有概念A,B满足A∧BCA∨B，则A∨B是C的一个上近似，A∧B是C的一个下近似，它们显然比现有的近似要好。",A∨B,属于,C的一个上近似
"但如果T中有概念A,B满足A∧BCA∨B，则A∨B是C的一个上近似，A∧B是C的一个下近似，它们显然比现有的近似要好。",A∧B,属于,C的一个下近似
"但如果T中有概念A,B满足A∧BCA∨B，则A∨B是C的一个上近似，A∧B是C的一个下近似，它们显然比现有的近似要好。",A∨B,实现,较好的
"但如果T中有概念A,B满足A∧BCA∨B，则A∨B是C的一个上近似，A∧B是C的一个下近似，它们显然比现有的近似要好。",A∧B,实现,较好的
"显然，A,B,C之间不存在任何蕴涵关系，但有A∧BCA∨B。",A,属于,蕴涵关系
"显然，A,B,C之间不存在任何蕴涵关系，但有A∧BCA∨B。",A∧BC,实现,A∨B
"显然，A,B,C之间不存在任何蕴涵关系，但有A∧BCA∨B。",A,中文名,A∨B
它根据每个查询结果中的实例进行查询重写：对每一个应该是原查询结果的实例，找到能返回该实例的另一个本体中的最小查询，最后把这些最小查询组合起来得到原查询的一个近似。,查询重写,属于,根据每个查询结果中的实例进行查询
它根据每个查询结果中的实例进行查询重写：对每一个应该是原查询结果的实例，找到能返回该实例的另一个本体中的最小查询，最后把这些最小查询组合起来得到原查询的一个近似。,查询重写,实现,对每一个应该是原查询结果的实例，找到能返回该实例的另一个本体中的最小查询
它根据每个查询结果中的实例进行查询重写：对每一个应该是原查询结果的实例，找到能返回该实例的另一个本体中的最小查询，最后把这些最小查询组合起来得到原查询的一个近似。,查询重写,中文名,根据每个查询结果中的实例进行查询重写
这样，对于非空对象集合K，它的上界和下界可计算为：显然，由于K+和K-中的查询表达式数目可能会很多，这样的上、下界表达式长度会很长，需要一种方法计算等价的且长度有限的查询。,上界,属于,非空对象集合K
这样，对于非空对象集合K，它的上界和下界可计算为：显然，由于K+和K-中的查询表达式数目可能会很多，这样的上、下界表达式长度会很长，需要一种方法计算等价的且长度有限的查询。,上界计算,实现,等价的且长度有限的查询
这样，对于非空对象集合K，它的上界和下界可计算为：显然，由于K+和K-中的查询表达式数目可能会很多，这样的上、下界表达式长度会很长，需要一种方法计算等价的且长度有限的查询。,非空对象集合K,等价,K+和K-中的查询表达式数目
为此，引入一个将对象映射到概念合取的函数：。,将对象映射到概念合取的函数：,属于,函数
为此，引入一个将对象映射到概念合取的函数：。,将对象映射到概念合取的函数：,实现,将对象映射到概念合取
为此，引入一个将对象映射到概念合取的函数：。,将对象映射到概念合取的函数：,中文名,将对象映射到概念合取的函数
可证明利用DI(o)能得到与上界和下界等价的近似表示形式，这种表示的长度是有限的：对于概念C，如果K=CI(S)，那么name+(K)是C关于T的最小上近似，name-(K)是最大下近似。,DI(o),等价,得到与上界和下界等价的近似表示形式
对于给定的查询，只需要将其中的概念按照这种近似表示就能重写概念近似查询。,概念近似查询,属于,概念近似查询查询
对于给定的查询，只需要将其中的概念按照这种近似表示就能重写概念近似查询。,概念近似查询,实现,重写概念近似查询
与Stuckenschmidt_H的方法相比，这种表示不会造成映射结果的丢失，即能得到完备的概念间近似，但这种方法存在着明显的缺点。,表示概念间近似,属于,与Stuckenschmidt_H的方法相比
与Stuckenschmidt_H的方法相比，这种表示不会造成映射结果的丢失，即能得到完备的概念间近似，但这种方法存在着明显的缺点。,不会造成映射结果的丢失,实现,得到完备的概念间近似
得到的近似查询是由很多小查询构成的，比较冗长，但表达式的长度却没有算法来简化。,得到的近似查询,属于,很多小查询构成的
得到的近似查询是由很多小查询构成的，比较冗长，但表达式的长度却没有算法来简化。,得到的近似查询,实现,比较冗长
得到的近似查询是由很多小查询构成的，比较冗长，但表达式的长度却没有算法来简化。,得到的近似查询,中文名,很多小查询构成的
最后，该方法得到的近似不能传递，即不能从和得到，因为它们可能是根据不同的训练集得到的结果。,近似,属于,不能传递
最后，该方法得到的近似不能传递，即不能从和得到，因为它们可能是根据不同的训练集得到的结果。,近似,实现,不能从和得到
Kang_Dazhou、Lu_Jianjiang和Xu_Baowen等人提出一套表示和发现概念近似查询的有效方法[61-63]，该方法能有效发现异构本体间概念的近似，且这种近似是最佳的和完备的。,概念近似查询,等价,发现异构本体间概念的近似
将概念的最小上界和最大下界扩展为多元界：引入概念的析取定义概念的多元最小上界，引入概念的合取定义概念的多元最大下界。,概念的析取定义概念的多元最小上界,属于,将概念的最小上界扩展为多元界
将概念的最小上界和最大下界扩展为多元界：引入概念的析取定义概念的多元最小上界，引入概念的合取定义概念的多元最大下界。,概念的合取定义概念的多元最大下界,实现,将概念的最大下界扩展为多元界
该方法又定义了概念的最简多元最小上界和最简多元最大下界去除这些冗余，并提供两个有效的算法寻找概念的最简多元界，算法被证明是正确和完备的。,概念的多元界,属于,寻找概念的最简多元界
该方法又定义了概念的最简多元最小上界和最简多元最大下界去除这些冗余，并提供两个有效的算法寻找概念的最简多元界，算法被证明是正确和完备的。,寻找概念的最简多元界,实现,去除这些冗余
该方法又定义了概念的最简多元最小上界和最简多元最大下界去除这些冗余，并提供两个有效的算法寻找概念的最简多元界，算法被证明是正确和完备的。,寻找概念的最简多元界,中文名,概念的最简多元最小上界
引入复杂概念间的蕴涵关系，将概念析取扩充到概念的上界中，将概念合取扩充到概念的下界中。,概念析取,属于,概念间蕴涵关系
引入复杂概念间的蕴涵关系，将概念析取扩充到概念的上界中，将概念合取扩充到概念的下界中。,概念合取,实现,概念上界
由于上下界中都含有多个概念组成的复杂概念，称新的上下界为概念的多元界。,多元界,属于,上下界
由于上下界中都含有多个概念组成的复杂概念，称新的上下界为概念的多元界。,多元界,实现,新的上下界
证明利用多元界可以求得概念的最佳近似，从而提高近似查询的质量。,多元界,属于,概念/实现近似查询的质量
证明利用多元界可以求得概念的最佳近似，从而提高近似查询的质量。,多元界,实现,求得概念的最佳近似
该方法的结果是合并后的本体，但结果本体间接蕴涵着两个初始本体间的概念映射：被合并的概念可认为是等价映射，它们与对应的祖先或孩子节点之间存在包含关系的映射，与对应的兄弟概念存在着相似关系。,合并后的本体,属于,概念映射
该方法的结果是合并后的本体，但结果本体间接蕴涵着两个初始本体间的概念映射：被合并的概念可认为是等价映射，它们与对应的祖先或孩子节点之间存在包含关系的映射，与对应的兄弟概念存在着相似关系。,该方法,实现,合并后的本体间概念映射
该方法的结果是合并后的本体，但结果本体间接蕴涵着两个初始本体间的概念映射：被合并的概念可认为是等价映射，它们与对应的祖先或孩子节点之间存在包含关系的映射，与对应的兄弟概念存在着相似关系。,合并后的本体间概念映射,中文名,被合并的概念可认为是等价映射
该方法的结果是合并后的本体，但结果本体间接蕴涵着两个初始本体间的概念映射：被合并的概念可认为是等价映射，它们与对应的祖先或孩子节点之间存在包含关系的映射，与对应的兄弟概念存在着相似关系。,概念映射,等价,被合并的概念可认为是等价映射
另外，概念格通过Hasse图生动和简洁地体现了这些概念之间的泛化和特化关系。,概念格,属于,泛化和特化关系
另外，概念格通过Hasse图生动和简洁地体现了这些概念之间的泛化和特化关系。,概念格,实现,通过Hasse图生动和简洁地体现了这些概念之间的泛化和特化关系
另外，概念格通过Hasse图生动和简洁地体现了这些概念之间的泛化和特化关系。,概念格,中文名,概念格
"形式背景可表示为三元组形式T=(S,D,R)，其中S是实例集合，D是属性集合，R是S和D之间的一个二元关系，即R∈S×D。",形式背景,属于,"三元组形式T=(S,D,R)"
"形式背景可表示为三元组形式T=(S,D,R)，其中S是实例集合，D是属性集合，R是S和D之间的一个二元关系，即R∈S×D。",形式背景,实现,"S,D,R"
"形式背景可表示为三元组形式T=(S,D,R)，其中S是实例集合，D是属性集合，R是S和D之间的一个二元关系，即R∈S×D。",形式背景,中文名,"三元组形式T=(S,D,R)"
一个形式背景存在唯一的一个偏序集合与之对应，并且这个偏序集合产生一种格结构。,形式背景,属于,偏序集合
一个形式背景存在唯一的一个偏序集合与之对应，并且这个偏序集合产生一种格结构。,形式背景,实现,格结构
"这种由背景(S,D,R)导出的格L就称为一个概念格。",概念格,属于,"背景(S,D,R)导出的格L"
"这种由背景(S,D,R)导出的格L就称为一个概念格。",概念格,实现,一个概念格
"这种由背景(S,D,R)导出的格L就称为一个概念格。",概念格,中文名,概念格
"给定H1=(X1,Y1)和H2=(X2,Y2)，则H2<H1⇔Y1<Y2，领先次序意味着H2是H1的父节点或称直接泛化。",领先次序,属于,概念/节点间的关系
"给定H1=(X1,Y1)和H2=(X2,Y2)，则H2<H1⇔Y1<Y2，领先次序意味着H2是H1的父节点或称直接泛化。",领先次序,实现,"给定H1=(X1,Y1)和H2=(X2,Y2)，则H2<H1⇔Y1<Y2"
"给定H1=(X1,Y1)和H2=(X2,Y2)，则H2<H1⇔Y1<Y2，领先次序意味着H2是H1的父节点或称直接泛化。",领先次序,中文名,节点间的关系
"给定H1=(X1,Y1)和H2=(X2,Y2)，则H2<H1⇔Y1<Y2，领先次序意味着H2是H1的父节点或称直接泛化。",H2<H1,等价,Y1<Y2
"给定H1=(X1,Y1)和H2=(X2,Y2)，则H2<H1⇔Y1<Y2，领先次序意味着H2是H1的父节点或称直接泛化。",H2,等价,H1的父节点或称直接泛化
根据偏序关系可生成格的Hasse图：如果H2<H1，且不存在另一个元素H3使得H2<H3<H1，则从H1到H2就存在一条边[66]。,偏序关系,属于,生成格的Hasse图
根据偏序关系可生成格的Hasse图：如果H2<H1，且不存在另一个元素H3使得H2<H3<H1，则从H1到H2就存在一条边[66]。,从H1到H2,实现,存在一条边
该方法并不直接处理本体映射，而是使用形式化概念分析技术，以一种自底向上的方式来合并两个共享相同实例集的本体。,自底向上的方式合并两个共享相同实例集的本体,属于,形式化概念分析技术
该方法并不直接处理本体映射，而是使用形式化概念分析技术，以一种自底向上的方式来合并两个共享相同实例集的本体。,该方法,实现,以一种自底向上的方式来合并两个共享相同实例集的本体
而共享实例是用来识别相似概念的基础，因此，提取共享实例是该方法实现的保证，同时提取出的实例质量也决定了最后结果的质量。,提取共享实例,属于,识别相似概念的基础
而共享实例是用来识别相似概念的基础，因此，提取共享实例是该方法实现的保证，同时提取出的实例质量也决定了最后结果的质量。,提取共享实例,实现,识别相似概念的保证
这一步采用自然语言处理技术，得到两本体的形式背景。,两本体的形式背景,属于,自然语言处理技术
这一步采用自然语言处理技术，得到两本体的形式背景。,两本体的形式背景,实现,得到
这一步采用自然语言处理技术，得到两本体的形式背景。,两本体的形式背景,中文名,形式背景
每个本体的形式背景表示为一张布尔表，表的行是实例，列是本体的概念，行列对应的位置表示实例是否属于概念；FCA-Merge将每个文本视为一个实例，如果某个文档是一个概念的实例，则它们在表中对应的值为真。,FCA-Merge,等价,将每个文本视为一个实例
"FCA-Merge采用经典的形式化概念分析理论提供的算法，这些算法能根据两张形式化背景的布尔表自动生成一个剪枝的概念格[65,67,68]。",FCA-Merge,属于,经典的形式化概念分析理论提供的算法
"FCA-Merge采用经典的形式化概念分析理论提供的算法，这些算法能根据两张形式化背景的布尔表自动生成一个剪枝的概念格[65,67,68]。",FCA-Merge,实现,根据两张形式化背景的布尔表自动生成一个剪枝的概念格
生成的概念格已经将独立的两个本体合并在一起。,概念格,属于,独立的两个本体合并在一起
生成的概念格已经将独立的两个本体合并在一起。,生成的概念格,实现,将独立的两个本体合并在一起
生成的概念格已经将独立的两个本体合并在一起。,概念格,中文名,概念格
本体工程师根据生成的概念格，借助领域知识，通过与机器交互创建目标合并本体。,本体工程师,属于,生成概念格
本体工程师根据生成的概念格，借助领域知识，通过与机器交互创建目标合并本体。,本体工程师,实现,创建目标合并本体
显然，合并的本体实际上蕴涵了两个初始本体概念间的映射关系。,合并的本体,属于,初始本体概念间的映射关系
显然，合并的本体实际上蕴涵了两个初始本体概念间的映射关系。,合并的本体,实现,两个初始本体概念间的映射关系
这种方法能发现异构本体概念间的等价和包含映射，这样的映射是1∶1的简单类型。,等价映射,属于,发现异构本体概念间的等价和包含映射
这种方法能发现异构本体概念间的等价和包含映射，这样的映射是1∶1的简单类型。,等价映射,实现,1∶1的简单类型
这种方法能发现异构本体概念间的等价和包含映射，这样的映射是1∶1的简单类型。,本体概念间的等价映射,等价,1∶1的简单类型
其次，映射结果质量受提取共享实例过程的影响。,映射结果质量,属于,提取共享实例过程的影响
其次，映射结果质量受提取共享实例过程的影响。,映射结果质量,实现,提取共享实例过程的影响
其次，映射结果质量受提取共享实例过程的影响。,映射结果质量,中文名,影响
最后，由概念格生成合并本体的工作由于人工参与，可能产生错误的映射结果。,概念格生成合并本体的工作,属于,由人工参与产生错误的映射结果
最后，由概念格生成合并本体的工作由于人工参与，可能产生错误的映射结果。,概念格生成合并本体的工作,实现,错误映射结果
该方法是一种自动的本体映射发现技术，基于信息流理论[71]。,本体映射发现技术,属于,自动的本体映射发现技术，基于信息流理论
该方法是一种自动的本体映射发现技术，基于信息流理论[71]。,本体映射发现技术,实现,基于信息流理论
该方法是一种自动的本体映射发现技术，基于信息流理论[71]。,本体映射发现技术,中文名,自动的本体映射发现技术，基于信息流理论
IF-Map的基本原理是寻找两个局部本体间的等价，其方法是通过查看它们与一个通用的参考本体的映射。,IF-Map,等价,寻找两个局部本体间的等价
那样的参考本体没有实例，而实例只在局部本体中才考虑。,本体,属于,没有实例的参考本体
那样的参考本体没有实例，而实例只在局部本体中才考虑。,局部本体,属于,考虑实例
那样的参考本体没有实例，而实例只在局部本体中才考虑。,本体,实现,那样的参考本体
因此，IF-Map方法的核心在于生成参考本体和局部本体之间的可能映射，然后根据这些映射判断两局部本体间的等价关系。,IF-Map,属于,生成参考本体和局部本体之间的可能映射
因此，IF-Map方法的核心在于生成参考本体和局部本体之间的可能映射，然后根据这些映射判断两局部本体间的等价关系。,IF-Map,实现,根据这些映射判断两局部本体间的等价关系
因此，IF-Map方法的核心在于生成参考本体和局部本体之间的可能映射，然后根据这些映射判断两局部本体间的等价关系。,IF-Map,中文名,生成参考本体和局部本体之间的可能映射
IF-Map也只能生成异构本体概念间的简单等价映射。,IF-Map,属于,异构本体概念间的简单等价映射
IF-Map也只能生成异构本体概念间的简单等价映射。,IF-Map,实现,生成异构本体概念间的简单等价映射
因此，为了得到更好的本体映射结果，可以考虑将多种映射方法综合使用，以吸收每种方法的优势。,本体映射,属于,多种映射方法
因此，为了得到更好的本体映射结果，可以考虑将多种映射方法综合使用，以吸收每种方法的优势。,本体映射,实现,吸收每种方法的优势
因此，为了得到更好的本体映射结果，可以考虑将多种映射方法综合使用，以吸收每种方法的优势。,本体映射,中文名,综合使用多种映射方法
QOM是采用综合方法发现本体映射的典型工作[72-75]。,QOM,属于,采用综合方法发现本体映射的典型工作
QOM是采用综合方法发现本体映射的典型工作[72-75]。,QOM,实现,采用综合方法发现本体映射的典型工作
QOM是采用综合方法发现本体映射的典型工作[72-75]。,QOM,中文名,采用综合方法发现本体映射的典型工作
该方法的最大特点在于寻找映射的过程中同时考虑了映射结果的质量与发现映射的时间复杂度，它力图寻找到二者间的平衡。,A-TREE,属于,寻找映射的过程中同时考虑了映射结果的质量与发现映射的时间复杂度
该方法的最大特点在于寻找映射的过程中同时考虑了映射结果的质量与发现映射的时间复杂度，它力图寻找到二者间的平衡。,A-TREE,实现,寻找映射的过程中同时考虑了映射结果的质量与发现映射的时间复杂度
该方法的最大特点在于寻找映射的过程中同时考虑了映射结果的质量与发现映射的时间复杂度，它力图寻找到二者间的平衡。,A-TREE,中文名,A-树
大多数本体映射发现算法过于强调映射结果的质量，而往往忽略发现映射的效率。,本体映射发现算法,属于,强调映射结果的质量而忽略发现映射的效率
大多数本体映射发现算法过于强调映射结果的质量，而往往忽略发现映射的效率。,本体映射发现算法,实现,过于强调映射结果的质量而往往忽略发现映射的效率
大多数本体映射发现算法过于强调映射结果的质量，而往往忽略发现映射的效率。,本体映射发现算法,中文名,本体映射发现算法
"目前，绝大多数方法的时间复杂度为O(n2),n是映射对象的数目。",时间复杂度,属于,O(n2)
"目前，绝大多数方法的时间复杂度为O(n2),n是映射对象的数目。",时间复杂度,实现,O(n2)
"目前，绝大多数方法的时间复杂度为O(n2),n是映射对象的数目。",时间复杂度,中文名,O(n2)
与这些方法不同，QOM给出的映射发现方法同时考虑映射质量和运行时间复杂度，在提高映射发现效率的同时保证一定质量的映射结果。,QOM给出的映射发现方法,属于,考虑映射质量和运行时间复杂度
与这些方法不同，QOM给出的映射发现方法同时考虑映射质量和运行时间复杂度，在提高映射发现效率的同时保证一定质量的映射结果。,QOM给出的映射发现方法,实现,同时考虑映射质量和运行时间复杂度
与这些方法不同，QOM给出的映射发现方法同时考虑映射质量和运行时间复杂度，在提高映射发现效率的同时保证一定质量的映射结果。,QOM给出的映射发现方法,中文名,同时考虑映射质量和运行时间复杂度
QOM只考虑异构本体间1∶1等价映射，映射对象包括概念、关系和实例。,QOM,等价,异构本体间1∶1等价映射
QOM处理本体映射的过程共分六步，输入异构本体，进行处理后得到本体间的映射。,QOM处理本体映射的过程,属于,六步
QOM处理本体映射的过程共分六步，输入异构本体，进行处理后得到本体间的映射。,QOM处理本体映射的过程,实现,输入异构本体进行处理后得到本体间的映射
QOM处理本体映射的过程共分六步，输入异构本体，进行处理后得到本体间的映射。,QOM处理本体映射的过程,中文名,六步处理本体映射
特征工程：将初始的输入本体转换为相似度计算中使用的统一格式，并分析映射对象的特征。,特征工程,属于,将初始的输入本体转换为相似度计算中使用的统一格式，并分析映射对象的特征
特征工程：将初始的输入本体转换为相似度计算中使用的统一格式，并分析映射对象的特征。,特征工程,实现,将初始的输入本体转换为相似度计算中使用的统一格式，并分析映射对象的特征
特征工程：将初始的输入本体转换为相似度计算中使用的统一格式，并分析映射对象的特征。,特征工程,中文名,将初始的输入本体转换为相似度计算中使用的统一格式，并分析映射对象的特征
QOM使用RDF三元组形式作为统一的本体形式，其中考虑的映射对象特征包括：标识，即表示映射对象的专用字符串，如URIs或RDF标签；RDF(S)原语，如属性或子类关系；推导出的特征，由RDF(S)原语推导出的特征，如最特化的类；OWLsameAs等表示等价的原语；领域中特定的特征，例如某领域中概原语，例如考虑念“Person”的实例都有“ID”属性，可用该属性值代替实例，方便处理。,映射对象的专用字符串,等价,标识
搜索步骤的选择：由于各种相似度计算方法的复杂度与待映射的对象对直接相关，为了避免比较两个本体的全部对象，保证发现映射的搜索空间在能接受的范围内，QOM使用启发式方法降低候选映射对象的数目，即它只选择那些必要的映射对象，而忽略其他不关心的映射对象。,搜索步骤,属于,启发式方法降低候选映射对象的数目
搜索步骤的选择：由于各种相似度计算方法的复杂度与待映射的对象对直接相关，为了避免比较两个本体的全部对象，保证发现映射的搜索空间在能接受的范围内，QOM使用启发式方法降低候选映射对象的数目，即它只选择那些必要的映射对象，而忽略其他不关心的映射对象。,QOM,实现,只选择那些必要的映射对象
搜索步骤的选择：由于各种相似度计算方法的复杂度与待映射的对象对直接相关，为了避免比较两个本体的全部对象，保证发现映射的搜索空间在能接受的范围内，QOM使用启发式方法降低候选映射对象的数目，即它只选择那些必要的映射对象，而忽略其他不关心的映射对象。,搜索步骤的选择,中文名,只选择那些必要的映射对象
相似度计算：对每一对候选映射对象，判断它们之间的相似度值。,相似度计算,属于,相似度计算相似度对象
相似度计算：对每一对候选映射对象，判断它们之间的相似度值。,相似度计算相似度对象,实现,对每一对候选映射对象判断它们之间的相似度值
相似度计算：对每一对候选映射对象，判断它们之间的相似度值。,相似度计算相似度对象,中文名,对每一对候选映射对象判断它们之间的相似度值
一个对象可被不同类型的信息描述，如URIs的标识和RDF(S)原语等。,一个对象,属于,信息描述
一个对象可被不同类型的信息描述，如URIs的标识和RDF(S)原语等。,一个对象,实现,URIs的标识
一个对象可被不同类型的信息描述，如URIs的标识和RDF(S)原语等。,一个对象,实现,RDF(S)原语
一个对象可被不同类型的信息描述，如URIs的标识和RDF(S)原语等。,一个对象,中文名,信息描述
为了提高发现映射的效率，在选择度量公式的时候忽略那些复杂度过高的度量公式。,选择度量公式,属于,忽略那些复杂度过高的度量公式
为了提高发现映射的效率，在选择度量公式的时候忽略那些复杂度过高的度量公式。,选择度量公式,实现,提高发现映射的效率
为了提高发现映射的效率，在选择度量公式的时候忽略那些复杂度过高的度量公式。,选择度量公式,中文名,忽略那些复杂度过高的度量公式
这些不同的相似度值需要累加，成为单个的相似度值。,相似度值,属于,累加
这些不同的相似度值需要累加，成为单个的相似度值。,不同的相似度值,实现,单个的相似度值
根据处理后的最终相似度值判断本体之间的映射。,本体之间的映射,属于,根据处理后的最终相似度值判断
根据处理后的最终相似度值判断本体之间的映射。,本体之间的映射,实现,根据处理后的最终相似度值判断本体之间的映射
根据处理后的最终相似度值判断本体之间的映射。,本体之间的映射,中文名,根据处理后的最终相似度值判断本体之间的映射
迭代：算法过程可迭代执行，每次迭代都能提高映射结果的质量，迭代可在没有新映射生成后停止。,迭代,属于,算法过程可迭代执行
迭代：算法过程可迭代执行，每次迭代都能提高映射结果的质量，迭代可在没有新映射生成后停止。,迭代,实现,每次迭代都能提高映射结果的质量
迭代：算法过程可迭代执行，每次迭代都能提高映射结果的质量，迭代可在没有新映射生成后停止。,迭代,中文名,算法过程可迭代执行
每次迭代时可基于贪婪策略从当前相似度最高的对象开始执行。,相似度,属于,相似度计算
每次迭代时可基于贪婪策略从当前相似度最高的对象开始执行。,相似度计算,实现,基于贪婪策略从当前相似度最高的对象开始执行
每次迭代时可基于贪婪策略从当前相似度最高的对象开始执行。,相似度计算,中文名,相似度计算
QOM分析了几种典型的本体映射方法的时间复杂度。,本体映射方法的复杂度,属于,几种典型的本体映射方法
QOM分析了几种典型的本体映射方法的时间复杂度。,QOM,实现,几中典型的本体映射方法的时间复杂度
QOM分析了几种典型的本体映射方法的时间复杂度。,本体映射方法的复杂度,中文名,几种典型的本体映射方法的时间复杂度
"iPROMPT的复杂度为O(n·log(n)),AnchorPROMPT的复杂度为O(n2·log2(n)),GLUE的复杂度为O(2n)。",iPROMPT,属于,复杂度的数学模型
"iPROMPT的复杂度为O(n·log(n)),AnchorPROMPT的复杂度为O(n2·log2(n)),GLUE的复杂度为O(2n)。",AnchorPROMPT,实现,复杂度的数学模型
"iPROMPT的复杂度为O(n·log(n)),AnchorPROMPT的复杂度为O(n2·log2(n)),GLUE的复杂度为O(2n)。",GLUE,实现,复杂度的数学模型
与这些方法相比，QOM忽略一些造成较高复杂度的方法，将映射发现的时间复杂度控制为O(n·og(n))。,QOM,属于,控制为O(n·og(n))的方法
与这些方法相比，QOM忽略一些造成较高复杂度的方法，将映射发现的时间复杂度控制为O(n·og(n))。,QOM,实现,将映射发现的时间复杂度控制为O(n·og(n))
与这些方法相比，QOM忽略一些造成较高复杂度的方法，将映射发现的时间复杂度控制为O(n·og(n))。,QOM,中文名,控制为O(n·og(n))的方法
注意，各种方法的时间复杂度并不是在同样的映射结果下给出的：iPROMPT的时间复杂度虽然低，但映射结果的质量不尽如人意；GLUE的时间复杂度虽然高，但映射结果质量却最好。,时间复杂度,属于,各种方法
注意，各种方法的时间复杂度并不是在同样的映射结果下给出的：iPROMPT的时间复杂度虽然低，但映射结果的质量不尽如人意；GLUE的时间复杂度虽然高，但映射结果质量却最好。,iPROMPT,实现,低时间复杂度给出的映射结果质量不尽如人意
注意，各种方法的时间复杂度并不是在同样的映射结果下给出的：iPROMPT的时间复杂度虽然低，但映射结果的质量不尽如人意；GLUE的时间复杂度虽然高，但映射结果质量却最好。,时间复杂度,中文名,各种方法的时间复杂度
试验结果表明，QOM能在保证一定映射结果质量的前提下，尽量提高发现映射的效率。,QOM,属于,保证一定映射结果质量的前提下，尽量提高发现映射的效率
试验结果表明，QOM能在保证一定映射结果质量的前提下，尽量提高发现映射的效率。,QOM,实现,保证一定映射结果质量的前提下，尽量提高发现映射的效率
试验结果表明，QOM能在保证一定映射结果质量的前提下，尽量提高发现映射的效率。,QOM,中文名,查询操作映射
"OLA也是一种本体映射发现综合方法[76,77]，具有如下特点：①覆盖本体所有可能的特征（如术语、结构和外延）;②考虑本体结构；③明确所有的循环关系，迭代寻找最佳映射。",OLA,属于,本体映射发现综合方法
"OLA也是一种本体映射发现综合方法[76,77]，具有如下特点：①覆盖本体所有可能的特征（如术语、结构和外延）;②考虑本体结构；③明确所有的循环关系，迭代寻找最佳映射。",OLA,实现,覆盖本体所有可能的特征（如术语、结构和外延）
"OLA也是一种本体映射发现综合方法[76,77]，具有如下特点：①覆盖本体所有可能的特征（如术语、结构和外延）;②考虑本体结构；③明确所有的循环关系，迭代寻找最佳映射。",OLA,中文名,本体映射发现综合方法
实体之间的相似度被赋予权重并线性累加。,相似度加权,属于,实体之间的相似度
实体之间的相似度被赋予权重并线性累加。,相似度加权,实现,权重并线性累加
OntoMap是一个知识表示的形式化、推理和Web接口。,OntoMap,属于,知识表示的形式化、推理和Web接口
OntoMap是一个知识表示的形式化、推理和Web接口。,OntoMap,实现,知识表示的形式化、推理和Web接口
为统一表示本体和它们之间的映射，OntoMap引入相对简单的元本体OntoMapO。,OntoMap,属于,元本体
为统一表示本体和它们之间的映射，OntoMap引入相对简单的元本体OntoMapO。,OntoMap,实现,统一表示本体和它们之间的映射
这个表示语言比RDF(S)复杂，与OWL_Lite相似，但它包括描述本体映射的特定原语。,OWL_2_EL,属于,描述本体映射的特定原语
这个表示语言比RDF(S)复杂，与OWL_Lite相似，但它包括描述本体映射的特定原语。,OWL_2_EL,实现,语言比RDF(S)复杂
这个表示语言比RDF(S)复杂，与OWL_Lite相似，但它包括描述本体映射的特定原语。,OWL_2_EL,中文名,OWL_2_E_L
这个表示语言比RDF(S)复杂，与OWL_Lite相似，但它包括描述本体映射的特定原语。,OWL_2_RL,等价,描述本体映射的特定原语
OntoMapO考虑的上层本体包括Cyc、WordNet和SENSUS等。,OntoMapO,属于,上层本体
OntoMapO考虑的上层本体包括Cyc、WordNet和SENSUS等。,OntoMapO,实现,考虑
映射语言中包括的映射原语有：①MuchMoreSpecific，表示两个概念的特化程度；②MuchMoreGeneral，与相反；③TopInstance，最特化的概念；④ParentAsInstance_MuchMoreSpecific_ChildAsClass。,映射原语,属于,映射语言
映射语言中包括的映射原语有：①MuchMoreSpecific，表示两个概念的特化程度；②MuchMoreGeneral，与相反；③TopInstance，最特化的概念；④ParentAsInstance_MuchMoreSpecific_ChildAsClass。,映射原语,实现,表示两个概念的特化程度
映射语言中包括的映射原语有：①MuchMoreSpecific，表示两个概念的特化程度；②MuchMoreGeneral，与相反；③TopInstance，最特化的概念；④ParentAsInstance_MuchMoreSpecific_ChildAsClass。,映射原语,中文名,映射原语
映射语言中包括的映射原语有：①MuchMoreSpecific，表示两个概念的特化程度；②MuchMoreGeneral，与相反；③TopInstance，最特化的概念；④ParentAsInstance_MuchMoreSpecific_ChildAsClass。,映射原语,等价,MuchMoreSpecific
映射语言中包括的映射原语有：①MuchMoreSpecific，表示两个概念的特化程度；②MuchMoreGeneral，与相反；③TopInstance，最特化的概念；④ParentAsInstance_MuchMoreSpecific_ChildAsClass。,映射原语,等价,MuchMoreGeneral
映射语言中包括的映射原语有：①MuchMoreSpecific，表示两个概念的特化程度；②MuchMoreGeneral，与相反；③TopInstance，最特化的概念；④ParentAsInstance_MuchMoreSpecific_ChildAsClass。,映射原语,等价,TopInstance
映射语言中包括的映射原语有：①MuchMoreSpecific，表示两个概念的特化程度；②MuchMoreGeneral，与相反；③TopInstance，最特化的概念；④ParentAsInstance_MuchMoreSpecific_ChildAsClass。,映射原语,等价,ParentAsInstance_MuchMoreSpecific_ChildAsClass
这些原语表明了OntoMapO支持的映射类型。,原语,属于,支持的映射类型
这些原语表明了OntoMapO支持的映射类型。,OntoMapO,实现,支持的映射类型
这些原语表明了OntoMapO支持的映射类型。,原语,中文名,支持的映射类型
但遗憾的是，OntoMap不能自动创建映射，它假设一个映射已存在或者能被手工创建。,OntoMap,属于,创建映射
但遗憾的是，OntoMap不能自动创建映射，它假设一个映射已存在或者能被手工创建。,OntoMap,实现,自动创建映射
因此，OntoMap更多只是提供了一个映射的表示框架。,OntoMap,属于,映射的表示框架
因此，OntoMap更多只是提供了一个映射的表示框架。,OntoMap,实现,一个概念/产品表示的映射
OBSERVER系统是为了解决分布式数据库的异构问题，它通过使用组件本体和它们之间明确的映射关系解决数据库间的异构[82]，同时它能维护这些映射。,OBSERVER系统,属于,解决分布式数据库的异构问题
OBSERVER系统是为了解决分布式数据库的异构问题，它通过使用组件本体和它们之间明确的映射关系解决数据库间的异构[82]，同时它能维护这些映射。,OBSERVER系统,实现,通过使用组件本体和它们之间明确的映射关系解决数据库间的异构
OBSERVER系统是为了解决分布式数据库的异构问题，它通过使用组件本体和它们之间明确的映射关系解决数据库间的异构[82]，同时它能维护这些映射。,OBSERVER系统,中文名,观察者系统
它使用多个预先定义的本体来表示异构数据库的模式。,OWL_S,属于,表示异构数据库的模式
它使用多个预先定义的本体来表示异构数据库的模式。,OWL_S,实现,使用多个预先定义的本体
映射建立在这些本体之间，通过一个内部管理器提供不同组件本体之间的互操作，以及维护这些映射。,映射,属于,不同组件本体之间的互操作以及维护这些映射
映射建立在这些本体之间，通过一个内部管理器提供不同组件本体之间的互操作，以及维护这些映射。,内部管理器,实现,提供不同组件本体之间的互操作，以及维护这些映射
映射建立在这些本体之间，通过一个内部管理器提供不同组件本体之间的互操作，以及维护这些映射。,映射,中文名,不同组件本体之间的互操作以及维护这些映射
本体的映射由一个特殊的被称为“资源主体”的类完成。,本体的映射,属于,“资源主体”的类
本体的映射由一个特殊的被称为“资源主体”的类完成。,本体的映射,实现,一个特殊的被称为“资源主体”的类完成
本体的映射由一个特殊的被称为“资源主体”的类完成。,本体的映射,中文名,本体的映射
一个资源主体封装了本体映射的规则集，这些规则能被其他主体使用，辅助完成主体之间的信息检索。,资源主体,属于,本体映射的规则集
一个资源主体封装了本体映射的规则集，这些规则能被其他主体使用，辅助完成主体之间的信息检索。,资源主体,实现,其他主体使用
本体元素使用的词汇可能是独立的单词（如Review），也可能是多个单词的组合形式（如Meta_Reviewer），还可能是某些特殊的缩写（如Stu_ID）。,本体元素,属于,本体概念
本体元素使用的词汇可能是独立的单词（如Review），也可能是多个单词的组合形式（如Meta_Reviewer），还可能是某些特殊的缩写（如Stu_ID）。,本体元素,实现,本体概念的语义检索
元素还可以通过自身注释中的简单语句，对其含义进行补充说明。,元素,属于,补充说明
元素还可以通过自身注释中的简单语句，对其含义进行补充说明。,元素,实现,对其含义进行补充说明
此外，各种语义描述（例如概念的上下位关系等）也可转化为文本形式。,语义描述,属于,语义描述转化为文本形式
此外，各种语义描述（例如概念的上下位关系等）也可转化为文本形式。,语义描述,实现,概念的上下位关系等转化为文本形式
因此，可以将本体中元素相关的文本组织为虚拟文档，然后用虚拟文档表示相应的元素。,本体中元素,属于,虚拟文档表示相应的元素
因此，可以将本体中元素相关的文本组织为虚拟文档，然后用虚拟文档表示相应的元素。,本体中元素相关的文本,实现,虚拟文档表示相应的元素
"①元素自身的描述文本Des（e）：包括localname、rdfs:lable、rdfs:comment，以及其他的注释文本，这些不同类型的文本可赋予[0,1]区间的权重。",描述文本,中文名,Des（e）
"①元素自身的描述文本Des（e）：包括localname、rdfs:lable、rdfs:comment，以及其他的注释文本，这些不同类型的文本可赋予[0,1]区间的权重。",元素的描述文本Des（e）,等价,localname、rdfs:lable、rdfs:comment以及其他的注释文本
②空节点的描述文档Des（e）：对于空节点类型的元素，虽然它没有描述自身的文本，但仍然可以根据和它相关的三元组中的其他非空节点进行描述，在这个描述过程中，如果存在其他的空节点，则这种描述迭代进行多次，直至收敛。,空节点的描述文档Des（e）,等价,对于空节点类型的元素，虽然它没有描述自身的文本，但仍然可以根据和它相关的三元组中的其他非空节点进行描述，在这个描述过程中，如果存在其他的空节点，则这种描述迭代进行多次，直至收敛。
在此过程中，越远的元素会被赋予越小的描述权重。,描述权重,属于,越远的元素
在此过程中，越远的元素会被赋予越小的描述权重。,描述权重,实现,越远的元素会被赋予越小的描述权重
③元素邻居的描述文本：根据三元组得到元素的邻居，并分别得到元素作为主语、谓语、宾语时的邻居文本。,元素的邻居,属于,得到元素的邻居
③元素邻居的描述文本：根据三元组得到元素的邻居，并分别得到元素作为主语、谓语、宾语时的邻居文本。,根据三元组得到元素的邻居,实现,分别得到元素作为主语、谓语、宾语时的邻居文本
③元素邻居的描述文本：根据三元组得到元素的邻居，并分别得到元素作为主语、谓语、宾语时的邻居文本。,元素的邻居的描述文本,中文名,根据三元组得到元素的邻居，并分别得到元素作为主语、谓语、宾语时的邻居文本。
注意，如果这些邻居存在空节点，则采用空节点的描述方式进行描述。,SPO,属于,三元组抽取
注意，如果这些邻居存在空节点，则采用空节点的描述方式进行描述。,SPO,实现,注意，如果这些邻居存在空节点，则采用空节点的描述方式进行描述。
注意，如果这些邻居存在空节点，则采用空节点的描述方式进行描述。,SPO,中文名,三元组抽取
两元素的语义描述文档相似度越高，它们相匹配的可能性越大。,语义描述文档相似度,属于,两元素的语义描述文档相似度
两元素的语义描述文档相似度越高，它们相匹配的可能性越大。,语义描述文档相似度,实现,相匹配的可能性
考虑将多种映射方法综合使用，吸收每种方法的优点，能得到更好的本体映射结果。,本体映射,属于,多种映射方法
考虑将多种映射方法综合使用，吸收每种方法的优点，能得到更好的本体映射结果。,本体映射,实现,吸收每种方法的优点
考虑将多种映射方法综合使用，吸收每种方法的优点，能得到更好的本体映射结果。,本体映射,中文名,综合使用多种映射方法
但综合使用多种方法要注意这些方法之间是否能改善映射质量，还要在映射的效率上进行权衡，因为可能引入一些方法会大大降低原有算法的效率。,多种方法,属于,改善映射质量
但综合使用多种方法要注意这些方法之间是否能改善映射质量，还要在映射的效率上进行权衡，因为可能引入一些方法会大大降低原有算法的效率。,多种方法,属于,权衡
但综合使用多种方法要注意这些方法之间是否能改善映射质量，还要在映射的效率上进行权衡，因为可能引入一些方法会大大降低原有算法的效率。,引入一些方法,属于,降低原有算法的效率
此外，将各种映射方法的结果进行综合也很重要。,综合,属于,各种映射方法的结果
此外，将各种映射方法的结果进行综合也很重要。,综合,实现,将各种映射方法的结果进行综合也很重要。
此外，将各种映射方法的结果进行综合也很重要。,综合,中文名,将各种映射方法的结果进行综合也很重要。
要在多本体环境中实现知识重用和协调多本体，还需要对多本体进行有效的管理。,多本体环境,属于,对多本体进行有效的管理
要在多本体环境中实现知识重用和协调多本体，还需要对多本体进行有效的管理。,多本体环境,实现,知识重用和协调多本体
管理多个本体的好处在于：①方便处理多个本体的维护和演化问题；②合理组织本体间的映射，方便查询、数据转移和推理等应用；③将多个本体作为一个整体来使用，能为实际应用提供更强大的功能。,管理多个本体的好处,属于,便于处理多个本体的维护和演化问题
管理多个本体的好处在于：①方便处理多个本体的维护和演化问题；②合理组织本体间的映射，方便查询、数据转移和推理等应用；③将多个本体作为一个整体来使用，能为实际应用提供更强大的功能。,管理多个本体的好处,实现,合理组织本体间的映射，方便查询、数据转移和推理等应用
管理多个本体的好处在于：①方便处理多个本体的维护和演化问题；②合理组织本体间的映射，方便查询、数据转移和推理等应用；③将多个本体作为一个整体来使用，能为实际应用提供更强大的功能。,管理多个本体的好处,中文名,方便处理多个本体的维护和演化问题
这里讨论如何通过组织映射来达到管理异构的多本体的目的。,组织映射,属于,通过组织映射来达到管理异构的多本体的目的
这里讨论如何通过组织映射来达到管理异构的多本体的目的。,组织映射,实现,通过组织映射来达到管理异构的多本体的目的
这里讨论如何通过组织映射来达到管理异构的多本体的目的。,组织映射,中文名,通过组织映射来达到管理异构的多本体的目的
实际上，在数据库等领域中就有针对模式或模型管理的研究。,模式或模型管理,属于,针对模式或模型管理的研究
实际上，在数据库等领域中就有针对模式或模型管理的研究。,数据库,实现,针对模式或模型管理的研究
实际上，在数据库等领域中就有针对模式或模型管理的研究。,模式或模型管理,中文名,针对模式或模型管理的研究
他们指出，模型间的映射和操作是模型管理的核心问题。,模型间的映射和操作,属于,模型管理
他们指出，模型间的映射和操作是模型管理的核心问题。,模型间的映射和操作,实现,模型管理的核心问题
"在本体研究领域，一些工作分析了本体管理的挑战[87,88]。",本体研究领域的工作,属于,分析本体管理的挑战
"在本体研究领域，一些工作分析了本体管理的挑战[87,88]。",本体研究领域的工作,实现,分析本体管理的挑战
"在本体研究领域，一些工作分析了本体管理的挑战[87,88]。",本体研究领域的工作,中文名,分析本体管理的挑战
显然，这些工作都关注本体的表示、存储和维护。,本体的表示,属于,关注本体的表示、存储和维护
显然，这些工作都关注本体的表示、存储和维护。,本体的表示,实现,关注本体的表示、存储和维护
而且这些方法只处理单个本体，没有考虑多个本体之间的映射或演化问题。,本体映射或演化问题,属于,只处理单个本体
而且这些方法只处理单个本体，没有考虑多个本体之间的映射或演化问题。,本体映射或演化问题,实现,多个本体之间的映射或演化问题
从这些本体管理工作可以看出，目前多数本体管理工作关注本体演化或本体版本变化问题。,本体管理工作,属于,关注本体演化或本体版本变化问题
从这些本体管理工作可以看出，目前多数本体管理工作关注本体演化或本体版本变化问题。,本体管理工作,实现,关注本体演化或本体版本变化问题
从这些本体管理工作可以看出，目前多数本体管理工作关注本体演化或本体版本变化问题。,本体管理工作,中文名,本体管理工作
传统的本体管理通常是二层结构：本体存储层和应用层。,本体存储层,属于,传统的本体管理
传统的本体管理通常是二层结构：本体存储层和应用层。,本体存储层,实现,应用层
这样的管理方式具有灵活的特点，适应动态Web环境。,SPO,属于,管理方式
这样的管理方式具有灵活的特点，适应动态Web环境。,SPO,实现,灵活的特点
然后将多本体可提供的功能与应用分离，提供面向应用的通用功能，避免使用多本体时的大量重复工作。,多本体,属于,面向应用的通用功能
然后将多本体可提供的功能与应用分离，提供面向应用的通用功能，避免使用多本体时的大量重复工作。,多本体,实现,避免使用多本体时的大量重复工作
不同本体语言的语法、逻辑模型和表达能力都必然存在差异，因此需要将这些本体转换到统一的表示形式上来。,本体语言的语法,属于,差异
不同本体语言的语法、逻辑模型和表达能力都必然存在差异，因此需要将这些本体转换到统一的表示形式上来。,将本体转换到统一的表示形式上来,实现,将这些本体转换到统一的表示形式
不同本体语言的语法、逻辑模型和表达能力都必然存在差异，因此需要将这些本体转换到统一的表示形式上来。,本体语言的语法,中文名,本体语言的语法特点
不同本体语言的语法、逻辑模型和表达能力都必然存在差异，因此需要将这些本体转换到统一的表示形式上来。,将这些本体转换到统一的表示形式上来,中文名,将不同本体语言的语法转换到统一的表示形式
通常少许的非关键本体信息在转换中丢失是可容忍的。,非关键本体信息,属于,转换中丢失
通常少许的非关键本体信息在转换中丢失是可容忍的。,非关键本体信息在转换中丢失,实现,可容忍的
多本体间常常重叠，其间往往有关联。,多本体,属于,多本体间常常重叠，其间往往有关联。
多本体间常常重叠，其间往往有关联。,多本体间常常重叠,实现,关联
多本体间常常重叠，其间往往有关联。,多本体间常常重叠,中文名,多本体间重叠
为有效使用多本体而避免本体集成，采用生成的桥本体来描述多本体间的沟通。,生成的桥本体,属于,多本体间的沟通
为有效使用多本体而避免本体集成，采用生成的桥本体来描述多本体间的沟通。,生成的桥本体,实现,为有效使用多本体而避免本体集成
为有效使用多本体而避免本体集成，采用生成的桥本体来描述多本体间的沟通。,生成的桥本体,中文名,多本体间的沟通
桥本体是一特殊的本体，可表示本体间概念和关系的12种不同映射。,桥本体,属于,特殊的本体
桥本体是一特殊的本体，可表示本体间概念和关系的12种不同映射。,桥本体,实现,表示本体间概念和关系的12种不同映射
桥本体是一特殊的本体，可表示本体间概念和关系的12种不同映射。,桥本体,中文名,特殊的本体
桥的生成是半自动化的，并在桥本体中组织管理。,桥的生成,属于,半自动化的
桥的生成是半自动化的，并在桥本体中组织管理。,桥的生成,实现,组织管理
本体间映射生成过程无法避免语义冗余和冲突，有必要在使用前进行有效的化简。,本体间映射生成过程,属于,在使用前进行有效的化简
本体间映射生成过程无法避免语义冗余和冲突，有必要在使用前进行有效的化简。,本体间映射生成过程无法避免语义冗余和冲突,实现,在使用前进行有效的化简
对于语义一致性问题，将引入桥后的多本体中的回路分为两种类型：良性回路和恶性回路。,良性回路,属于,多本体中的回路
对于语义一致性问题，将引入桥后的多本体中的回路分为两种类型：良性回路和恶性回路。,将引入桥后的多本体中的回路分为两种类型,实现,语义一致性问题
对于语义一致性问题，将引入桥后的多本体中的回路分为两种类型：良性回路和恶性回路。,良性回路,中文名,多本体中的回路
前者是由于引入等价桥后造成的，通过算法可消除。,等价类,属于,划分概念
前者是由于引入等价桥后造成的，通过算法可消除。,等价类,实现,消除前者的原因
后者是由于原始本体中的错误或引入不当的桥造成的。,后者,属于,原始本体中的错误或引入不当的桥
后者是由于原始本体中的错误或引入不当的桥造成的。,后者,实现,由于原始本体中的错误或引入不当的桥造成的
算法能够找到环路，但区分恶性和良性环路需要人工参与。,算法,属于,找到环路
算法能够找到环路，但区分恶性和良性环路需要人工参与。,算法,实现,区分恶性和良性环路
经过语义检查的多本体环境可当作有向无环图来处理，语义化简的目的就是要保证该图中的映射是无冗余的，同时化简操作不能改变整个多本体环境的连通性。,语义化简,属于,多本体环境的处理
经过语义检查的多本体环境可当作有向无环图来处理，语义化简的目的就是要保证该图中的映射是无冗余的，同时化简操作不能改变整个多本体环境的连通性。,语义化简,实现,保证该图中的映射是无冗余的
经过语义检查的多本体环境可当作有向无环图来处理，语义化简的目的就是要保证该图中的映射是无冗余的，同时化简操作不能改变整个多本体环境的连通性。,语义化简,中文名,保证该图中的映射是无冗余的
经过语义检查的多本体环境可当作有向无环图来处理，语义化简的目的就是要保证该图中的映射是无冗余的，同时化简操作不能改变整个多本体环境的连通性。,语义化简,中文名,保证整个多本体环境的连通性
本体间映射抽取出来，可通过桥本体进行管理。,本体间映射,属于,桥本体进行管理
本体间映射抽取出来，可通过桥本体进行管理。,本体间映射,实现,可通过桥本体进行管理
当多本体环境中添加、删除或修改本体时，为减少重新生成映射的代价，需要设计高效的增量更新算法保证映射同步更新。,增量更新算法,属于,高效更新映射
当多本体环境中添加、删除或修改本体时，为减少重新生成映射的代价，需要设计高效的增量更新算法保证映射同步更新。,增量更新算法,实现,减少重新生成映射的代价
当多本体环境中添加、删除或修改本体时，为减少重新生成映射的代价，需要设计高效的增量更新算法保证映射同步更新。,增量更新算法,中文名,高效更新映射
多本体的管理能提供满足应用需求的一些主要功能。,多本体的管理,属于,能提供满足应用需求的一些主要功能
多本体的管理能提供满足应用需求的一些主要功能。,多本体的管理,实现,提供满足应用需求的一些主要功能
通过这些映射，很容易实现异构本体间的互操作问题。,映射,属于,异构本体间的互操作问题
通过这些映射，很容易实现异构本体间的互操作问题。,映射,实现,很容易实现异构本体间的互操作问题
第二，利用多本体间的桥，能实现跨不同本体的推理。,多本体间的桥,属于,跨不同本体的推理
第二，利用多本体间的桥，能实现跨不同本体的推理。,多本体间的桥,实现,跨不同本体的推理
第二，利用多本体间的桥，能实现跨不同本体的推理。,多本体间的桥,中文名,跨不同本体的推理
第四，还可以从多本体中抽取满足需求的子本体。,抽取三元组,属于,多本体中抽取满足需求的子本体
第四，还可以从多本体中抽取满足需求的子本体。,第四,实现,从多本体中抽取满足需求的子本体
第四，还可以从多本体中抽取满足需求的子本体。,抽取三元组,中文名,从多本体中抽取满足需求的子本体
大本体难以驾驭，而且在实际应用中往往只需其中与应用需求相关的一小部分。,大本体,属于,难以驾驭
大本体难以驾驭，而且在实际应用中往往只需其中与应用需求相关的一小部分。,大本体,属于,实际应用中往往只需其中与应用需求相关的一小部分
大本体难以驾驭，而且在实际应用中往往只需其中与应用需求相关的一小部分。,大本体,实现,一小部分
因此，从源本体中抽取一个小的子本体能让系统更有效。,抽取子本体,属于,源本体中抽取一个小的子本体
因此，从源本体中抽取一个小的子本体能让系统更有效。,抽取子本体,实现,让系统更有效
Noy_N_F等提出的PROMPTFactor本体抽取工具也支持从单个本体中获得语义独立的子本体[25]，其主要思想是通过用户选择所需要的相关术语，并与PROMPT系统进行交互抽取子本体。,Noy_N_F等提出的PROMPTFactor本体抽取工具,等价,从单个本体中获得语义独立的子本体
但多本体环境下的应用很多，多个本体的不同部分都可能是子本体需要的。,本体,属于,多本体环境下的应用
但多本体环境下的应用很多，多个本体的不同部分都可能是子本体需要的。,子本体,实现,多本体环境下的应用很多
本体映射表示了多本体间的联系，对解决从多本体中抽取子本体具有重要的作用。,本体映射,属于,多本体间的联系
本体映射表示了多本体间的联系，对解决从多本体中抽取子本体具有重要的作用。,本体映射,实现,从多本体中抽取子本体
与此同时，很多领域中的研究人员为了整合、归纳和分享领域内的专业知识，也建立了很多领域本体。,本体,属于,整合、归纳和分享领域内的专业知识
与此同时，很多领域中的研究人员为了整合、归纳和分享领域内的专业知识，也建立了很多领域本体。,本体,实现,整合、归纳和分享领域内的专业知识
与此同时，很多领域中的研究人员为了整合、归纳和分享领域内的专业知识，也建立了很多领域本体。,本体,中文名,领域本体
这些本体的规模正随着人类知识的增长而变得越来越大。,本体的规模,属于,随着人类知识的增长而变得越来越大
这些本体的规模正随着人类知识的增长而变得越来越大。,本体的规模,实现,变得越来越大
然而，多数映射系统不仅无法在用户可接受的时间内给出满意的映射结果，而且还往往会由于匹配过程申请过大的内存空间而导致系统崩溃。,映射系统,属于,无法在用户可接受的时间内给出满意的映射结果
然而，多数映射系统不仅无法在用户可接受的时间内给出满意的映射结果，而且还往往会由于匹配过程申请过大的内存空间而导致系统崩溃。,映射系统,属于,往往会由于匹配过程申请过大的内存空间而导致系统崩溃
然而，多数映射系统不仅无法在用户可接受的时间内给出满意的映射结果，而且还往往会由于匹配过程申请过大的内存空间而导致系统崩溃。,映射系统,中文名,映射系统
大规模本体在机器翻译、信息检索和集成、决策支持、知识发现等领域中都有着重要的应用。,大规模本体,属于,机器翻译、信息检索和集成、决策支持、知识发现等领域中都有着重要的应用
大规模本体在机器翻译、信息检索和集成、决策支持、知识发现等领域中都有着重要的应用。,大规模本体,实现,机器翻译、信息检索和集成、决策支持、知识发现等领域中都有着重要的应用
大规模本体在机器翻译、信息检索和集成、决策支持、知识发现等领域中都有着重要的应用。,大规模本体,中文名,本体
表5-4是对12个大规模知识图谱的调查结果，其中列举了各知识图谱中概念、关系、实例和公理的数目，表中横线表示没有获得对应数据；另外，由于一些本体创建时间较早，它们并没有按近年提出的本体模型来组织知识，因此只提供了所包含的术语数目。,本体,中文名,概念、关系、实例和公理的数目
表5-4是对12个大规模知识图谱的调查结果，其中列举了各知识图谱中概念、关系、实例和公理的数目，表中横线表示没有获得对应数据；另外，由于一些本体创建时间较早，它们并没有按近年提出的本体模型来组织知识，因此只提供了所包含的术语数目。,本体,中文名,所包含的术语数目
从调查结果可见，大规模知识图谱中的元素数庞大，尤其是实例数据较多。,大规模知识图谱,属于,元素
从调查结果可见，大规模知识图谱中的元素数庞大，尤其是实例数据较多。,大规模知识图谱,实现,实例数据
总之，大规模知识图谱间的异构现象依然普遍存在。,大规模知识图谱间的异构现象,属于,普遍存在
总之，大规模知识图谱间的异构现象依然普遍存在。,大规模知识图谱间的异构现象,实现,概念/产品
总之，大规模知识图谱间的异构现象依然普遍存在。,大规模知识图谱间的异构现象,中文名,普遍存在
"传统的模式匹配工作虽然提出处理大规模模式匹配的分治法[102,103]，但数据库模式和XML模式都是树状结构，位于不同树枝的信息相对独立，适于采用分治思想处理。",分治法,属于,处理大规模模式匹配
"传统的模式匹配工作虽然提出处理大规模模式匹配的分治法[102,103]，但数据库模式和XML模式都是树状结构，位于不同树枝的信息相对独立，适于采用分治思想处理。",传统的模式匹配工作,实现,处理大规模模式匹配的分治法
"传统的模式匹配工作虽然提出处理大规模模式匹配的分治法[102,103]，但数据库模式和XML模式都是树状结构，位于不同树枝的信息相对独立，适于采用分治思想处理。",分治法,中文名,处理大规模模式匹配的分治思想
由此可见，大多数公开的系统仍然不能处理大规模知识图谱匹配问题。,公开的系统,属于,不能处理大规模知识图谱匹配问题
由此可见，大多数公开的系统仍然不能处理大规模知识图谱匹配问题。,公开的系统,实现,处理大规模知识图谱匹配问题
当系统申请的存储空间不能一次读入内存时，将造成操作系统不断在内存储器和虚拟存储器之间中进行数据交换；当操作系统无法满足映射系统的空间申请要求时，将导致内存不足的严重错误。,操作系统内存不足的错误,属于,操作系统无法满足映射系统的空间申请要求时，将导致内存不足的严重错误
当系统申请的存储空间不能一次读入内存时，将造成操作系统不断在内存储器和虚拟存储器之间中进行数据交换；当操作系统无法满足映射系统的空间申请要求时，将导致内存不足的严重错误。,操作系统内存不足的错误,实现,将造成操作系统不断在内存储器和虚拟存储器之间中进行数据交换
当系统申请的存储空间不能一次读入内存时，将造成操作系统不断在内存储器和虚拟存储器之间中进行数据交换；当操作系统无法满足映射系统的空间申请要求时，将导致内存不足的严重错误。,操作系统内存不足的错误,中文名,操作系统无法满足映射系统的空间申请要求时，将导致内存不足的严重错误
很多匹配系统都采用二维数组来记录元素间的相似度矩阵，即使对于一个实例规模为5000的小型知识图谱，相似矩阵中的数值为双精度类型，则存储该矩阵所需的空间大约为200MB。,相似矩阵,属于,存储该矩阵所需的空间
很多匹配系统都采用二维数组来记录元素间的相似度矩阵，即使对于一个实例规模为5000的小型知识图谱，相似矩阵中的数值为双精度类型，则存储该矩阵所需的空间大约为200MB。,相似矩阵,实现,记录元素间的相似度矩阵
很多匹配系统都采用二维数组来记录元素间的相似度矩阵，即使对于一个实例规模为5000的小型知识图谱，相似矩阵中的数值为双精度类型，则存储该矩阵所需的空间大约为200MB。,相似矩阵,中文名,存储该矩阵所需的空间大约为200MB
因此，虽然空间复杂度是大规模知识图谱匹配中的一个难题，但并不是不可能克服的问题。,空间复杂度,属于,大规模知识图谱匹配
因此，虽然空间复杂度是大规模知识图谱匹配中的一个难题，但并不是不可能克服的问题。,空间复杂度,实现,克服问题
令计算两元素相似度过程的时间复杂度为t，则匹配系统的总时间复杂度可表示为O(n2t)。,匹配系统的总时间复杂度,属于,O(n2t)
令计算两元素相似度过程的时间复杂度为t，则匹配系统的总时间复杂度可表示为O(n2t)。,匹配系统的总时间复杂度,实现,计算两元素相似度过程的时间复杂度为t
令计算两元素相似度过程的时间复杂度为t，则匹配系统的总时间复杂度可表示为O(n2t)。,匹配系统的总时间复杂度,中文名,O(n2t)
因此，降低大规模知识图谱匹配问题的时间复杂度除了要考虑减少匹配元素对的相似度计算次数（即n2），还需要降低每次相似度计算的时间复杂度（即t）。,降低大规模知识图谱匹配问题的时间复杂度,属于,减少匹配元素对的相似度计算次数
因此，降低大规模知识图谱匹配问题的时间复杂度除了要考虑减少匹配元素对的相似度计算次数（即n2），还需要降低每次相似度计算的时间复杂度（即t）。,降低大规模知识图谱匹配问题的时间复杂度,实现,减少每次相似度计算的时间复杂度
此外，很多有效的匹配算法需要对知识图谱进行全局分析和整理，例如采用相似度传播的结构匹配方法等。,有效的匹配算法,属于,对知识图谱进行全局分析和整理
此外，很多有效的匹配算法需要对知识图谱进行全局分析和整理，例如采用相似度传播的结构匹配方法等。,有效的匹配算法,实现,结构匹配方法
然而，这种处理对大规模知识图谱来说并不可行，尽管可以采用简化或近似处理来替代，但由此得到的映射结果可能有损失。,映射,属于,处理大规模知识图谱
然而，这种处理对大规模知识图谱来说并不可行，尽管可以采用简化或近似处理来替代，但由此得到的映射结果可能有损失。,映射,实现,简化或近似处理来替代
然而，这种处理对大规模知识图谱来说并不可行，尽管可以采用简化或近似处理来替代，但由此得到的映射结果可能有损失。,映射,中文名,替代得到的映射结果可能有损失
最后，一些算法采用分治的策略，将大规模知识图谱匹配问题转换为多个小规模匹配问题，但分治的过程会将原本相邻元素分割开，破坏某些实例语义信息的完整性，因此这部分位于边界位置的实例的匹配质量无法得到保证。,分治策略,属于,将大规模知识图谱匹配问题转换为多个小规模匹配问题
最后，一些算法采用分治的策略，将大规模知识图谱匹配问题转换为多个小规模匹配问题，但分治的过程会将原本相邻元素分割开，破坏某些实例语义信息的完整性，因此这部分位于边界位置的实例的匹配质量无法得到保证。,分治的过程,实现,将原本相邻元素分割开
最后，一些算法采用分治的策略，将大规模知识图谱匹配问题转换为多个小规模匹配问题，但分治的过程会将原本相邻元素分割开，破坏某些实例语义信息的完整性，因此这部分位于边界位置的实例的匹配质量无法得到保证。,分治的过程,中文名,将原本相邻元素分割开
基于快速相似度计算的方法使用的匹配器主要包括文本匹配器、结构匹配器和基于实例的匹配器等。,基于快速相似度计算的方法,属于,匹配器
基于快速相似度计算的方法使用的匹配器主要包括文本匹配器、结构匹配器和基于实例的匹配器等。,基于快速相似度计算的方法使用的匹配器,实现,文本匹配器
基于快速相似度计算的方法使用的匹配器主要包括文本匹配器、结构匹配器和基于实例的匹配器等。,基于快速相似度计算的方法使用的匹配器,中文名,基于快速相似度计算的方法使用的匹配器
很多基于文本相似的匹配算法时间复杂度都较低，但为达到快速计算元素相似度的目的，文本匹配器还应避免构造复杂的映射线索，例如映射线索只考虑元素标签和注释信息。,基于文本相似的匹配算法,属于,时间复杂度较低的文本匹配算法
很多基于文本相似的匹配算法时间复杂度都较低，但为达到快速计算元素相似度的目的，文本匹配器还应避免构造复杂的映射线索，例如映射线索只考虑元素标签和注释信息。,文本匹配器,实现,避免构造复杂的映射线索
很多基于文本相似的匹配算法时间复杂度都较低，但为达到快速计算元素相似度的目的，文本匹配器还应避免构造复杂的映射线索，例如映射线索只考虑元素标签和注释信息。,基于文本相似的匹配算法,中文名,时间复杂度较低的文本匹配算法
其次，系统效率受相似度计算方法影响较大，即t的少量变化会给系统的效率带来较大影响。,系统效率,属于,相似度计算方法影响较大，即t的少量变化会给系统的效率带来较大影响
其次，系统效率受相似度计算方法影响较大，即t的少量变化会给系统的效率带来较大影响。,系统效率,实现,受相似度计算方法影响较大，即t的少量变化会给系统的效率带来较大影响
其次，系统效率受相似度计算方法影响较大，即t的少量变化会给系统的效率带来较大影响。,系统效率,中文名,相似度计算方法影响较大，即t的少量变化会给系统的效率带来较大影响
Ichise等人实现了Web_Directory的匹配[109]，匹配方法依靠统计共享实例。,Ichise等人,属于,实现Web_Directory的匹配
Ichise等人实现了Web_Directory的匹配[109]，匹配方法依靠统计共享实例。,Ichise等人,实现,统计共享实例
该框架以迭代的方式来自动发现匹配规则，并逐步提高匹配规则集的质量，再利用更新后的规则集来寻找高质量的匹配对。,SPO,属于,自动发现匹配规则，并逐步提高匹配规则集的质量
该框架以迭代的方式来自动发现匹配规则，并逐步提高匹配规则集的质量，再利用更新后的规则集来寻找高质量的匹配对。,SPO,实现,来自动发现匹配规则，并逐步提高匹配规则集的质量
该框架以迭代的方式来自动发现匹配规则，并逐步提高匹配规则集的质量，再利用更新后的规则集来寻找高质量的匹配对。,SPO,中文名,自动发现匹配规则，并逐步提高匹配规则集的质量
具体地，数据集中少量具有owl:sameAs属性的现存匹配对被视为种子（Seeds），匹配规则被视为似然函数中需要被估计的参数。,匹配规则,等价,似然函数中需要被估计的参数
该方法利用一种基于图的指标来度量匹配的精确度，并作为EM算法的目标似然函数。,基于图的指标度量匹配精确度,属于,EM算法的目标似然函数
该方法利用一种基于图的指标来度量匹配的精确度，并作为EM算法的目标似然函数。,基于图的指标度量匹配精确度,实现,度量匹配的精确度
该方法利用一种基于图的指标来度量匹配的精确度，并作为EM算法的目标似然函数。,基于图的指标度量匹配精确度,中文名,基于图的指标度量匹配精确度
在不同的匹配规则下，同一个匹配对的匹配置信度是不一样的，如何集成不同规则的置信度是一个很重要的问题。,匹配规则,属于,集成不同规则的置信度
在不同的匹配规则下，同一个匹配对的匹配置信度是不一样的，如何集成不同规则的置信度是一个很重要的问题。,匹配规则下的同一个匹配对的匹配置信度,实现,集成不同规则的置信度
在不同的匹配规则下，同一个匹配对的匹配置信度是不一样的，如何集成不同规则的置信度是一个很重要的问题。,匹配规则,中文名,匹配规则下的同一个匹配对的匹配置信度
该方法引入Dempster's_rule[1]来集成同一个匹配对的不同置信度。,融合相似度的概念,属于,同一个匹配对的不同置信度
该方法引入Dempster's_rule[1]来集成同一个匹配对的不同置信度。,融合相似度的概念,实现,引入Dempster's_rule
该方法引入Dempster's_rule[1]来集成同一个匹配对的不同置信度。,融合相似度的概念,中文名,引入Dempster's_rule
该方法引入Dempster's_rule[1]来集成同一个匹配对的不同置信度。,Dempster's_rule,等价,集成同一个匹配对的不同置信度
"URI不同的两个实例e1,e2是等价的，当且仅当＜e1,e2＞∈～I。",e1,等价,e2
然后，种子匹配对被导入系统中，用来驱动发现新的匹配，高质量的新匹配对会加入种子匹配对中以进行下一轮迭代。,种子匹配对,属于,驱动发现新的匹配
然后，种子匹配对被导入系统中，用来驱动发现新的匹配，高质量的新匹配对会加入种子匹配对中以进行下一轮迭代。,种子匹配对,实现,高质量的新匹配对加入种子匹配对中以进行下一轮迭代
前面提到，该框架通过学习规则来推导实例之间的等价关系。,OWL_2_CRS,属于,学习推导实例等价关系
前面提到，该框架通过学习规则来推导实例之间的等价关系。,OWL_2_CRS,实现,通过学习规则来推导实例之间的等价关系
前面提到，该框架通过学习规则来推导实例之间的等价关系。,OWL_2_CRS,中文名,OWL_2_CRS
一些属性等价的例子如下所示：rdfs:label≈gs:hasCommonNamefoaf:name≈gs:hsCanonicalNamedbpedia:phylum≈gs:inPhylum在dbpedia.org中定义的属性dbpedia:phylum和geospecies.org中定义的属性gs:inPhylum有相同的内在含义：它们对应的值在生物分类中都属于同一个等级。,dbpedia.org中定义的属性dbpedia:phylum,属于,gs:inPhylum
一些属性等价的例子如下所示：rdfs:label≈gs:hasCommonNamefoaf:name≈gs:hsCanonicalNamedbpedia:phylum≈gs:inPhylum在dbpedia.org中定义的属性dbpedia:phylum和geospecies.org中定义的属性gs:inPhylum有相同的内在含义：它们对应的值在生物分类中都属于同一个等级。,属性等价的例子,实现,rdfs:label≈gs:hasCommonNamefoaf:name≈gs:hsCanonicalNamedbpedia:phylum≈gs:inPhylum
一些属性等价的例子如下所示：rdfs:label≈gs:hasCommonNamefoaf:name≈gs:hsCanonicalNamedbpedia:phylum≈gs:inPhylum在dbpedia.org中定义的属性dbpedia:phylum和geospecies.org中定义的属性gs:inPhylum有相同的内在含义：它们对应的值在生物分类中都属于同一个等级。,rdfs:label,等价,gs:hasCommonName
一些属性等价的例子如下所示：rdfs:label≈gs:hasCommonNamefoaf:name≈gs:hsCanonicalNamedbpedia:phylum≈gs:inPhylum在dbpedia.org中定义的属性dbpedia:phylum和geospecies.org中定义的属性gs:inPhylum有相同的内在含义：它们对应的值在生物分类中都属于同一个等级。,foaf:name,等价,gs:hsCanonicalName
一些属性等价的例子如下所示：rdfs:label≈gs:hasCommonNamefoaf:name≈gs:hsCanonicalNamedbpedia:phylum≈gs:inPhylum在dbpedia.org中定义的属性dbpedia:phylum和geospecies.org中定义的属性gs:inPhylum有相同的内在含义：它们对应的值在生物分类中都属于同一个等级。,dbpedia:phylum,等价,gs:inPhylum
"实例等价和属性等价可推导出如下规则：如果两个实例e1,e2满足则有＜e1,e2＞∈～I。",实例等价,属于,SPO三元组
"实例等价和属性等价可推导出如下规则：如果两个实例e1,e2满足则有＜e1,e2＞∈～I。",实例等价,实现,推导出规则
"实例等价和属性等价可推导出如下规则：如果两个实例e1,e2满足则有＜e1,e2＞∈～I。",实例等价,等价,属性等价
"实例等价和属性等价可推导出如下规则：如果两个实例e1,e2满足则有＜e1,e2＞∈～I。",属性等价,等价,推导出如下规则
"（p（e,o）是三元组＜e,p,o＞的函数式表示，o1≃o2表示o1和o2指向同一实例或者字面值相等）。",p,属于,三元组
"（p（e,o）是三元组＜e,p,o＞的函数式表示，o1≃o2表示o1和o2指向同一实例或者字面值相等）。",p,实现,函数的函数式表示
"（p（e,o）是三元组＜e,p,o＞的函数式表示，o1≃o2表示o1和o2指向同一实例或者字面值相等）。",p,中文名,三元组的函数式表示
"（p（e,o）是三元组＜e,p,o＞的函数式表示，o1≃o2表示o1和o2指向同一实例或者字面值相等）。",p,等价,"三元组＜e,p,o＞的函数式表示"
"（p（e,o）是三元组＜e,p,o＞的函数式表示，o1≃o2表示o1和o2指向同一实例或者字面值相等）。",o1,等价,o指向同一实例或者字面值相等
这样的规则可以推导出大量的等价实例，从而完成实例匹配。,等价实例推导,属于,完成实例匹配
这样的规则可以推导出大量的等价实例，从而完成实例匹配。,等价实例推导,实现,推导出大量的等价实例
"定义5.14（属性-值对等价）给定两个隐含等价属性（p1,p2）和两个值（o1,o2），属性-值对＜p1,o1＞和＜p2,o2＞等价当且仅当＜o1,o2＞∈～I（o1,o2为实例），或者o1=o2（o1,o2为字面值），记作～P。",属性-值对等价,属于,"给定两个隐含等价属性（p1,p2）和两个值（o1,o2）"
"定义5.14（属性-值对等价）给定两个隐含等价属性（p1,p2）和两个值（o1,o2），属性-值对＜p1,o1＞和＜p2,o2＞等价当且仅当＜o1,o2＞∈～I（o1,o2为实例），或者o1=o2（o1,o2为字面值），记作～P。",属性-值对等价,实现,"给定两个隐含等价属性（p1,p2）和两个值（o1,o2）"
"定义5.14（属性-值对等价）给定两个隐含等价属性（p1,p2）和两个值（o1,o2），属性-值对＜p1,o1＞和＜p2,o2＞等价当且仅当＜o1,o2＞∈～I（o1,o2为实例），或者o1=o2（o1,o2为字面值），记作～P。",属性-值对等价,等价,"给定两个隐含等价属性（p1,p2）和两个值（o1,o2）"
"定义5.14（属性-值对等价）给定两个隐含等价属性（p1,p2）和两个值（o1,o2），属性-值对＜p1,o1＞和＜p2,o2＞等价当且仅当＜o1,o2＞∈～I（o1,o2为实例），或者o1=o2（o1,o2为字面值），记作～P。","给定两个隐含等价属性（p1,p2）和两个值（o1,o2）",等价,"属性-值对＜p1,o1＞和＜p2,o2＞等价当且仅当＜o1,o2＞∈～I（o1,o2为实例），或者o1=o2（o1,o2为字面值），记作～P。"
"将这种等价关系拓展到属性-值对集，给定一个实例e和属性集合P，属性-值对集定义为PVe,P={＜p,o＞|p∈P,＜e,p,o＞∈G}。",属性-值对集,等价,"给定一个实例e和属性集合P属性-值对集定义为PVe,P={＜p,o＞|p∈P,＜e,p,o＞∈G}。"
"定义5.15（等价属性-值对集）给定两个实例（e1,e2）和一个等价属性对集（＜P1,P2＞），两个键值对集等价当且仅当存在一个从到的双射f∈～P，记作～S。",等价属性-值对集,等价,"给定两个实例（e1,e2）和一个等价属性对集（＜P1,P2＞），两个键值对集等价当且仅当存在一个从到的双射f∈～P，记作～S"
"定义5.16（逆功能属性集）一个等价属性对集eps是一个逆功能属性集（InverseFunctional_Property_Suite），当且仅当其满足若，则＜e1,e2＞∈～I。",逆功能属性集,属于,等价属性对集
"定义5.16（逆功能属性集）一个等价属性对集eps是一个逆功能属性集（InverseFunctional_Property_Suite），当且仅当其满足若，则＜e1,e2＞∈～I。",逆功能属性集,实现,"若,则＜e1,e2＞∈～I"
"定义5.16（逆功能属性集）一个等价属性对集eps是一个逆功能属性集（InverseFunctional_Property_Suite），当且仅当其满足若，则＜e1,e2＞∈～I。",逆功能属性集,中文名,逆功能属性对集
"定义5.16（逆功能属性集）一个等价属性对集eps是一个逆功能属性集（InverseFunctional_Property_Suite），当且仅当其满足若，则＜e1,e2＞∈～I。",等价属性对集,等价,逆功能属性集
"对于所有eps里的属性对＜pi1,pi2＞,EIFPS规则有如下形式：根据以上定义，该方法实现了一个基于EM算法的实例匹配框架，输入为待匹配三元组、初始匹配对阈值，输出为匹配结果集与IFPS规则集。",基于EM算法的实例匹配框架,实现,一个基于EM算法的实例匹配框架
该框架利用EM算法迭代：E步，根据已经获得的EIFPS规则计算实例对应的置信度，把置信度高于阈值的对应放到匹配结果中；M步，根据现有的匹配结果挖掘EIFPS规则，等同于最大化似然函数。,EIFPS,属于,根据已经获得的EIFPS规则计算实例对应的置信度
该框架利用EM算法迭代：E步，根据已经获得的EIFPS规则计算实例对应的置信度，把置信度高于阈值的对应放到匹配结果中；M步，根据现有的匹配结果挖掘EIFPS规则，等同于最大化似然函数。,EIFPS,实现,根据现有的匹配结果挖掘EIFPS规则
该框架利用EM算法迭代：E步，根据已经获得的EIFPS规则计算实例对应的置信度，把置信度高于阈值的对应放到匹配结果中；M步，根据现有的匹配结果挖掘EIFPS规则，等同于最大化似然函数。,EIFPS,中文名,EM算法迭代
根据EIPFS规则集合，可以从所有的三元组中提取出一个匹配图。,匹配图,属于,EIPFS规则集合
根据EIPFS规则集合，可以从所有的三元组中提取出一个匹配图。,匹配图,实现,从所有的三元组中提取出一个
传统上会选择取两者之间的较大值，但这种集成方式只利用了一次匹配的信息，我们倾向于认为利用了两次匹配的信息得出的结果更为准确。,向量空间模型,属于,集成向量空间模型
传统上会选择取两者之间的较大值，但这种集成方式只利用了一次匹配的信息，我们倾向于认为利用了两次匹配的信息得出的结果更为准确。,向量空间模型,实现,利用两次匹配的信息得出更为准确的结果
传统上会选择取两者之间的较大值，但这种集成方式只利用了一次匹配的信息，我们倾向于认为利用了两次匹配的信息得出的结果更为准确。,向量空间模型,中文名,集成向量空间模型
由此可见，系统效率取决于能将原有问题划分为多少个小规模。,系统效率,属于,将原有问题划分为多少个小规模
由此可见，系统效率取决于能将原有问题划分为多少个小规模。,系统效率,实现,将原有问题划分为多少个小规模
由此可见，系统效率取决于能将原有问题划分为多少个小规模。,系统效率,中文名,将原有问题划分为多少个小规模
最常用的分治策略是将大规模本体划分为若干个小知识图谱，然后计算这些小知识图谱间的匹配。,分治策略,属于,将大规模本体划分为若干个小知识图谱
最常用的分治策略是将大规模本体划分为若干个小知识图谱，然后计算这些小知识图谱间的匹配。,分治策略,实现,计算这些小知识图谱间的匹配
本体模块化方法是对大规模本体进行划分的一种直观手段。,本体模块化方法,属于,对大规模本体进行划分的一种直观手段
本体模块化方法是对大规模本体进行划分的一种直观手段。,本体模块化方法,实现,划分大规模本体
本体模块化方法是对大规模本体进行划分的一种直观手段。,本体模块化方法,中文名,对本大规模本体进行划分的一种直观手段
例如，该算法只能将GALEN划分为2个模块，只能将NCI本体划分为17个模块，而且所得模块的规模很不均匀，即某些模块对本体映射来说还是太大了，因此该方法并不能解决将大本体划分为适当大小的问题。,GALEN,等价,将GALEN划分为2个模块
例如，该算法只能将GALEN划分为2个模块，只能将NCI本体划分为17个模块，而且所得模块的规模很不均匀，即某些模块对本体映射来说还是太大了，因此该方法并不能解决将大本体划分为适当大小的问题。,NCI本体,等价,将NCI本体划分为17个模块
例如，该算法对NCI本体划分会得到概念数目为15254的大模块，而对GALEN本体模块化则失败。,SPO三元组,属于,概念/产品
例如，该算法对NCI本体划分会得到概念数目为15254的大模块，而对GALEN本体模块化则失败。,SPO三元组,实现,对NCI本体划分会得到概念数目为15254的大模块
例如，该算法对NCI本体划分会得到概念数目为15254的大模块，而对GALEN本体模块化则失败。,SPO三元组,中文名,对GALEN本体模块化则失败
"此外，一些本体模块化工作的目标是获得描述特定元素集含义的模块[117,118]，而不能将本体划分为多个不相交或只有少量重叠的模块。",本体模块化工作,属于,获得描述特定元素集含义的模块
"此外，一些本体模块化工作的目标是获得描述特定元素集含义的模块[117,118]，而不能将本体划分为多个不相交或只有少量重叠的模块。",本体模块化工作,实现,将本体划分为多个不相交或只有少量重叠的模块
"此外，一些本体模块化工作的目标是获得描述特定元素集含义的模块[117,118]，而不能将本体划分为多个不相交或只有少量重叠的模块。",本体模块化工作,中文名,获得描述特定元素集含义的模块
"此外，一些本体模块化工作的目标是获得描述特定元素集含义的模块[117,118]，而不能将本体划分为多个不相交或只有少量重叠的模块。",本体模块化工作的目标,等价,描述特定元素集含义的模块
Malasco提供了三种本体划分算法：①基于RDF声明[121]的朴素划分算法；②Stuckenschmidt和Klein的模块化算法[119];③基于Grau的ε-connection模块化算法[116]。,Malasco,属于,本体划分算法
Malasco提供了三种本体划分算法：①基于RDF声明[121]的朴素划分算法；②Stuckenschmidt和Klein的模块化算法[119];③基于Grau的ε-connection模块化算法[116]。,基于RDF声明的朴素划分算法的本体划分,实现,基于RDF声明
Malasco提供了三种本体划分算法：①基于RDF声明[121]的朴素划分算法；②Stuckenschmidt和Klein的模块化算法[119];③基于Grau的ε-connection模块化算法[116]。,基于RDF声明,中文名,朴素划分算法
Malasco提供了三种本体划分算法：①基于RDF声明[121]的朴素划分算法；②Stuckenschmidt和Klein的模块化算法[119];③基于Grau的ε-connection模块化算法[116]。,模块化算法,中文名,Malasco
Malasco提供了三种本体划分算法：①基于RDF声明[121]的朴素划分算法；②Stuckenschmidt和Klein的模块化算法[119];③基于Grau的ε-connection模块化算法[116]。,基于ε-connection模块化算法,中文名,Malasco
Paulheim的工作表明了模块化方法经过适当优化，是可以处理大规模本体映射问题的。,模块化方法,属于,处理大规模本体映射问题的方法
Paulheim的工作表明了模块化方法经过适当优化，是可以处理大规模本体映射问题的。,模块化方法经过适当优化,实现,处理大规模本体映射问题
Paulheim的工作表明了模块化方法经过适当优化，是可以处理大规模本体映射问题的。,模块化方法经过适当优化,中文名,经过适当优化的模块化方法
该方法首先通过分析概念层次、属性层次以及属性约束信息，然后利用聚类方法将本体中的元素划分为不相交的若干个集合，再利用RDF声明恢复每个集合中的语义信息，从而完成本体划分。,本体划分,属于,聚类方法将本体中的元素划分为不相交的若干个集合
该方法首先通过分析概念层次、属性层次以及属性约束信息，然后利用聚类方法将本体中的元素划分为不相交的若干个集合，再利用RDF声明恢复每个集合中的语义信息，从而完成本体划分。,该方法,实现,本体划分
该方法首先通过分析概念层次、属性层次以及属性约束信息，然后利用聚类方法将本体中的元素划分为不相交的若干个集合，再利用RDF声明恢复每个集合中的语义信息，从而完成本体划分。,本体划分,中文名,概念聚类
该方法的划分算法可将本体元素划分为合适大小的集合，从而能利用现有的匹配器发现映射。,划分算法,属于,本体元素
该方法的划分算法可将本体元素划分为合适大小的集合，从而能利用现有的匹配器发现映射。,本体元素,实现,利用现有的匹配器发现映射
Falcon-AO的结果也表明该算法并未使映射结果质量有明显损失。,Falcon-AO,属于,映射结果质量
Falcon-AO的结果也表明该算法并未使映射结果质量有明显损失。,Falcon-AO,实现,使映射结果质量有明显损失
Falcon-AO的结果也表明该算法并未使映射结果质量有明显损失。,Falcon-AO,中文名,算法并未使映射结果质量有明显损失
一般来说，划分得到的块越多，边界语义信息损失也越多，因此，模块大小和边界信息损失是不可调和的，在实际应用中需要合理权衡。,模块大小,属于,划分得到的块越多，边界语义信息损失也越多
一般来说，划分得到的块越多，边界语义信息损失也越多，因此，模块大小和边界信息损失是不可调和的，在实际应用中需要合理权衡。,模块大小,实现,划分得到的块越多，边界信息损失也越多
一般来说，划分得到的块越多，边界语义信息损失也越多，因此，模块大小和边界信息损失是不可调和的，在实际应用中需要合理权衡。,模块大小,中文名,模块大小和边界信息损失是不可调和的
一般来说，划分得到的块越多，边界语义信息损失也越多，因此，模块大小和边界信息损失是不可调和的，在实际应用中需要合理权衡。,模块大小,等价,边界信息损失
Malasco中的覆盖模块优化方法是一种对该缺点的补救处理。,覆盖模块优化方法,属于,对该缺点的补救处理
Malasco中的覆盖模块优化方法是一种对该缺点的补救处理。,覆盖模块优化方法,实现,对该缺点的补救处理
该方法的优点是实现过程简单，同时避免了划分知识图谱造成的语义信息损失。,该方法的优点,属于,实现过程简单
该方法的优点是实现过程简单，同时避免了划分知识图谱造成的语义信息损失。,该方法的优点,属于,避免划分知识图谱造成的语义信息损失
该方法的优点是实现过程简单，同时避免了划分知识图谱造成的语义信息损失。,该方法的优点,实现,实现过程简单
该方法的优点是实现过程简单，同时避免了划分知识图谱造成的语义信息损失。,该方法的优点,实现,避免划分知识图谱造成的语义信息损失
该方法的优点是实现过程简单，同时避免了划分知识图谱造成的语义信息损失。,该方法的优点,中文名,实现过程简单
该方法的优点是实现过程简单，同时避免了划分知识图谱造成的语义信息损失。,该方法的优点,中文名,避免划分知识图谱造成的语义信息损失
类似的方法在关系数据库领域和自然语言处理领域中的实体消解中早已得到了广泛的应用。,实体消解,属于,关系数据库领域
类似的方法在关系数据库领域和自然语言处理领域中的实体消解中早已得到了广泛的应用。,实体消解,属于,自然语言处理领域
类似的方法在关系数据库领域和自然语言处理领域中的实体消解中早已得到了广泛的应用。,类似的方法,实现,实体消解中早已得到了广泛的应用
类似的方法在关系数据库领域和自然语言处理领域中的实体消解中早已得到了广泛的应用。,类似的方法,中文名,实体消解中早已得到了广泛的应用
