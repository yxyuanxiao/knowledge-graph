input,subject,relation,object
为了更好地进行三元组数据的存储，语义万维网领域发展出专门存储RDF数据的三元组库；数据库领域发展出用于管理属性图的图数据库。,三元组库,包含,存储RDF数据
为了更好地进行三元组数据的存储，语义万维网领域发展出专门存储RDF数据的三元组库；数据库领域发展出用于管理属性图的图数据库。,图数据库,包含,管理属性图
虽然目前没有一种数据库系统被公认为具有主导地位的知识图谱数据库，但可以预见，随着三元组库和图数据库的相互融合发展，知识图谱的存储和数据管理手段将愈加丰富和强大。,知识图谱数据库,包含,三元组库
虽然目前没有一种数据库系统被公认为具有主导地位的知识图谱数据库，但可以预见，随着三元组库和图数据库的相互融合发展，知识图谱的存储和数据管理手段将愈加丰富和强大。,知识图谱数据库,包含,图数据库
3.1知识图谱数据库基本知识本节首先介绍目前表示知识图谱的两种主要图数据模型：RDF图和属性图。,知识图谱数据库,包含,RDF图
3.1知识图谱数据库基本知识本节首先介绍目前表示知识图谱的两种主要图数据模型：RDF图和属性图。,知识图谱数据库,包含,属性图
3.1.1知识图谱数据模型从数据模型角度来看，知识图谱本质上是一种图数据。,知识图谱,包含,图数据
不同领域的知识图谱均须遵循相应的数据模型。,知识图谱,包含,数据模型
知识图谱数据模型的数学基础源于有着近300年历史的数学分支——图论。,知识图谱数据模型,包含,图论
"在图论中，图是二元组G=（V,E），其中V是节点集合，E是边集合。",图,包含,V
"在图论中，图是二元组G=（V,E），其中V是节点集合，E是边集合。",图,包含,E
知识图谱数据模型基于图论中图的定义，用节点集合表示实体，用边集合表示实体间的联系，这种一般和通用的数据表示恰好能够自然地刻画现实世界中事物的广泛联系。,知识图谱数据模型,包含,节点集合表示实体
知识图谱数据模型基于图论中图的定义，用节点集合表示实体，用边集合表示实体间的联系，这种一般和通用的数据表示恰好能够自然地刻画现实世界中事物的广泛联系。,知识图谱数据模型,包含,边集合表示实体间的联系
1.RDF图RDF是W3C制定的在语义万维网上表示和交换机器可理解信息的标准数据模型[1]。,RDF,包含,在语义万维网上表示和交换机器可理解信息的标准数据模型
实际上，RDF三元组集合即为图中的有向边集合。,RDF三元组集合,包含,图中的有向边集合
图3-1RDF图示例值得注意的是，RDF图对于节点和边上的属性没有内置的支持。,RDF图,包含,节点和边上的属性
节点属性可用三元组表示，这类三元组的宾语称为字面量，即图中的矩形。,节点属性,包含,三元组
边上的属性表示起来稍显烦琐，最常见的是利用RDF中一种叫作“具体化”（reification）的技术[2]，需要引入额外的点表示整个三元组，将边属性表示为以该节点为主语的三元组。,边上的属性,包含,利用RDF中一种叫作“具体化”（reification）的技术
例如在图3-2中，引入节点ex:participate代表三元组(ex:zhangsan，参加，ex:graphdb)，该节点通过RDF内置属性rdf:subject、rdf:predicate和rdf:object分别与代表的三元组的主语、谓语和宾语建立起联系，这样三元组(ex:participate，权重，0.4)就实现了为原三元组增加边属性的效果。,ex:participate,包含,为原三元组增加边属性的效果
图3-2RDF图中边属性的表示2.属性图属性图可以说是目前被图数据库业界采纳最广的一种图数据模型[3]。,属性图,包含,目前被图数据库业界采纳最广的一种图数据模型
属性图由节点集和边集组成，且满足如下性质：（1）每个节点具有唯一的id；（2）每个节点具有若干条出边；（3）每个节点具有若干条入边；（4）每个节点具有一组属性，每个属性是一个键值对；（5）每条边具有唯一的id；（6）每条边具有一个头节点；（7）每条边具有一个尾节点；（8）每条边具有一个标签，表示联系；（9）每条边具有一组属性，每个属性是一个键值对。,属性图的性质,包含,（1）每个节点具有唯一的id
图3-3给出的属性图不仅表达了RDF图的全部数据，而且还增加了边上的“权重”属性。,属性图,包含,边上的“权重”属性
图3-3属性图示例图3-3的每个节点和每条边均有id。,图3-3的每个节点,包含,id
图3-3属性图示例图3-3的每个节点和每条边均有id。,图3-3的每条边,包含,id
"遵照属性图的要素，节点4的出边集合为{边10,边11}，入边集合为{边8}，属性集合为{姓名=""王五""，年龄=32}；边11的头节点是节点3，尾节点是节点4，标签是“参加”，属性集合为{权重=0.4}。",节点4的出边集合,包含,边10
"遵照属性图的要素，节点4的出边集合为{边10,边11}，入边集合为{边8}，属性集合为{姓名=""王五""，年龄=32}；边11的头节点是节点3，尾节点是节点4，标签是“参加”，属性集合为{权重=0.4}。",节点4的出边集合,包含,边11
3.1.2知识图谱查询语言在知识图谱数据模型上，需要借助知识图谱查询语言进行查询操作。,知识图谱查询语言,包含,查询操作
目前，RDF图上的查询语言是SPARQL；属性图上的查询语言常用的是Cypher和Gremlin。,SPARQL,包含,RDF图上的查询语言
目前，RDF图上的查询语言是SPARQL；属性图上的查询语言常用的是Cypher和Gremlin。,Cypher,包含,属性图上的查询语言
1.SPARQLSPARQL是W3C制定的RDF图数据的标准查询语言[4]。,SPARQL,包含,W3C制定的RDF图数据的标准查询语言
最新的SPARQL1.1版本为有效查询RDF图专门设计了三元组模式、子图模式、属性路径等多种查询机制。,SPARQL1.1,包含,三元组模式查询机制
最新的SPARQL1.1版本为有效查询RDF图专门设计了三元组模式、子图模式、属性路径等多种查询机制。,SPARQL1.1,包含,子图模式查询机制
最新的SPARQL1.1版本为有效查询RDF图专门设计了三元组模式、子图模式、属性路径等多种查询机制。,SPARQL1.1,包含,属性路径查询机制
几乎全部的RDF三元组数据库都实现了SPARQL语言。,RDF三元组数据库,包含,SPARQL语言
查询使用的是RDF图数据。,查询,包含,RDF图数据
三元组模式查询是最基本的SPARQL查询。,SPARQL查询,包含,三元组模式查询
（2）查询程序员张三认识的其他程序员参加的项目输出：说明：这是由两个三元组模式组成的一个基本图模式（Basic_Graph_Pattern）查询，简称为BGP查询。,BGP查询,包含,查询程序员张三认识的其他程序员参加的项目
实际上，这两个三元组模式之间通过公共变量？p连接为一个链式查询。,三元组模式,包含,公共变量
（3）查询节点ex:zhangsan认识的30岁以上的程序员参加的项目名称输出：说明：关键字FILTER用于指明过滤条件，对变量匹配结果进行按条件筛选。,查询节点,包含,ex:zhangsan认识的30岁以上的程序员参加的项目名称
这里既有？p和？pr分别作为两个三元组模式的宾语和主语连接起来的链式模式，也有？p作为两个三元组模式的主语连接起来的星形结构，该查询是一个更加一般的BGP查询。,三元组模式的宾语和主语连接起来的链式模式,包含,？p
这里既有？p和？pr分别作为两个三元组模式的宾语和主语连接起来的链式模式，也有？p作为两个三元组模式的主语连接起来的星形结构，该查询是一个更加一般的BGP查询。,三元组模式的主语连接起来的星形结构,包含,？p
实际上，BGP查询相当于一个带有变量的查询图，查询过程是在数据图中寻找与查询图映射Isomorphism）或子图同态匹配的所有子图，等价于图论中的子图同构（Subgraph（Subgraph_Homomorphism）问题[5]，所以也将BGP查询称为子图匹配查询。,BGP查询,包含,子图同构（Subgraph（Subgraph_Homomorphism）问题
（4）查询年龄为29的参加了项目ex:graphdb的程序员参加的其他项目及其直接或间接认识的程序员参加的项目输出：说明：这里使用了Path）机制，ex:knows*/ex:participate类似于正则表达式，其表示经过0条、1条或多条ex:knows边，再经过一条ex:participate边。,ex:graphdb,包含,查询年龄为29的参加了项目ex:graphdb的程序员参加的其他项目及其直接或间接认识的程序员参加的项目
1.1引入的属性路径（Property_SPARQL_SPARQL实际上是一整套知识服务标准体系。,SPARQL_SPARQL,包含,知识服务标准体系
SPARQL1.1语言的语法和语义的完整定义请参见W3C的推荐标准“SPARQL1.1查询语言”[4]，该标准连同其他10个推荐标准共同组成了SPARQL知识平台，包括查询[4]、更新[6]、服务描述[7]、联邦查询[8]、查询结果格式[9]、蕴涵推理[10]和接口协议[11]等。,SPARQL1.1查询语言,包含,语法和语义的完整定义
开放的SPARQL学习教程有WikiBooks_SPARQL教程[12]、WikidataSPARQL教程[13]和Apache_Jena_SPARQL教程[14]等。,开放的SPARQL学习教程,包含,WikiBooks_SPARQL教程
开放的SPARQL学习教程有WikiBooks_SPARQL教程[12]、WikidataSPARQL教程[13]和Apache_Jena_SPARQL教程[14]等。,开放的SPARQL学习教程,包含,WikidataSPARQL教程
开放的SPARQL学习教程有WikiBooks_SPARQL教程[12]、WikidataSPARQL教程[13]和Apache_Jena_SPARQL教程[14]等。,开放的SPARQL学习教程,包含,Apache_Jena_SPARQL教程
2.CypherCypher最初是图数据库Neo4j中实现的属性图数据查询语言[15]。,Cypher,包含,属性图数据查询语言
与SPARQL一样，Cypher也是一种声明式语言，即用户只需要声明“查什么”，而无须关心“怎么查”，这就好比乘坐出租车到一个目的地，只需要告诉司机要到哪里，具体的行车路线可由司机安排，乘客并不需要关心。,Cypher,包含,声明式语言
这类语言的优点是便于用户学习掌握，同时给予数据库进行查询优化的空间，缺点是不能满足高级用户导航式查询的要求，数据库规划的查询执行计划有可能并不是最优方案。,这类语言的优点,包含,便于用户学习掌握
这类语言的优点是便于用户学习掌握，同时给予数据库进行查询优化的空间，缺点是不能满足高级用户导航式查询的要求，数据库规划的查询执行计划有可能并不是最优方案。,这类语言的缺点,包含,不能满足高级用户导航式查询的要求
2015年，Neo4j公司发起开源项目openCypher[16]，旨在对Cypher进行标准化工作，为其他实现者提供语法和语义的参考标准。,openCypher,包含,对Cypher进行标准化工作
虽然Cypher的发展目前仍由Neo4j主导，但包括SAP_HANA_Graph[17]、Redis_Graph[18]、AgensGraph[19]和Memgraph[20]等在内的图数据库产品已经实现了Cypher。,Cypher,包含,SAP_HANA_Graph
虽然Cypher的发展目前仍由Neo4j主导，但包括SAP_HANA_Graph[17]、Redis_Graph[18]、AgensGraph[19]和Memgraph[20]等在内的图数据库产品已经实现了Cypher。,Cypher,包含,Redis_Graph
虽然Cypher的发展目前仍由Neo4j主导，但包括SAP_HANA_Graph[17]、Redis_Graph[18]、AgensGraph[19]和Memgraph[20]等在内的图数据库产品已经实现了Cypher。,Cypher,包含,AgensGraph
虽然Cypher的发展目前仍由Neo4j主导，但包括SAP_HANA_Graph[17]、Redis_Graph[18]、AgensGraph[19]和Memgraph[20]等在内的图数据库产品已经实现了Cypher。,Cypher,包含,Memgraph
使用的知识图谱是图3-3中的属性图。,知识图谱,包含,属性图
（1）查询图中的所有程序员节点输出：说明：MATCH关键字指明需要匹配的模式，这里将节点分为了程序员和项目两类，p作为查询变量会依次绑定到每个类型为Programmer的节点，RETURN关键字返回变量p的值作为查询结果。,查询图中的所有程序员节点,包含,返回变量p的值作为查询结果。
（2）查询程序员与“图数据库”项目之间的边输出：说明：此查询返回边及其属性，程序员类型节点与图数据库项目节点之前存在3条标签为参加的边。,程序员,包含,参加的
（2）查询程序员与“图数据库”项目之间的边输出：说明：此查询返回边及其属性，程序员类型节点与图数据库项目节点之前存在3条标签为参加的边。,程序员,包含,图数据库项目
（3）查询从节点1出发的标签为“认识”的边输出：说明：从节点1出发沿“认识”边到达节点2和节点4。,查询从节点1出发的标签为“认识”的边,包含,从节点1出发沿“认识”边到达节点2和节点4
（4）查询节点1认识的30岁以上的程序员参加的项目名称输出：说明：该查询MATCH子句等价于SPARQLBGP查询的链式查询。,查询节点1认识的30岁以上的程序员参加的项目名称,包含,实现
（5）查询年龄为29的参加了项目3的程序员参加的其他项目及其直接或间接认识的程序员参加的项目输出：说明：“：认识*0..”表示由一个节点到达另一个节点的路径包括0个、1个或多个“认识”边。,项目3,包含,查询年龄为29的参加了项目3的程序员参加的其他项目
（5）查询年龄为29的参加了项目3的程序员参加的其他项目及其直接或间接认识的程序员参加的项目输出：说明：“：认识*0..”表示由一个节点到达另一个节点的路径包括0个、1个或多个“认识”边。,查询年龄为29的参加了项目3的程序员参加的其他项目,包含,直接或间接认识的程序员参加的项目
对比该查询的SPARQL版本。,查询的SPARQL版本,包含,对比
3.GremlinGremlin是Apache_TinkerPop图计算框架[21]提供的属性图查询语言[22]。,Gremlin,包含,属性图查询语言
Gremlin的定位是图遍历语言，其执行机制好比是一个人置身于图中沿着有向边，从一个节点到另一个节点进行导航式的游走。,Gremlin,包含,图遍历语言
Gremlin的定位是图遍历语言，其执行机制好比是一个人置身于图中沿着有向边，从一个节点到另一个节点进行导航式的游走。,Gremlin,包含,执行机制
这种执行方式决定了用户使用Gremlin需要指明具体的导航步骤，这和自己驾驶汽车到一个目的地需要知道行车路线是一个道理，所以将Gremlin归为过程式语言，即需要明确“怎么做”。,Gremlin,包含,需要指明具体的导航步骤
这类语言的优点是可以时刻知道自己在图中所处的位置，以及是如何到达该位置的；缺点是用户需要“认识路”！与受到SQL影响的声明式语言SPARQL和Cypher不同，Gremlin更像一种函数式的编程语言接口。,Gremlin,包含,函数式的编程语言接口
下面通过几个例子认识Gremlin语言，假设用g代表图3-3中的属性图。,Gremlin语言,包含,查询图3-3中属性图g的实现
（1）列出图中所有节点的属性输出：说明：V表示节点集合。,V,包含,节点
（2）列出图中所有的边输出：说明：E表示边集合。,E,包含,边
（3）查询从节点1出发的标签为“认识”的边输出：说明：v(1)选取id为1的节点；outE表示节点的出边集合，outE(’认识’)是标签为“认识”的出边集合。,出边,包含,标签为“认识”的出边集合
（3）查询从节点1出发的标签为“认识”的边输出：说明：v(1)选取id为1的节点；outE表示节点的出边集合，outE(’认识’)是标签为“认识”的出边集合。,节点,包含,v(1)
（4）查询节点1认识的30岁以上的程序员参加的项目名称输出：说明：out(’认识’)选取标签为“认识”的出边指向的邻接节点集合；filter为过滤器，filter{it.年龄>30}的意思是后面只处理年龄大于30的节点。,查询节点1认识的30岁以上的程序员参加的项目名称,包含,实现
"（5）查询年龄为29的参加了项目3的程序员参加的其他项目及其直接或间接认识的程序员参加的项目输出：说明：in(’参加’)选取标签为“参加”的入边连接的邻接节点集合；has(’年龄’,29)的作用是只选取具有属性“年龄=29”的节点；as('x')将当前的导航步骤命名为x;loop('x'){it.loops>=0}为从x开始到当前的步骤循环0次、1次或多次。",查询年龄为29的参加了项目3的程序员参加的其他项目,包含,参加的其他项目
"（5）查询年龄为29的参加了项目3的程序员参加的其他项目及其直接或间接认识的程序员参加的项目输出：说明：in(’参加’)选取标签为“参加”的入边连接的邻接节点集合；has(’年龄’,29)的作用是只选取具有属性“年龄=29”的节点；as('x')将当前的导航步骤命名为x;loop('x'){it.loops>=0}为从x开始到当前的步骤循环0次、1次或多次。",查询年龄为29的参加了项目3的程序员参加的其他项目及其直接或间接认识的程序员参加的项目,包含,参加的其他项目及其直接或间接认识的程序员参加的项目
对比该查询的SPARQL和Cypher版本。,SPARQL,包含,查询
3.2常见知识图谱存储方法本节介绍三类知识图谱数据库：基于关系数据库的存储方案、面向RDF的三元组数据库和原生图数据库，多数系统给出了演示操作步骤。,知识图谱数据库,包含,基于关系数据库的存储方案
3.2常见知识图谱存储方法本节介绍三类知识图谱数据库：基于关系数据库的存储方案、面向RDF的三元组数据库和原生图数据库，多数系统给出了演示操作步骤。,知识图谱数据库,包含,面向RDF的三元组数据库
3.2常见知识图谱存储方法本节介绍三类知识图谱数据库：基于关系数据库的存储方案、面向RDF的三元组数据库和原生图数据库，多数系统给出了演示操作步骤。,知识图谱数据库,包含,原生图数据库
3.2.1基于关系数据库的存储方案关系数据库拥有40多年的发展历史，从理论到实践有着一整套成熟体系。,关系数据库,包含,40多年的发展历史
3.2.1基于关系数据库的存储方案关系数据库拥有40多年的发展历史，从理论到实践有着一整套成熟体系。,关系数据库,包含,一整套成熟体系
在历史上，关系数据库曾经取代了层次数据库和网状数据库；成功吸收容纳了面向对象数据库和XML数据库，成为现今数据管理的主流数据库产品。,关系数据库,包含,层次数据库
在历史上，关系数据库曾经取代了层次数据库和网状数据库；成功吸收容纳了面向对象数据库和XML数据库，成为现今数据管理的主流数据库产品。,关系数据库,包含,网状数据库
在历史上，关系数据库曾经取代了层次数据库和网状数据库；成功吸收容纳了面向对象数据库和XML数据库，成为现今数据管理的主流数据库产品。,关系数据库,包含,面向对象数据库
在历史上，关系数据库曾经取代了层次数据库和网状数据库；成功吸收容纳了面向对象数据库和XML数据库，成为现今数据管理的主流数据库产品。,关系数据库,包含,XML数据库
在历史上，关系数据库曾经取代了层次数据库和网状数据库；成功吸收容纳了面向对象数据库和XML数据库，成为现今数据管理的主流数据库产品。,层次数据库,包含,关系数据库
在历史上，关系数据库曾经取代了层次数据库和网状数据库；成功吸收容纳了面向对象数据库和XML数据库，成为现今数据管理的主流数据库产品。,网状数据库,包含,关系数据库
在历史上，关系数据库曾经取代了层次数据库和网状数据库；成功吸收容纳了面向对象数据库和XML数据库，成为现今数据管理的主流数据库产品。,面向对象数据库,包含,关系数据库
在历史上，关系数据库曾经取代了层次数据库和网状数据库；成功吸收容纳了面向对象数据库和XML数据库，成为现今数据管理的主流数据库产品。,XML数据库,包含,关系数据库
因此基于历史上的成功经验，人们容易想到使用关系数据库存储知识图谱。,知识图谱,包含,关系数据库
基于关系数据库的存储方案是目前知识图谱采用的一种主要存储方法。,基于关系数据库的存储方案,包含,知识图谱存储方法
本小节将按照时间发展顺序简要介绍各种基于关系表的知识图谱存储结构，包括三元组表、水平表、属性表、垂直划分、六重索引和DB2RDF。,基于关系表的知识图谱存储结构,包含,三元组表
本小节将按照时间发展顺序简要介绍各种基于关系表的知识图谱存储结构，包括三元组表、水平表、属性表、垂直划分、六重索引和DB2RDF。,基于关系表的知识图谱存储结构,包含,水平表
本小节将按照时间发展顺序简要介绍各种基于关系表的知识图谱存储结构，包括三元组表、水平表、属性表、垂直划分、六重索引和DB2RDF。,基于关系表的知识图谱存储结构,包含,属性表
本小节将按照时间发展顺序简要介绍各种基于关系表的知识图谱存储结构，包括三元组表、水平表、属性表、垂直划分、六重索引和DB2RDF。,基于关系表的知识图谱存储结构,包含,垂直划分
本小节将按照时间发展顺序简要介绍各种基于关系表的知识图谱存储结构，包括三元组表、水平表、属性表、垂直划分、六重索引和DB2RDF。,基于关系表的知识图谱存储结构,包含,六重索引
本小节将按照时间发展顺序简要介绍各种基于关系表的知识图谱存储结构，包括三元组表、水平表、属性表、垂直划分、六重索引和DB2RDF。,基于关系表的知识图谱存储结构,包含,DB2RDF
对于其他格式的知识图谱，这些存储方案同样适用。,其他格式的知识图谱,包含,存储方案
表3-1是图3-4中知识图谱对应的三元组表，由于一共有21行，限于篇幅仅列出了前5行。,表3-1,包含,知识图谱对应的三元组表
表3-1三元组表三元组表存储方案虽然简单明了，但三元组表的行数与知识图谱的边数一样，其最大问题在于将知识图谱查询翻译为SQL查询后的三元组表自连接。,三元组表,包含,简单明了
例如，如图3-5所示的SPARQL查询是查找1850年出生且1934年逝世的创办了某公司的人，翻译为等价的SQL查询后如图3-6所示，这里三元组表的表名为t。,SPARQL查询,等价,查找1850年出生且1934年逝世的创办了某公司的人
例如，如图3-5所示的SPARQL查询是查找1850年出生且1934年逝世的创办了某公司的人，翻译为等价的SQL查询后如图3-6所示，这里三元组表的表名为t。,SPARQL查询,包含,查找1850年出生且1934年逝世的创办了某公司的人
例如，如图3-5所示的SPARQL查询是查找1850年出生且1934年逝世的创办了某公司的人，翻译为等价的SQL查询后如图3-6所示，这里三元组表的表名为t。,等价的SQL查询,包含,查找1850年出生且1934年逝世的创办了某公司的人
一般自连接的数量与SPARQL中三元组模式数量相当。,自连接,包含,SPARQL中三元组模式数量
当三元组表规模较大时，多个自连接操作会使SQL查询性能低下。,自连接操作,包含,多个自连接操作会使SQL查询性能低下
采用三元组表存储方案的代表是RDF数据库系统3store[24]。,RDF数据库系统3store,包含,采用三元组表存储方案
图3-5一个星形SPARQL查询图3-6三元组表方案中SPARQL查询转换为等价的SQL查询2.水平表水平表存储方案同样非常简单，与三元组表不同，其每行记录存储一个知识图谱中一个主语的所有谓语和宾语。,水平表存储方案,等价,一个知识图谱中一个主语的所有谓语和宾语
图3-5一个星形SPARQL查询图3-6三元组表方案中SPARQL查询转换为等价的SQL查询2.水平表水平表存储方案同样非常简单，与三元组表不同，其每行记录存储一个知识图谱中一个主语的所有谓语和宾语。,水平表存储方案,包含,一个主语的所有谓语和宾语
实际上，水平表就相当于知识图谱的邻接表。,水平表,包含,知识图谱的邻接表
表3-2是图3-4中知识图谱对应的水平表，共有5行、13列，限于篇幅省略了若干列。,表3-2,包含,水平表
表3-2是图3-4中知识图谱对应的水平表，共有5行、13列，限于篇幅省略了若干列。,表3-2,包含,5行
表3-2是图3-4中知识图谱对应的水平表，共有5行、13列，限于篇幅省略了若干列。,表3-2,包含,13列
不难看出，水平表的列数是知识图谱中不同谓语的数量，行数是知识图谱中不同主语的数量。,水平表的列数,包含,知识图谱中不同谓语的数量
不难看出，水平表的列数是知识图谱中不同谓语的数量，行数是知识图谱中不同主语的数量。,水平表的行数,包含,知识图谱中不同主语的数量
表3-2水平表在水平表存储方案中，图3-5所示的SPARQL查询可以等价地翻译为图3-7中的SQL查询。,SPARQL查询,等价,SQL查询
表3-2水平表在水平表存储方案中，图3-5所示的SPARQL查询可以等价地翻译为图3-7中的SQL查询。,水平表存储方案,包含,SPARQL查询
可见，与三元组表相比，水平表的查询大为简化，仅需单表查询即可完成该任务，不用进行连接操作。,水平表的查询,包含,单表查询
图3-7水平表方案中SPARQL查询转换为等价的SQL查询但是水平表的缺点在于：所需列的数目等于知识图谱中不同谓语数量，在真实知识图谱数据集中，不同谓语数量可能为几千个到上万个，很可能超出关系数据库允许的表中列数目的上限；对于一行来说，仅在极少数列上具有值，表中存在大量空值，空值过多会影响表的存储、索引和查询性能；在知识图谱中，同一主语和谓语可能具有多个不同宾语，即一对多联系或多值属性，而水平表的一行一列上只能存储一个值，无法应对这种情况（可以将多个值用分隔符连接存储为一个值，但这违反关系数据库设计的第一范式）；知识图谱的更新往往会引起谓语的增加、修改或删除，即水平表中列的增加、修改或删除，这是对于表结构的改变，成本很高。,水平表的缺点,等价,将多个值用分隔符连接存储为一个值，但这违反关系数据库设计的第一范式
图3-7水平表方案中SPARQL查询转换为等价的SQL查询但是水平表的缺点在于：所需列的数目等于知识图谱中不同谓语数量，在真实知识图谱数据集中，不同谓语数量可能为几千个到上万个，很可能超出关系数据库允许的表中列数目的上限；对于一行来说，仅在极少数列上具有值，表中存在大量空值，空值过多会影响表的存储、索引和查询性能；在知识图谱中，同一主语和谓语可能具有多个不同宾语，即一对多联系或多值属性，而水平表的一行一列上只能存储一个值，无法应对这种情况（可以将多个值用分隔符连接存储为一个值，但这违反关系数据库设计的第一范式）；知识图谱的更新往往会引起谓语的增加、修改或删除，即水平表中列的增加、修改或删除，这是对于表结构的改变，成本很高。,水平表的缺点,包含,所需列的数目等于知识图谱中不同谓语数量
采用水平表存储方案的代表是早期的RDF数据库系统DLDB[25]。,DLDB,包含,水平表存储方案
3.属性表属性表（Property_Table）存储方案是对水平表的细化，将同类主语分到一个表中，不同类主语分到不同表中。,属性表属性表,包含,水平表的细化
这样就解决了表中列的数目过多的问题。,表,包含,列数目过多的问题
对于图3-5中的SPARQL查询，在属性表存储方案上等价的SQL查询如图3-9所示；该查询与图3-7中水平表上查询的唯一区别是将表名由t变为了person。,属性表存储方案上等价的SQL查询,等价,图3-9所示
对于图3-5中的SPARQL查询，在属性表存储方案上等价的SQL查询如图3-9所示；该查询与图3-7中水平表上查询的唯一区别是将表名由t变为了person。,SPARQL查询,包含,等价的SQL查询
图3-8属性表图3-9属性表方案中SPARQL查询转换为等价的SQL查询属性表既克服了三元组表的自连接问题，又解决了水平表中列数目过多的问题。,属性表,等价,SPARQL查询转换为等价的SQL查询
图3-8属性表图3-9属性表方案中SPARQL查询转换为等价的SQL查询属性表既克服了三元组表的自连接问题，又解决了水平表中列数目过多的问题。,属性表,包含,自连接问题
图3-8属性表图3-9属性表方案中SPARQL查询转换为等价的SQL查询属性表既克服了三元组表的自连接问题，又解决了水平表中列数目过多的问题。,属性表,包含,水平表中列数目过多的问题
实际上，水平表方案是属性表存储方案的一种极端情况，即水平表是将所有主语划归为一类，因此属性表中的空值问题与水平表相比会大为缓解。,水平表方案,包含,属性表存储方案
采用属性表存储方案的代表是RDF三元组库Jena[26]。,RDF三元组库Jena,包含,采用属性表存储方案
4.垂直划分垂直划分（Vertical_Partitioning）存储方案是由美国麻省理工学院的Abadi等人在2007年提出的RDF数据存储方法[27]。,垂直划分存储方案,包含,RDF数据存储方法
该方法以三元组的谓语作为划分维度，将RDF知识图谱划分为若干张只包含(主语，宾语)两列的表，表的总数量即知识图谱中不同谓语的数量；也就是说，为每种谓语建立一张表，表中存放知识图谱中由该谓语连接的主语和宾语值。,RDF知识图谱的划分,包含,将RDF知识图谱划分为若干张只包含(主语，宾语)两列的表
对于图3-5中的SPARQL查询，在垂直划分存储方案中等价的SQL查询如图3-11所示；该查询涉及3张谓语表born、died和founder的连接操作。,垂直划分存储方案的等价的SQL查询,等价,图3-11
对于图3-5中的SPARQL查询，在垂直划分存储方案中等价的SQL查询如图3-11所示；该查询涉及3张谓语表born、died和founder的连接操作。,SPARQL查询,包含,等价的SQL查询
由于谓语表中的行都是按照主语列进行排序的，可以快速执行这种以“主语-主语”作为连接条件的查询操作，而这种连接操作又是常用的。,谓语表的行,包含,按照主语列进行排序
与之前基于关系数据库的知识图谱存储方案相比，垂直划分有一些突出的优点：谓语表仅存储出现在知识图谱中的三元组，解决了空值问题；一个主语的一对多联系或多值属性存储在谓语表的多行中，解决了多值问题；每个谓语表都按主语列的值进行排序，能够使用归并排序连接（Merge-sort_Join）快速执行不同谓语表的连接查询操作。,垂直划分,包含,谓语表的优点
与之前基于关系数据库的知识图谱存储方案相比，垂直划分有一些突出的优点：谓语表仅存储出现在知识图谱中的三元组，解决了空值问题；一个主语的一对多联系或多值属性存储在谓语表的多行中，解决了多值问题；每个谓语表都按主语列的值进行排序，能够使用归并排序连接（Merge-sort_Join）快速执行不同谓语表的连接查询操作。,垂直划分,包含,谓语表的优点
采用垂直划分存储方案的代表数据库是SW-Store[28]。,SW-Store,包含,垂直划分存储方案
5.六重索引六重索引（Sextuple_Indexing）存储方案是对三元组表的扩展，是一种典型的“空间换时间”策略，其将三元组全部6种排列对应地建立为6张表，即spo(主语，谓语，宾语)、pos(谓语，宾语，主语)、osp(宾语，主语，谓语)、sop(主语，宾语，谓语)、pso(谓语，主语，宾语)和ops(宾语，谓语，主语)。,六重索引六重索引（Sextuple_Indexing）存储方案,包含,spo(主语，谓语，宾语)、pos(谓语，宾语，主语)、osp(宾语，主语，谓语)、sop(主语，宾语，谓语)、pso(谓语，主语，宾语)和ops(宾语，谓语，主语)。
不难看出，其中spo表就是原来的三元组表。,spo表,包含,三元组表
六重索引通过6张表的连接操作不仅缓解了三元组表的单表自连接问题，而且加速了某些典型知识图谱查询的效率。,六重索引,包含,6张表的连接操作
使用六重索引方法的典型系统有RDF-3X[28]和Hexastore[29]。,RDF-3X,包含,六重索引方法
使用六重索引方法的典型系统有RDF-3X[28]和Hexastore[29]。,Hexastore,包含,六重索引方法
表3-3三元组模式查询能够使用的索引表图3-12一个链式SPARQL查询六重索引存储方案存在的问题包括：虽然部分缓解了三元组表的单表自连接问题，但需要花费6倍的存储空间开销、索引维护代价和数据更新时的一致性维护代价，随着知识图谱规模的增大，该问题会愈加突出；当知识图谱查询变得复杂时，会产生大量的连接索引表查询操作，索引表的自连接依然不可避免。,六重索引存储方案,包含,部分缓解了三元组表的单表自连接问题
6.DB2RDFDB2RDF是由IBM研究中心于2013年提出的一种面向实体的RDF知识图谱存储方案[30]，该方案是以往RDF关系存储方案的一种权衡折中，既具备了三元组表、属性表和垂直划分方案的部分优点，又克服了这些方案的部分缺点。,DB2RDF,包含,以往RDF关系存储方案的部分缺点
三元组表的优势在于“行维度”上的灵活性，即存储模式不会随行的增加而变化；DB2RDF方案将这种灵活性扩展到“列维度”上，即将表的列作为谓语和宾语的存储位置，而不将列与谓语进行绑定。,DB2RDF方案的灵活性,包含,表的列作为谓语和宾语的存储位置
当插入数据时，将谓语动态地映射存储到某列；方案能够确保将相同的谓语映射到同一组列上。,方案,包含,将相同的谓语映射到同一组列上
DB2RDF存储方案由4张表组成，即dph表、rph表、ds表和rs表；图3-13给出了图3-4中知识图谱对应的DB2RDF存储方案。,DB2RDF存储方案,包含,dph表
DB2RDF存储方案由4张表组成，即dph表、rph表、ds表和rs表；图3-13给出了图3-4中知识图谱对应的DB2RDF存储方案。,DB2RDF存储方案,包含,rph表
DB2RDF存储方案由4张表组成，即dph表、rph表、ds表和rs表；图3-13给出了图3-4中知识图谱对应的DB2RDF存储方案。,DB2RDF存储方案,包含,ds表
DB2RDF存储方案由4张表组成，即dph表、rph表、ds表和rs表；图3-13给出了图3-4中知识图谱对应的DB2RDF存储方案。,DB2RDF存储方案,包含,rs表
"dph（direct_primary_hash）是存储方案的主表，该表中一行存储一个主语（主语列）及其全部谓语（predi列）和宾语（vali列）,0≤i≤k,k为图着色结果值或某个给定值。",dph,包含,"主语（主语列）及其全部谓语（predi列）和宾语（vali列）,0≤i≤k,k为图着色结果值或某个给定值"
如果一个主语的谓语数量大于k，则一行不足以容纳下一个实体，将在下一行存储第k+1到2k个谓语和宾语，以此类推，这种情况叫作溢出。,溢出,包含,主语的谓语数量大于k，则在下一行存储第k+1到2k个谓语和宾语
spill列是溢出标志，即对于一行能存储下的实体，该行spill列为0，对于溢出的实体，该实体所有行的spill列为1。,spill列,包含,溢出标志
例如，在图3-13的dph表中，除实体Android溢出外，其余实体均存储为一行。,dph表,包含,实体Android溢出
例如，在图3-13的dph表中，除实体Android溢出外，其余实体均存储为一行。,dph表,包含,其余实体
对于多值谓语的处理，引入ds（direct_secondary_hash）表。,ds,包含,多值谓语的处理
当dph表中遇到一个多值谓语时，则在相应的宾语处生成一个唯一的id值；将该id值和每个对应的宾语存储为ds表的一行。,dph表,包含,在相应的宾语处生成一个唯一的id值
当dph表中遇到一个多值谓语时，则在相应的宾语处生成一个唯一的id值；将该id值和每个对应的宾语存储为ds表的一行。,dph表,包含,将该id值和每个对应的宾语存储为ds表的一行
例如，在图3-13的dph表中，主语Google的谓语industry（pred1列）是多值谓语，则在其宾语列（val1）存储id值lid:1；在ds表中存储lid:1关联的两个宾语Software和Internet。,Google,包含,多值谓语
例如，在图3-13的dph表中，主语Google的谓语industry（pred1列）是多值谓语，则在其宾语列（val1）存储id值lid:1；在ds表中存储lid:1关联的两个宾语Software和Internet。,dph表,包含,id值lid:1
例如，在图3-13的dph表中，主语Google的谓语industry（pred1列）是多值谓语，则在其宾语列（val1）存储id值lid:1；在ds表中存储lid:1关联的两个宾语Software和Internet。,ds表,包含,lid:1
实际上，dph表实现了列的共享：一方面，不同实体的相同谓语总是会被分配到相同的列上；另一方面，同一列中可以存储多个不同的谓语。,dph表,包含,列的共享
例如，主语Charles_Flint和Larry_Page的谓语founder都被分配到pred3列，该列也存储了主语Android的谓语kernel和graphics。,pred3,包含,主语Charles_Flint和Larry_Page的谓语founder
例如，主语Charles_Flint和Larry_Page的谓语founder都被分配到pred3列，该列也存储了主语Android的谓语kernel和graphics。,pred3,包含,主语Android的谓语kernel
例如，主语Charles_Flint和Larry_Page的谓语founder都被分配到pred3列，该列也存储了主语Android的谓语kernel和graphics。,pred3,包含,主语Android的谓语graphics
正是由于DB2RDF方案具备“列共享”机制，才使得在关系表中最大列数目上限的情况下可以存储远超出该上限的谓语数目，也能够有效地解决水平表方案中存在的谓语稀疏性空值问题。,DB2RDF方案,包含,“列共享”机制
在真实的知识图谱中，不同主语往往具有不同的谓语集合，例如，谓语born只有人才具有，谓语employees只有公司才具有，这也是能够实现列共享的原因所在。,谓语born,包含,不同的人
在真实的知识图谱中，不同主语往往具有不同的谓语集合，例如，谓语born只有人才具有，谓语employees只有公司才具有，这也是能够实现列共享的原因所在。,谓语employees,包含,不同的公司
图3-13DB2RDF方案从图数据模型的角度来看，dph表和ds表实际上存储了实体节点（主语）的出边信息（从主语经谓语到宾语）；为了提高查询处理效率，还需要存储实体节点的入边信息（从宾语经谓语到主语）。,dph表,包含,实体节点主语的出边信息
图3-13DB2RDF方案从图数据模型的角度来看，dph表和ds表实际上存储了实体节点（主语）的出边信息（从主语经谓语到宾语）；为了提高查询处理效率，还需要存储实体节点的入边信息（从宾语经谓语到主语）。,ds表,包含,实体节点主语的出边信息
图3-13DB2RDF方案从图数据模型的角度来看，dph表和ds表实际上存储了实体节点（主语）的出边信息（从主语经谓语到宾语）；为了提高查询处理效率，还需要存储实体节点的入边信息（从宾语经谓语到主语）。,dph表,包含,实体节点宾语的入边信息
图3-13DB2RDF方案从图数据模型的角度来看，dph表和ds表实际上存储了实体节点（主语）的出边信息（从主语经谓语到宾语）；为了提高查询处理效率，还需要存储实体节点的入边信息（从宾语经谓语到主语）。,ds表,包含,实体节点宾语的入边信息
为此，DB2RDF方案提供了rph（reverse_primary_hash）表和rs（reverse_secondary_hash）表，如图3-13所示。,rph表,包含,reverse_primary_hash
为此，DB2RDF方案提供了rph（reverse_primary_hash）表和rs（reverse_secondary_hash）表，如图3-13所示。,rs表,包含,reverse_secondary_hash
DB2RDF方案中SPARQL查询转换为等价的SQL查询如图3-14所示。,DB2RDF方案中SPARQL查询转换为等价的SQL查询,等价,将SPARQL查询转换为等价的SQL查询
DB2RDF方案中SPARQL查询转换为等价的SQL查询如图3-14所示。,DB2RDF方案的SPARQL查询转换为等价的SQL查询,包含,实现
从中可以看出，对于知识图谱的星型查询，DB2RDF存储方案只需要查询dph表即可完成，无须进行连接操作。,DB2RDF存储方案的查询,包含,查询dph表即可完成
图3-14DB2RDF方案中SPARQL查询转换为等价的SQL查询在DB2RDF方案中，谓语到列的映射是需要重点考虑的问题。,谓语到列的映射,等价,需要重点考虑的问题
图3-14DB2RDF方案中SPARQL查询转换为等价的SQL查询在DB2RDF方案中，谓语到列的映射是需要重点考虑的问题。,谓语到列的映射,包含,重点考虑的问题
因为关系表中最大列的数目是固定的，该映射的两个优化目标是：使用的列的数目不要超过某个值m；尽量减少将同一主语的两个不同谓语分配到同一列的情况，从而减少溢出现象，因为溢出会导致查询时发生自连接。,映射的两个优化目标,包含,使用的列的数目不要超过某个值m
因为关系表中最大列的数目是固定的，该映射的两个优化目标是：使用的列的数目不要超过某个值m；尽量减少将同一主语的两个不同谓语分配到同一列的情况，从而减少溢出现象，因为溢出会导致查询时发生自连接。,映射的两个优化目标,包含,尽量减少将同一主语的两个不同谓语分配到同一列的情况
谓语到列映射的一种方法是使用一组散列函数，将谓语映射到一组列编号，并将谓语及其宾语存储到这组列中的第一个空列上；在一个主语对应的一行中，如果存储某谓语（及其宾语）时，散列函数计算得出的这组列中的所有列都被之前存储的该主语的谓语占用了，则产生溢出，到下一行存储该谓语。,谓语到列映射,包含,散列函数
谓语到列映射的一种方法是使用一组散列函数，将谓语映射到一组列编号，并将谓语及其宾语存储到这组列中的第一个空列上；在一个主语对应的一行中，如果存储某谓语（及其宾语）时，散列函数计算得出的这组列中的所有列都被之前存储的该主语的谓语占用了，则产生溢出，到下一行存储该谓语。,谓语到列映射,包含,将谓语映射到一组列编号
谓语到列映射的一种方法是使用一组散列函数，将谓语映射到一组列编号，并将谓语及其宾语存储到这组列中的第一个空列上；在一个主语对应的一行中，如果存储某谓语（及其宾语）时，散列函数计算得出的这组列中的所有列都被之前存储的该主语的谓语占用了，则产生溢出，到下一行存储该谓语。,谓语到列映射,包含,将谓语及其宾语存储到这组列中的第一个空列上
谓语到列映射的一种方法是使用一组散列函数，将谓语映射到一组列编号，并将谓语及其宾语存储到这组列中的第一个空列上；在一个主语对应的一行中，如果存储某谓语（及其宾语）时，散列函数计算得出的这组列中的所有列都被之前存储的该主语的谓语占用了，则产生溢出，到下一行存储该谓语。,谓语到列映射,包含,产生溢出
谓语到列映射的一种方法是使用一组散列函数，将谓语映射到一组列编号，并将谓语及其宾语存储到这组列中的第一个空列上；在一个主语对应的一行中，如果存储某谓语（及其宾语）时，散列函数计算得出的这组列中的所有列都被之前存储的该主语的谓语占用了，则产生溢出，到下一行存储该谓语。,谓语到列映射,包含,到下一行存储该谓语
例如，表3-4给出了谓语到列映射的散列函数表，其中包括h2两个散列函数，映射了5个谓语到列编号组。,表3-4,包含,散列函数表
表3-4谓语到列映射的散列函数表如果可以事先获取知识图谱的一个子集，则可以利用知识图谱的内在结构优化谓语到列的映射。,谓语到列的映射,包含,知识图谱的内在结构
方法是将谓语到列的映射转化为图着色（Graph_Coloring）问题[31]。,方法,包含,将谓语到列的映射转化为图着色（Graph_Coloring）问题
将一个主语上出现的不同谓语称为共现谓语（Co-occurrence_Predicates），目标是让共现谓语着上不同颜色（映射到不同列中），非共现谓语可以着上相同颜色（映射到同一列中）。,共现谓语,包含,将一个主语上出现的不同谓语称为共现谓语
将一个主语上出现的不同谓语称为共现谓语（Co-occurrence_Predicates），目标是让共现谓语着上不同颜色（映射到不同列中），非共现谓语可以着上相同颜色（映射到同一列中）。,非共现谓语,包含,让非共现谓语着上相同颜色
为此，构建图着色算法的冲突图（Interference_Graph）：图中节点为知识图谱中的所有谓语；每对共现谓语节点之间由一条边相连。,图着色算法的冲突图,包含,谓语
图着色问题的要求是为冲突图中的节点着上颜色，使得每个节点的颜色不同于其任一邻接节点的颜色，并使所用颜色数最少；对应到谓语映射问题，即为冲突图中的谓语节点分配列，使得每个谓语映射到的列不同于其任一共现谓语映射到的列，并使所用的列数目最少。,图着色问题的要求,包含,为冲突图中的节点着上颜色
图着色问题的要求是为冲突图中的节点着上颜色，使得每个节点的颜色不同于其任一邻接节点的颜色，并使所用颜色数最少；对应到谓语映射问题，即为冲突图中的谓语节点分配列，使得每个谓语映射到的列不同于其任一共现谓语映射到的列，并使所用的列数目最少。,谓语映射问题,包含,为冲突图中的谓语节点分配列
可见，对于13个谓语，仅使用了5种颜色，即只需使用5列。,颜色,包含,谓语
需要指出的是，图着色是经典的NP难问题，对于规模较大的冲突图可用贪心算法（如Welsh-Powell算法）[32]求得近似解。,贪心算法,包含,图着色
图3-15冲突图如果在大规模真实知识图谱（如DBpedia）中，图着色所需颜色数量超过了关系数据表的列数上限m，则根据某种策略（如最频繁使用的前k个谓语）选取一个谓语子集，使得该谓语子集到列的映射满足图着色要求；对于不在该子集中的谓语，再使用前面提到的散列函数组策略进行映射。,图着色,包含,谓语子集
3.2.2面向RDF的三元组数据库由于RDF是W3C推荐的表示语义网上关联数据（Linked_Data）的标准格式，RDF也是表示和发布Web上知识图谱的最主要数据格式之一。,三元组数据库,包含,RDF
面向RDF的三元组数据库是专门为存储大规模RDF数据而开发的知识图谱数据库，其支持RDF的标准查询语言SPARQL。,面向RDF的三元组数据库,包含,RDF的标准查询语言SPARQL
主要的开源RDF三元组数据库包括：Apache旗下的Jena、Eclipse旗下的RDF4J以及源自学术界的RDF-3X和gStore；主要的商业RDF三元组数据库包括：Virtuoso、AllegroGraph、GraphDB和BlazeGraph。,Apache旗下的Jena,包含,开源RDF三元组数据库
主要的开源RDF三元组数据库包括：Apache旗下的Jena、Eclipse旗下的RDF4J以及源自学术界的RDF-3X和gStore；主要的商业RDF三元组数据库包括：Virtuoso、AllegroGraph、GraphDB和BlazeGraph。,Eclipse旗下的RDF4J,包含,开源RDF三元组数据库
主要的开源RDF三元组数据库包括：Apache旗下的Jena、Eclipse旗下的RDF4J以及源自学术界的RDF-3X和gStore；主要的商业RDF三元组数据库包括：Virtuoso、AllegroGraph、GraphDB和BlazeGraph。,源自学术界的RDF-3X,包含,开源RDF三元组数据库
主要的开源RDF三元组数据库包括：Apache旗下的Jena、Eclipse旗下的RDF4J以及源自学术界的RDF-3X和gStore；主要的商业RDF三元组数据库包括：Virtuoso、AllegroGraph、GraphDB和BlazeGraph。,源自学术界的gStore,包含,开源RDF三元组数据库
主要的开源RDF三元组数据库包括：Apache旗下的Jena、Eclipse旗下的RDF4J以及源自学术界的RDF-3X和gStore；主要的商业RDF三元组数据库包括：Virtuoso、AllegroGraph、GraphDB和BlazeGraph。,Virtuoso,包含,主要的商业RDF三元组数据库
主要的开源RDF三元组数据库包括：Apache旗下的Jena、Eclipse旗下的RDF4J以及源自学术界的RDF-3X和gStore；主要的商业RDF三元组数据库包括：Virtuoso、AllegroGraph、GraphDB和BlazeGraph。,AllegroGraph,包含,主要的商业RDF三元组数据库
主要的开源RDF三元组数据库包括：Apache旗下的Jena、Eclipse旗下的RDF4J以及源自学术界的RDF-3X和gStore；主要的商业RDF三元组数据库包括：Virtuoso、AllegroGraph、GraphDB和BlazeGraph。,GraphDB,包含,主要的商业RDF三元组数据库
主要的开源RDF三元组数据库包括：Apache旗下的Jena、Eclipse旗下的RDF4J以及源自学术界的RDF-3X和gStore；主要的商业RDF三元组数据库包括：Virtuoso、AllegroGraph、GraphDB和BlazeGraph。,BlazeGraph,包含,主要的商业RDF三元组数据库
1.开源RDF三元组数据库RDF4JRDF4J目前是Eclipse基金会旗下的开源孵化项目，其前身是荷兰软件公司Aduna开发的Sesame框架。,RDF4J,包含,开源RDF三元组数据库RDF4J
Sesame框架的历史可以追溯到1999年，当时作为Aduna公司的一个语义Web项目进行开发，后来发展成为语义Web领域一个非常有名的管理和处理RDF的开源Java框架，功能包括RDF数据的解析、存储、推理和查询等。,Sesame,包含,RDF数据的解析功能
Sesame框架的历史可以追溯到1999年，当时作为Aduna公司的一个语义Web项目进行开发，后来发展成为语义Web领域一个非常有名的管理和处理RDF的开源Java框架，功能包括RDF数据的解析、存储、推理和查询等。,Sesame,包含,RDF数据的存储功能
Sesame框架的历史可以追溯到1999年，当时作为Aduna公司的一个语义Web项目进行开发，后来发展成为语义Web领域一个非常有名的管理和处理RDF的开源Java框架，功能包括RDF数据的解析、存储、推理和查询等。,Sesame,包含,RDF数据的推理功能
Sesame框架的历史可以追溯到1999年，当时作为Aduna公司的一个语义Web项目进行开发，后来发展成为语义Web领域一个非常有名的管理和处理RDF的开源Java框架，功能包括RDF数据的解析、存储、推理和查询等。,Sesame,包含,RDF数据的查询功能
2016年5月，Sesame框架改名为RDF4J，并迁移为Eclipse开源项目继续开发。,RDF4J,包含,Eclipse开源项目继续开发
RDF4J本身提供内存和磁盘两种RDF存储机制，支持全部的SPARQL1.1查询和更新语言，可以使用与访问本地RDF库相同的API访问远程RDF库，支持所有主流RDF数据格式，包括RDF/XML、Turtle、N-Triples、N-Quads、JSON-LD、TriG和TriX。,RDF4J,包含,内存RDF存储机制
RDF4J本身提供内存和磁盘两种RDF存储机制，支持全部的SPARQL1.1查询和更新语言，可以使用与访问本地RDF库相同的API访问远程RDF库，支持所有主流RDF数据格式，包括RDF/XML、Turtle、N-Triples、N-Quads、JSON-LD、TriG和TriX。,RDF4J,包含,磁盘RDF存储机制
图3-16RDF4J的高层架构图（1）底层的RDF模型定义了URI、空节点（Blank_Node）、字面值（Literal）和语句（Statement）等RDF基本元素。,RDF模型,包含,URI、空节点（Blank_Node）、字面值（Literal）和语句（Statement）等RDF基本元素
（2）Rio代表“RDF_I/O”，即RDF输入/输出，包括各种RDF文件格式的解析器（Parser）和编写器（Writer），解析器负责将RDF文件解析为RDF模型中的三元组语句，编写器负责将三元组语句写为RDF文件。,Rio,包含,各种RDF文件格式的解析器（Parser）
（2）Rio代表“RDF_I/O”，即RDF输入/输出，包括各种RDF文件格式的解析器（Parser）和编写器（Writer），解析器负责将RDF文件解析为RDF模型中的三元组语句，编写器负责将三元组语句写为RDF文件。,Rio,包含,编写器（Writer）
（3）Sail_API代表“存储和推理层API”（Storage_And_Inference_Layer_API），是实现RDF存储和推理的底层系统（System）API（即SPI），其作用是将RDF存储和推理功能从底层实现细节中抽象出来，使得底层存储和推理实现模块可以透明地被替换；Sail_API是SAIL底层存储开发者需要实现的API，普通用户无须关心；RDF4J自带了两种SailAPI实现，即基于内存的MemoryStore和基于磁盘的NativeStore。,Sail_API,包含,“存储和推理层API”（Storage_And_Inference_Layer_API）
（3）Sail_API代表“存储和推理层API”（Storage_And_Inference_Layer_API），是实现RDF存储和推理的底层系统（System）API（即SPI），其作用是将RDF存储和推理功能从底层实现细节中抽象出来，使得底层存储和推理实现模块可以透明地被替换；Sail_API是SAIL底层存储开发者需要实现的API，普通用户无须关心；RDF4J自带了两种SailAPI实现，即基于内存的MemoryStore和基于磁盘的NativeStore。,Sail_API,包含,实现RDF存储和推理的底层系统（System）API（即SPI）
（3）Sail_API代表“存储和推理层API”（Storage_And_Inference_Layer_API），是实现RDF存储和推理的底层系统（System）API（即SPI），其作用是将RDF存储和推理功能从底层实现细节中抽象出来，使得底层存储和推理实现模块可以透明地被替换；Sail_API是SAIL底层存储开发者需要实现的API，普通用户无须关心；RDF4J自带了两种SailAPI实现，即基于内存的MemoryStore和基于磁盘的NativeStore。,Sail_API,包含,将RDF存储和推理功能从底层实现细节中抽象出来
（3）Sail_API代表“存储和推理层API”（Storage_And_Inference_Layer_API），是实现RDF存储和推理的底层系统（System）API（即SPI），其作用是将RDF存储和推理功能从底层实现细节中抽象出来，使得底层存储和推理实现模块可以透明地被替换；Sail_API是SAIL底层存储开发者需要实现的API，普通用户无须关心；RDF4J自带了两种SailAPI实现，即基于内存的MemoryStore和基于磁盘的NativeStore。,Sail_API,包含,使得底层存储和推理实现模块可以透明地被替换
（3）Sail_API代表“存储和推理层API”（Storage_And_Inference_Layer_API），是实现RDF存储和推理的底层系统（System）API（即SPI），其作用是将RDF存储和推理功能从底层实现细节中抽象出来，使得底层存储和推理实现模块可以透明地被替换；Sail_API是SAIL底层存储开发者需要实现的API，普通用户无须关心；RDF4J自带了两种SailAPI实现，即基于内存的MemoryStore和基于磁盘的NativeStore。,Sail_API,包含,SAIL底层存储开发者需要实现的API
（3）Sail_API代表“存储和推理层API”（Storage_And_Inference_Layer_API），是实现RDF存储和推理的底层系统（System）API（即SPI），其作用是将RDF存储和推理功能从底层实现细节中抽象出来，使得底层存储和推理实现模块可以透明地被替换；Sail_API是SAIL底层存储开发者需要实现的API，普通用户无须关心；RDF4J自带了两种SailAPI实现，即基于内存的MemoryStore和基于磁盘的NativeStore。,Sail_API,包含,普通用户无须关心
（3）Sail_API代表“存储和推理层API”（Storage_And_Inference_Layer_API），是实现RDF存储和推理的底层系统（System）API（即SPI），其作用是将RDF存储和推理功能从底层实现细节中抽象出来，使得底层存储和推理实现模块可以透明地被替换；Sail_API是SAIL底层存储开发者需要实现的API，普通用户无须关心；RDF4J自带了两种SailAPI实现，即基于内存的MemoryStore和基于磁盘的NativeStore。,RDF4J,包含,基于内存的MemoryStore
（3）Sail_API代表“存储和推理层API”（Storage_And_Inference_Layer_API），是实现RDF存储和推理的底层系统（System）API（即SPI），其作用是将RDF存储和推理功能从底层实现细节中抽象出来，使得底层存储和推理实现模块可以透明地被替换；Sail_API是SAIL底层存储开发者需要实现的API，普通用户无须关心；RDF4J自带了两种SailAPI实现，即基于内存的MemoryStore和基于磁盘的NativeStore。,RDF4J,包含,基于磁盘的NativeStore
（4）存储库API（Repository_API）是用户使用的RDF管理和处理高层API，提供RDF的存储、查询和推理等服务，面向终端用户，简单易用；存储库API的一种实现是基于本地SAIL实现的SailRepository，另一种是基于远程HTTP服务器实现的HttpRepository。,存储库API,包含,基于本地SAIL实现的SailRepository
（4）存储库API（Repository_API）是用户使用的RDF管理和处理高层API，提供RDF的存储、查询和推理等服务，面向终端用户，简单易用；存储库API的一种实现是基于本地SAIL实现的SailRepository，另一种是基于远程HTTP服务器实现的HttpRepository。,存储库API,包含,基于远程HTTP服务器实现的HttpRepository
（5）架构图的顶层是用户开发的应用程序和HTTP服务器，用户应用程序直接调用存储库API;HTTP服务器实现了通过HTTP访问存储库API的Web服务，可通过HttpClient库与HTTP服务器进行远程通信，从而访问远程RDF4J存储库。,HTTP服务器,包含,通过HTTP访问存储库API的Web服务
正是由于RDF4J规范的模块化设计，使其成为很多其他RDF三元组数据库（如GraphDB）的上层标准框架，这些三元组库只需要实现各自的SAIL_API，依赖于RDF4J存储库API的应用程序而无须修改，便可以在不同的三元组库之间实现透明切换。,RDF4J规范的模块化设计,包含,很多其他RDF三元组数据库（如GraphDB）的上层标准框架
目前，RDF-3X只支持Linux系统。,RDF-3X,包含,Linux系统
RDF-3X的最大特点在于其为RDF数据精心打造的压缩物理存储方案、查询处理和查询优化技术。,RDF-3X,包含,为RDF数据精心打造的压缩物理存储方案、查询处理和查询优化技术
在逻辑存储上，虽然以简单的三元组表为基础，但首次提出全索引方案：建立6种三元组索引spo、sop、osp、ops、pso和pos；建立6种二元聚合索引sp、ps、so、os、po和op；建立3种一元聚合索引s、p、o。,全索引方案,包含,spo索引
在逻辑存储上，虽然以简单的三元组表为基础，但首次提出全索引方案：建立6种三元组索引spo、sop、osp、ops、pso和pos；建立6种二元聚合索引sp、ps、so、os、po和op；建立3种一元聚合索引s、p、o。,全索引方案,包含,sop索引
在逻辑存储上，虽然以简单的三元组表为基础，但首次提出全索引方案：建立6种三元组索引spo、sop、osp、ops、pso和pos；建立6种二元聚合索引sp、ps、so、os、po和op；建立3种一元聚合索引s、p、o。,全索引方案,包含,osp索引
在逻辑存储上，虽然以简单的三元组表为基础，但首次提出全索引方案：建立6种三元组索引spo、sop、osp、ops、pso和pos；建立6种二元聚合索引sp、ps、so、os、po和op；建立3种一元聚合索引s、p、o。,全索引方案,包含,ops索引
在逻辑存储上，虽然以简单的三元组表为基础，但首次提出全索引方案：建立6种三元组索引spo、sop、osp、ops、pso和pos；建立6种二元聚合索引sp、ps、so、os、po和op；建立3种一元聚合索引s、p、o。,全索引方案,包含,pso索引
在逻辑存储上，虽然以简单的三元组表为基础，但首次提出全索引方案：建立6种三元组索引spo、sop、osp、ops、pso和pos；建立6种二元聚合索引sp、ps、so、os、po和op；建立3种一元聚合索引s、p、o。,全索引方案,包含,pos索引
在逻辑存储上，虽然以简单的三元组表为基础，但首次提出全索引方案：建立6种三元组索引spo、sop、osp、ops、pso和pos；建立6种二元聚合索引sp、ps、so、os、po和op；建立3种一元聚合索引s、p、o。,索引,包含,sp索引
在逻辑存储上，虽然以简单的三元组表为基础，但首次提出全索引方案：建立6种三元组索引spo、sop、osp、ops、pso和pos；建立6种二元聚合索引sp、ps、so、os、po和op；建立3种一元聚合索引s、p、o。,索引,包含,ps索引
在逻辑存储上，虽然以简单的三元组表为基础，但首次提出全索引方案：建立6种三元组索引spo、sop、osp、ops、pso和pos；建立6种二元聚合索引sp、ps、so、os、po和op；建立3种一元聚合索引s、p、o。,索引,包含,so索引
在逻辑存储上，虽然以简单的三元组表为基础，但首次提出全索引方案：建立6种三元组索引spo、sop、osp、ops、pso和pos；建立6种二元聚合索引sp、ps、so、os、po和op；建立3种一元聚合索引s、p、o。,索引,包含,os索引
在逻辑存储上，虽然以简单的三元组表为基础，但首次提出全索引方案：建立6种三元组索引spo、sop、osp、ops、pso和pos；建立6种二元聚合索引sp、ps、so、os、po和op；建立3种一元聚合索引s、p、o。,索引,包含,po索引
在逻辑存储上，虽然以简单的三元组表为基础，但首次提出全索引方案：建立6种三元组索引spo、sop、osp、ops、pso和pos；建立6种二元聚合索引sp、ps、so、os、po和op；建立3种一元聚合索引s、p、o。,索引,包含,op索引
在物理存储上，采用基于B+树的压缩方案：使用字典快速查找表建立RDF字符串到整数id的映射；使用面向字节的增量编码B+树页面内部，不会跨越不同页压缩技术，实现三元组的压缩存放；三元组压缩限于面，避免了不必要的解压缩操作，能够提高查询效率。,压缩技术的压缩存放,包含,三元组的压缩存放
在物理存储上，采用基于B+树的压缩方案：使用字典快速查找表建立RDF字符串到整数id的映射；使用面向字节的增量编码B+树页面内部，不会跨越不同页压缩技术，实现三元组的压缩存放；三元组压缩限于面，避免了不必要的解压缩操作，能够提高查询效率。,压缩技术的查询效率,包含,避免不必要的解压缩操作
借助巧妙设计的三元组压缩技术，全索引方案的空间开销是可以接受的，全索引为查询处理和优化带来了巨大便利。,全索引,包含,查询处理和优化带来便利
"如图3-18所示，利用spo索引查找三元组模式(Albert_Einstein,invented,?x),spo索引中存储的是已经进行字典编码之后的由整数id值组成的(s,p,o)三元组，并且已按照s、p、o值由小到大的顺序进行了排序。",spo索引,包含,"查找三元组模式(Albert_Einstein,invented,?x)"
图3-18使用spo索引进行三元组模式查找RDF-3X的查询处理器首先对SPARQL查询进行转化，生成若干查询执行计划；对于仅包含一个三元组模式的查询，可以通过一次相应索引查找操作完成；对于由多个三元组模式组成的查询，需要对多个连接的顺序进行优化。,RDF-3X的查询处理器,包含,对SPARQL查询进行转化，生成若干查询执行计划
RDF-3X采用的是一种自底向上的动态规划优化算法，其优化过程充分考虑了SPARQL查询的特点，并且最大限度地保持了有利于用全索引方案进行归并连接的连接顺序。,RDF-3X,包含,自底向上的动态规划优化算法
同时，RDF-3X还开发了基于代价模型的选择度评估（Selectivity_Estimates）机制，采用选择度直方图和频繁连接路径相结合的方法进行查询执行计划的选择度评估。,RDF-3X,包含,基于代价模型的选择度评估
gStore将RDF图G中的每个实体节点及其邻居属性和属性值编码成一个二进制位串，由这些位串作为节点组成一张与RDF图G对应的标签图G*。,gStore,包含,编码每个实体节点及其邻居属性和属性值
在执行SPARQL查询时，将查询图Q也转化为一张查询的标签图Q*。,查询图Q,包含,查询标签图Q*
gStore的研究工作已经证明了Q*在G*上的匹配是Q在G上匹配的超集。,Q*,包含,Q在G上匹配的超集
gStore的研究工作已经证明了Q*在G*上的匹配是Q在G上匹配的超集。,G*,包含,Q*在G*上的匹配
为了支持在G*上快速地查找到Q*的匹配位置，gStore系统提出建立“VS树”索引，其基本思想实际上是为标签图G*建立不同详细程度的摘要图（summary_graph）；利用“VS”树索引提供的摘要图，gStore系统提出可以大幅削减SPARQL查询的搜索空间，加快查询速度。,gStore系统,包含,为标签图G*建立不同详细程度的摘要图
为了支持在G*上快速地查找到Q*的匹配位置，gStore系统提出建立“VS树”索引，其基本思想实际上是为标签图G*建立不同详细程度的摘要图（summary_graph）；利用“VS”树索引提供的摘要图，gStore系统提出可以大幅削减SPARQL查询的搜索空间，加快查询速度。,gStore系统,包含,利用“VS”树索引提供的摘要图
为了支持在G*上快速地查找到Q*的匹配位置，gStore系统提出建立“VS树”索引，其基本思想实际上是为标签图G*建立不同详细程度的摘要图（summary_graph）；利用“VS”树索引提供的摘要图，gStore系统提出可以大幅削减SPARQL查询的搜索空间，加快查询速度。,gStore系统,包含,可以大幅削减SPARQL查询的搜索空间
为了支持在G*上快速地查找到Q*的匹配位置，gStore系统提出建立“VS树”索引，其基本思想实际上是为标签图G*建立不同详细程度的摘要图（summary_graph）；利用“VS”树索引提供的摘要图，gStore系统提出可以大幅削减SPARQL查询的搜索空间，加快查询速度。,gStore系统,包含,加快查询速度
目前，gStore已经作为开源项目发布，源代码和文档可以从其GitHub项目网站下载。,gStore,包含,开源项目
与RDF-3X一样，gStore只能在Linux系统上运行。,gStore,包含,Linux系统
关于gStore内部实现的详细信息可参见文献[33]。,gStore,包含,内部实现的详细信息
Virtuoso同时发布了商业版本VirtuosoUniversalServer（Virtuoso统一服务器）和开源版本OpenLinkVirtuoso。,Virtuoso,包含,商业版本VirtuosoUniversalServer
Virtuoso同时发布了商业版本VirtuosoUniversalServer（Virtuoso统一服务器）和开源版本OpenLinkVirtuoso。,Virtuoso,包含,开源版本OpenLinkVirtuoso
图3-21使用Virtuoso进行SPARQL查询5.商业RDF三元组数据库AllegroGraphAllegroGraph是Franz公司开发的RDF三元组数据库。,AllegroGraph,包含,RDF三元组数据库
由于Franz公司有着深厚的人工智能背景，早期一直开发Common_Lisp和Prolog语言的实现工具，这使得AllegroGraph对语义推理功能具有较为完善的支持。,AllegroGraph,包含,语义推理功能
AllegroGraph除了三元组数据库的基本功能外，还支持动态物化的RDFS++推理机、OWL2_RL推理机、Prolog规则推理系统、时空推理机制、社会网络分析库、可视化RDF图浏览器等。,AllegroGraph,包含,动态物化的RDFS++推理机
AllegroGraph除了三元组数据库的基本功能外，还支持动态物化的RDFS++推理机、OWL2_RL推理机、Prolog规则推理系统、时空推理机制、社会网络分析库、可视化RDF图浏览器等。,AllegroGraph,包含,OWL2_RL推理机
AllegroGraph除了三元组数据库的基本功能外，还支持动态物化的RDFS++推理机、OWL2_RL推理机、Prolog规则推理系统、时空推理机制、社会网络分析库、可视化RDF图浏览器等。,AllegroGraph,包含,Prolog规则推理系统
AllegroGraph除了三元组数据库的基本功能外，还支持动态物化的RDFS++推理机、OWL2_RL推理机、Prolog规则推理系统、时空推理机制、社会网络分析库、可视化RDF图浏览器等。,AllegroGraph,包含,时空推理机制
AllegroGraph除了三元组数据库的基本功能外，还支持动态物化的RDFS++推理机、OWL2_RL推理机、Prolog规则推理系统、时空推理机制、社会网络分析库、可视化RDF图浏览器等。,AllegroGraph,包含,社会网络分析库
AllegroGraph除了三元组数据库的基本功能外，还支持动态物化的RDFS++推理机、OWL2_RL推理机、Prolog规则推理系统、时空推理机制、社会网络分析库、可视化RDF图浏览器等。,AllegroGraph,包含,可视化RDF图浏览器
同时，AllegroGraph支持Java、Python、C#、Ruby、Clojure/Scala、Lisp等多种语言的编程访问接口。,AllegroGraph,包含,Java、Python、C#、Ruby、Clojure/Scala、Lisp
6.商业RDF三元组数据库GraphDBGraphDB是RDF三元组数据库，其前身OWLIM一直是支持W3C语义Web标准的主流产品。,GraphDB,包含,RDF三元组数据库
GraphDB目前有社区免费版、标准版和企业版，其中企业版支持多台机器的集群分布式部署。,GraphDB,包含,社区免费版
GraphDB目前有社区免费版、标准版和企业版，其中企业版支持多台机器的集群分布式部署。,GraphDB,包含,标准版
GraphDB目前有社区免费版、标准版和企业版，其中企业版支持多台机器的集群分布式部署。,GraphDB,包含,企业版
图3-26GraphDB的高层架构对于GraphDB的各部分组件自顶向下进行介绍：（1）Workbench是GraphDB的Web管理工具；（2）Engine是查询处理和推理引擎，由查询优化器（Query_Optimiser）、推理机（Reasoner）、存储层（Storage）和插件管理器（Plugin_Manager）组成；●查询优化器能够在多种查询执行计划中挑选出较高效的一种，查询经过解析后会交由查询优化器进行优化；●推理机执行基于RDF规则的前向链推理，由显式三元组推导出全部导出三元组，导出三元组会随显式三元组的更新而同步更新；●存储层使用pos和pso两种三元组索引、psco和pocs两种带有上下文信息的四元组索引以及字面值（Literal）索引存储RDF数据；实体池（Entity_Pool）是GraphDB存储层的核心部件，起到将RDF实体（URI、空节点和字面值）映射到内部整数ID的字典编码器的作用，同时还实现了对事务管理的支持机制。,GraphDB,包含,Workbench
图3-26GraphDB的高层架构对于GraphDB的各部分组件自顶向下进行介绍：（1）Workbench是GraphDB的Web管理工具；（2）Engine是查询处理和推理引擎，由查询优化器（Query_Optimiser）、推理机（Reasoner）、存储层（Storage）和插件管理器（Plugin_Manager）组成；●查询优化器能够在多种查询执行计划中挑选出较高效的一种，查询经过解析后会交由查询优化器进行优化；●推理机执行基于RDF规则的前向链推理，由显式三元组推导出全部导出三元组，导出三元组会随显式三元组的更新而同步更新；●存储层使用pos和pso两种三元组索引、psco和pocs两种带有上下文信息的四元组索引以及字面值（Literal）索引存储RDF数据；实体池（Entity_Pool）是GraphDB存储层的核心部件，起到将RDF实体（URI、空节点和字面值）映射到内部整数ID的字典编码器的作用，同时还实现了对事务管理的支持机制。,GraphDB,包含,Engine
（3）Connectors是GraphDB连接外部工具的桥梁，包括用于建立快速关键字查找功能的Lucene和用于建立搜索引擎的Solr和Elasticsearch。,Connectors,包含,Lucene
（3）Connectors是GraphDB连接外部工具的桥梁，包括用于建立快速关键字查找功能的Lucene和用于建立搜索引擎的Solr和Elasticsearch。,Connectors,包含,Solr
（3）Connectors是GraphDB连接外部工具的桥梁，包括用于建立快速关键字查找功能的Lucene和用于建立搜索引擎的Solr和Elasticsearch。,Connectors,包含,Elasticsearch
（4）插件管理器在Engine内起到插件管理作用，既包括GraphDB内部实现的插件，也包括各种外部工具连接器。,插件管理器,包含,GraphDB内部实现的插件
（4）插件管理器在Engine内起到插件管理作用，既包括GraphDB内部实现的插件，也包括各种外部工具连接器。,插件管理器,包含,各种外部工具连接器
7.商业RDF三元组数据库BlazegraphBlazegraph在1.5版本之前叫作Bigdata，但众所周知的“大数据”的兴起使得这个不温不火的RDF三元组库软件被淹没其中。,Blazegraph,包含,Bigdata
但这个软件在“大数据”兴起前很多年就叫Bigdata，迫不得已改名叫Blazegraph之后，其开发理念也有所调整。,Bigdata,包含,开发理念
但这个软件在“大数据”兴起前很多年就叫Bigdata，迫不得已改名叫Blazegraph之后，其开发理念也有所调整。,Blazegraph,包含,开发理念
原来仅仅是支持RDF三元组存储和SPARQL，现在已经定位为全面支持Blueprints标准的图数据库。,图数据库,包含,支持RDF三元组存储和SPARQL
原来仅仅是支持RDF三元组存储和SPARQL，现在已经定位为全面支持Blueprints标准的图数据库。,图数据库,包含,全面支持Blueprints标准的图数据库
不过，其内部实现技术仍是面向RDF三元组和SPARQL的，因而可以理解为是“基于RDF三元组库的图数据库”。,图数据库,包含,面向RDF三元组和SPARQL的
从2006年发布至今，Blazegraph一直由SYSTAP公司开发，虽然它既不是最知名的RDF三元组库，也不是最流行的图数据库，但开发进展稳扎稳打，积累了相对全面的功能。,Blazegraph,包含,开发进展
Blazegraph可以通过其官方网站下载。,Blazegraph,包含,官方网站下载
图3-27Blazegraph的Web用户界面8.商业RDF三元组数据库StardogStardog是由美国Stardog_Union公司开发的RDF三元组数据库，其首个公开发布版本是2012年2月发布的Stardog_0.9。,Stardog,包含,RDF三元组数据库
Stardog支持RDF图数据模型、SPARQL查询语言、属性图模型、Gremlin图遍历语言、OWL2标准、用户自定义的推理与数据分析规则、虚拟图、地理空间查询以及多种编程语言与网络接口支持。,Stardog,包含,RDF图数据模型
Stardog支持RDF图数据模型、SPARQL查询语言、属性图模型、Gremlin图遍历语言、OWL2标准、用户自定义的推理与数据分析规则、虚拟图、地理空间查询以及多种编程语言与网络接口支持。,Stardog,包含,SPARQL查询语言
Stardog支持RDF图数据模型、SPARQL查询语言、属性图模型、Gremlin图遍历语言、OWL2标准、用户自定义的推理与数据分析规则、虚拟图、地理空间查询以及多种编程语言与网络接口支持。,Stardog,包含,属性图模型
Stardog支持RDF图数据模型、SPARQL查询语言、属性图模型、Gremlin图遍历语言、OWL2标准、用户自定义的推理与数据分析规则、虚拟图、地理空间查询以及多种编程语言与网络接口支持。,Stardog,包含,Gremlin图遍历语言
Stardog支持RDF图数据模型、SPARQL查询语言、属性图模型、Gremlin图遍历语言、OWL2标准、用户自定义的推理与数据分析规则、虚拟图、地理空间查询以及多种编程语言与网络接口支持。,Stardog,包含,OWL2标准
Stardog支持RDF图数据模型、SPARQL查询语言、属性图模型、Gremlin图遍历语言、OWL2标准、用户自定义的推理与数据分析规则、虚拟图、地理空间查询以及多种编程语言与网络接口支持。,Stardog,包含,用户自定义的推理与数据分析规则
Stardog支持RDF图数据模型、SPARQL查询语言、属性图模型、Gremlin图遍历语言、OWL2标准、用户自定义的推理与数据分析规则、虚拟图、地理空间查询以及多种编程语言与网络接口支持。,Stardog,包含,虚拟图
Stardog支持RDF图数据模型、SPARQL查询语言、属性图模型、Gremlin图遍历语言、OWL2标准、用户自定义的推理与数据分析规则、虚拟图、地理空间查询以及多种编程语言与网络接口支持。,Stardog,包含,地理空间查询
Stardog支持RDF图数据模型、SPARQL查询语言、属性图模型、Gremlin图遍历语言、OWL2标准、用户自定义的推理与数据分析规则、虚拟图、地理空间查询以及多种编程语言与网络接口支持。,Stardog,包含,多种编程语言与网络接口支持
虽然Stardog发布较晚，但其对OWL2推理机制具有良好的支持，同时具备全文搜索、GraphQL查询、路径查询、融合机器学习任务等功能，能够支持多种不同编程语言和Web访问接口，使得Stardog成为一个知识图谱数据存储和查询平台。,Stardog,包含,全文搜索
虽然Stardog发布较晚，但其对OWL2推理机制具有良好的支持，同时具备全文搜索、GraphQL查询、路径查询、融合机器学习任务等功能，能够支持多种不同编程语言和Web访问接口，使得Stardog成为一个知识图谱数据存储和查询平台。,Stardog,包含,GraphQL查询
虽然Stardog发布较晚，但其对OWL2推理机制具有良好的支持，同时具备全文搜索、GraphQL查询、路径查询、融合机器学习任务等功能，能够支持多种不同编程语言和Web访问接口，使得Stardog成为一个知识图谱数据存储和查询平台。,Stardog,包含,路径查询
虽然Stardog发布较晚，但其对OWL2推理机制具有良好的支持，同时具备全文搜索、GraphQL查询、路径查询、融合机器学习任务等功能，能够支持多种不同编程语言和Web访问接口，使得Stardog成为一个知识图谱数据存储和查询平台。,Stardog,包含,融合机器学习任务的功能
虽然Stardog发布较晚，但其对OWL2推理机制具有良好的支持，同时具备全文搜索、GraphQL查询、路径查询、融合机器学习任务等功能，能够支持多种不同编程语言和Web访问接口，使得Stardog成为一个知识图谱数据存储和查询平台。,Stardog,包含,多种不同编程语言
虽然Stardog发布较晚，但其对OWL2推理机制具有良好的支持，同时具备全文搜索、GraphQL查询、路径查询、融合机器学习任务等功能，能够支持多种不同编程语言和Web访问接口，使得Stardog成为一个知识图谱数据存储和查询平台。,Stardog,包含,Web访问接口
虽然Stardog发布较晚，但其对OWL2推理机制具有良好的支持，同时具备全文搜索、GraphQL查询、路径查询、融合机器学习任务等功能，能够支持多种不同编程语言和Web访问接口，使得Stardog成为一个知识图谱数据存储和查询平台。,知识图谱数据存储和查询平台,包含,知识图谱数据存储和查询平台
Stardog分为企业版和社区版，社区版可以免费用于非商业用途。,Stardog,包含,企业版
Stardog分为企业版和社区版，社区版可以免费用于非商业用途。,Stardog,包含,社区版
3.2.3原生图数据库1.最流行的图数据库Neo4jNeo4j的1.0版本发布于2010年。,Neo4j,包含,最流行的图数据库
Neo4j基于属性图模型，其存储管理层为属性图结构中的节点、节点属性、边、边属性等设计了专门的存储方案。,Neo4j,包含,属性图模型
Neo4j基于属性图模型，其存储管理层为属性图结构中的节点、节点属性、边、边属性等设计了专门的存储方案。,Neo4j,包含,存储管理层
Neo4j基于属性图模型，其存储管理层为属性图结构中的节点、节点属性、边、边属性等设计了专门的存储方案。,属性图结构,包含,节点
Neo4j基于属性图模型，其存储管理层为属性图结构中的节点、节点属性、边、边属性等设计了专门的存储方案。,属性图结构,包含,节点属性
Neo4j基于属性图模型，其存储管理层为属性图结构中的节点、节点属性、边、边属性等设计了专门的存储方案。,属性图结构,包含,边
Neo4j基于属性图模型，其存储管理层为属性图结构中的节点、节点属性、边、边属性等设计了专门的存储方案。,属性图结构,包含,边属性
这使得Neo4j在存储层对于图数据的存取效率天生就优于关系数据库。,Neo4j,包含,对于图数据的存取效率
同时，Neo4j还具备OLTP数据库必需的ACID事务处理功能。,Neo4j,包含,ACID事务处理功能
Neo4j的不足之处在于其社区版是单机系统，虽然Neo4j企业版支持高可用性（HighAvailability）集群，但其与分布式图存储系统的最大区别在于每个节点上存储图数据库的完整副本（类似于关系数据库镜像的副本集群），不是将图数据划分为子图进行分布式存储，并非真正意义上的分布式数据库系统。,Neo4j的不足之处,包含,单机系统
如果图数据超过一定规模，系统性能就会因为磁盘、内存等限制而大幅降低。,图数据库,包含,图数据超过一定规模，系统性能就会因为磁盘、内存等限制而大幅降低
开发者注册信息后可以免费下载Neo4j桌面打包安装版（Neo4j_Desktop），其中包括Neo4j企业版的全部功能，即Neo4j服务器、客户端及全部组件。,Neo4j_Desktop,包含,Neo4j服务器、客户端及全部组件
使用Neo4j内置的Movie图数据库执行Cypher查询，返回“TomHanks”所出演的全部电影，如图3-31所示。,Neo4j内置的Movie图数据库,包含,Cypher查询
此外，成功启动Neo4j服务器之后，会在7474和7473端口分别开启HTTP和HTTPS服务。,Neo4j,包含,7474
此外，成功启动Neo4j服务器之后，会在7474和7473端口分别开启HTTP和HTTPS服务。,Neo4j,包含,7473
例如，使用浏览器访问http://localhost:7474/进入Web界面，执行Cypher查询，其功能与Neo4j浏览器是一致的。,Neo4j浏览器,包含,功能
图3-31Neo4j浏览器界面2.分布式图数据库JanusGraphJanusGraph借助第三方分布式索引库Elasticsearch、Solr和Lucene实现各种类型数据的快速检索功能，包括地理信息数据、数值数据和全文搜索。,JanusGraph,包含,各种类型数据的快速检索功能
图3-31Neo4j浏览器界面2.分布式图数据库JanusGraphJanusGraph借助第三方分布式索引库Elasticsearch、Solr和Lucene实现各种类型数据的快速检索功能，包括地理信息数据、数值数据和全文搜索。,JanusGraph,包含,地理信息数据
图3-31Neo4j浏览器界面2.分布式图数据库JanusGraphJanusGraph借助第三方分布式索引库Elasticsearch、Solr和Lucene实现各种类型数据的快速检索功能，包括地理信息数据、数值数据和全文搜索。,JanusGraph,包含,数值数据
图3-31Neo4j浏览器界面2.分布式图数据库JanusGraphJanusGraph借助第三方分布式索引库Elasticsearch、Solr和Lucene实现各种类型数据的快速检索功能，包括地理信息数据、数值数据和全文搜索。,JanusGraph,包含,全文搜索
JanusGraph的前身Titan是由Aurelius公司开发的，而该公司的创始人Rodriguez博士恰恰就是Blueprints标准及Gremlin语言的主要开发者，Titan对于Blueprints标准和Gremlin语言的全面支持便不难理解，JanusGraph基本上继承了Titan的这一特性。,JanusGraph,包含,对于Blueprints标准和Gremlin语言的全面支持
同时，JanusGraph也是OLTP图数据库，其支持多用户并发访问和实时图遍历查询。,JanusGraph,包含,多用户并发访问和实时图遍历查询
另一方面，JanusGraph还具备基于Hadoop_MapReduce的图分析引擎，其可以将Gremlin导航查询自动转化为MapReduce任务。,JanusGraph,包含,基于Hadoop_MapReduce的图分析引擎
从这个角度看，JanusGraph也可作为图计算引擎使用。,JanusGraph,包含,图计算引擎
3.图数据库OrientDBOrientDB对于数据模式的支持也相对灵活，可以管理无模式数据（Schema-less），也可以像关系数据库那样定义完整的模式（Schema-full），还可以适应介于两者之间的混合模式（Schema-mixed）数据。,OrientDB,包含,无模式数据
3.图数据库OrientDBOrientDB对于数据模式的支持也相对灵活，可以管理无模式数据（Schema-less），也可以像关系数据库那样定义完整的模式（Schema-full），还可以适应介于两者之间的混合模式（Schema-mixed）数据。,OrientDB,包含,完整的模式
3.图数据库OrientDBOrientDB对于数据模式的支持也相对灵活，可以管理无模式数据（Schema-less），也可以像关系数据库那样定义完整的模式（Schema-full），还可以适应介于两者之间的混合模式（Schema-mixed）数据。,OrientDB,包含,混合模式数据
在查询语言方面，OrientDB支持扩展的SQL和Gremlin用于图上的导航式查询；值得注意的是，在2.2版本引入的MATCH语句实现了声明式的模式匹配，这类似于Cypher语言查询模式。,OrientDB,包含,扩展的SQL
在查询语言方面，OrientDB支持扩展的SQL和Gremlin用于图上的导航式查询；值得注意的是，在2.2版本引入的MATCH语句实现了声明式的模式匹配，这类似于Cypher语言查询模式。,OrientDB,包含,Gremlin
在查询语言方面，OrientDB支持扩展的SQL和Gremlin用于图上的导航式查询；值得注意的是，在2.2版本引入的MATCH语句实现了声明式的模式匹配，这类似于Cypher语言查询模式。,MATCH,包含,声明式的模式匹配
从数据管理角度来看，OrientDB是一个功能上相对全面的数据库管理系统，除对图数据基本的存储和查询外，还支持完整的事务处理ACID特性、基于多主机复制模式（Multi-Master_Replication）的分布式部署、对于多种操作系统的支持（由于使用Java开发）和数据库安全性支持等。,OrientDB,包含,ACID特性
从数据管理角度来看，OrientDB是一个功能上相对全面的数据库管理系统，除对图数据基本的存储和查询外，还支持完整的事务处理ACID特性、基于多主机复制模式（Multi-Master_Replication）的分布式部署、对于多种操作系统的支持（由于使用Java开发）和数据库安全性支持等。,OrientDB,包含,基于多主机复制模式（Multi-Master_Replication）的分布式部署
从数据管理角度来看，OrientDB是一个功能上相对全面的数据库管理系统，除对图数据基本的存储和查询外，还支持完整的事务处理ACID特性、基于多主机复制模式（Multi-Master_Replication）的分布式部署、对于多种操作系统的支持（由于使用Java开发）和数据库安全性支持等。,OrientDB,包含,对于多种操作系统的支持
从数据管理角度来看，OrientDB是一个功能上相对全面的数据库管理系统，除对图数据基本的存储和查询外，还支持完整的事务处理ACID特性、基于多主机复制模式（Multi-Master_Replication）的分布式部署、对于多种操作系统的支持（由于使用Java开发）和数据库安全性支持等。,OrientDB,包含,数据库安全性支持
"4.图数据库CayleyCayley使用Go语言开发，可以作为Go类库使用；对外提供RESTAPI；具有内置的查询编辑器和可视化界面；支持多种查询语言，包括基于Gremlin的Gizmo、GraphQL和MQL；支持多种存储后端，包括键值数据库Bolt、LevelDB,NoSQL数据库MongoDB、CouchDB、PouchDB、ElasticSearch，关系数据库PostgreSQL、MySQL等；具有良好的模块化设计，易于扩展，对新语言和存储后端有良好的支持。",Cayley,包含,内置的查询编辑器和可视化界面
"4.图数据库CayleyCayley使用Go语言开发，可以作为Go类库使用；对外提供RESTAPI；具有内置的查询编辑器和可视化界面；支持多种查询语言，包括基于Gremlin的Gizmo、GraphQL和MQL；支持多种存储后端，包括键值数据库Bolt、LevelDB,NoSQL数据库MongoDB、CouchDB、PouchDB、ElasticSearch，关系数据库PostgreSQL、MySQL等；具有良好的模块化设计，易于扩展，对新语言和存储后端有良好的支持。",Cayley,包含,多种查询语言
"4.图数据库CayleyCayley使用Go语言开发，可以作为Go类库使用；对外提供RESTAPI；具有内置的查询编辑器和可视化界面；支持多种查询语言，包括基于Gremlin的Gizmo、GraphQL和MQL；支持多种存储后端，包括键值数据库Bolt、LevelDB,NoSQL数据库MongoDB、CouchDB、PouchDB、ElasticSearch，关系数据库PostgreSQL、MySQL等；具有良好的模块化设计，易于扩展，对新语言和存储后端有良好的支持。",Cayley,包含,多种存储后端
"4.图数据库CayleyCayley使用Go语言开发，可以作为Go类库使用；对外提供RESTAPI；具有内置的查询编辑器和可视化界面；支持多种查询语言，包括基于Gremlin的Gizmo、GraphQL和MQL；支持多种存储后端，包括键值数据库Bolt、LevelDB,NoSQL数据库MongoDB、CouchDB、PouchDB、ElasticSearch，关系数据库PostgreSQL、MySQL等；具有良好的模块化设计，易于扩展，对新语言和存储后端有良好的支持。",Cayley,包含,良好的模块化设计
"4.图数据库CayleyCayley使用Go语言开发，可以作为Go类库使用；对外提供RESTAPI；具有内置的查询编辑器和可视化界面；支持多种查询语言，包括基于Gremlin的Gizmo、GraphQL和MQL；支持多种存储后端，包括键值数据库Bolt、LevelDB,NoSQL数据库MongoDB、CouchDB、PouchDB、ElasticSearch，关系数据库PostgreSQL、MySQL等；具有良好的模块化设计，易于扩展，对新语言和存储后端有良好的支持。",Cayley,包含,易于扩展
"4.图数据库CayleyCayley使用Go语言开发，可以作为Go类库使用；对外提供RESTAPI；具有内置的查询编辑器和可视化界面；支持多种查询语言，包括基于Gremlin的Gizmo、GraphQL和MQL；支持多种存储后端，包括键值数据库Bolt、LevelDB,NoSQL数据库MongoDB、CouchDB、PouchDB、ElasticSearch，关系数据库PostgreSQL、MySQL等；具有良好的模块化设计，易于扩展，对新语言和存储后端有良好的支持。",Cayley,包含,对新语言和存储后端的良好支持
需要指出的是，Cayley虽然可以存储N-Quads格式的RDF文件，但目前尚不支持SPARQL查询。,Cayley,包含,存储N-Quads格式的RDF文件
总体来讲，基于关系的存储系统继承了关系数据库的优势，成熟度较高，在硬件性能和存储容量满足的前提下，通常能够适应千万到十亿级三元组规模的管理。,基于关系的存储系统,包含,成熟度较高
总体来讲，基于关系的存储系统继承了关系数据库的优势，成熟度较高，在硬件性能和存储容量满足的前提下，通常能够适应千万到十亿级三元组规模的管理。,基于关系的存储系统,包含,适应千万到十亿级三元组规模的管理
官方测评显示，关系数据库Oracle_12c配上空间和图数据扩展组件（Spatial_and_Graph）可以管理的三元组数量高达1.08万亿条[34]！当然，这样的性能效果是在Oracle专用硬件上获得的，所需软硬件成本投入很大。,Oracle_12c,包含,管理的三元组数量
官方测评显示，关系数据库Oracle_12c配上空间和图数据扩展组件（Spatial_and_Graph）可以管理的三元组数量高达1.08万亿条[34]！当然，这样的性能效果是在Oracle专用硬件上获得的，所需软硬件成本投入很大。,Oracle_12c,包含,性能效果
对于一般在百万到上亿级三元组的管理，使用稍高配置的单机系统和主流RDF三元组数据库（如Jena、RDF4J、Virtuoso等）完全可以胜任。,RDF三元组数据库,包含,百万到上亿级三元组的管理
近年来，以Neo4j为代表的图数据库系统发展迅猛，使用图数据库管理RDF三元组也是一种很好的选择；但目前大部分图数据库还不能直接支持RDF三元组存储，对于这种情况，可采用数据转换方式，先将RDF预处理为图数据库支持的数据格式（如属性图模型），再进行后续管理操作。,图数据库管理RDF三元组,包含,数据转换方式
表3-5主要知识图谱数据库的比较续表3.3知识存储关键技术为了适应大规模知识图谱数据的存储管理与查询处理，知识图谱数据库内部针对图数据模型设计了专门的存储方案和查询处理机制。,知识存储关键技术,包含,针对图数据模型设计了专门的存储方案和查询处理机制
本节首先以图数据库Neo4j为例介绍其内部存储方案，然后简要描述知识图谱数据库的两类索引技术。,知识图谱数据库,包含,索引技术
3.3.1知识图谱数据库的存储：以Neo4j为例这一节将深入Neo4j图数据库底层，探究其原生的图存储方案。,Neo4j,包含,图存储方案
对于遵循属性图的图数据库，存储管理层的任务是将属性图编码表示为在磁盘上存储的数据格式。,存储管理层的任务,包含,将属性图编码表示为在磁盘上存储的数据格式
虽然不同图数据库的具体存储方案各有差异，但一般认为具有“无索引邻接”特性（Index-FreeAdjacency）的图数据库才称为原生图数据库[35]。,原生图数据库,包含,“无索引邻接”特性
在实现了“无索引邻接”的图数据库中，每个节点维护着指向其邻接节点的直接引用，这相当于每个节点都可看作是其邻接节点的一个“局部索引”，用其查找邻接节点比使用“全局索引”更能节省时间。,图数据库,包含,每个节点维护着指向其邻接节点的直接引用
这就意味着图导航操作代价与图大小无关，仅与图的遍历范围成正比。,图导航操作代价,包含,与图的遍历范围成正比
作为对比，来看看在非原生图数据库中使用全局索引关联邻接节点的情形。,非原生图数据库,包含,全局索引关联邻接节点
如果觉得这样的查找代价还是可以接受的话，那么换一个问题，“谁认识张三”的查找代价是多少？显然，对于这个查询，需要通过全局索引检查每个节点，看其认识的人中有没有张三，总代价为O(nlogn)，这样的复杂度对于大图数据的遍历操作是不可接受的。,查找代价,包含,通过全局索引检查每个节点，看其认识的人中有没有张三
有人说，可为“被认识”关系再建一个同样的全局索引，但那样索引的维护开销就会翻倍，而且仍然不能做到图遍历操作代价与图规模无关。,“被认识”关系,包含,全局索引
只有将图数据的边表示的关系当作数据库的“一等公民”（即数据库中最基本、最核心的概念，如关系数据库中的“关系”），才能实现真正的“无索引邻接”特性。,图数据的边表示的关系,包含,真正的“无索引邻接”特性
图3-36邻接关系的全局索引示例图3-37将关系作为“一等公民”在Neo4j数据库中，属性图的不同部分是被分开存储在不同文件中的。,属性图的不同部分,包含,分开存储在不同文件中的
正是这种将图结构与图上属性分开存储的策略，使得Neo4j具有高效率的图遍历操作。,Neo4j,包含,高效率的图遍历操作
节点记录存储在文件neostore.nodestore.db中。,节点记录,包含,文件neostore.nodestore.db
节点记录的第0字节inUse是记录使用标志字节的，告诉数据库该记录是否在使用中，还是已经删除并可回收用来装载新的记录；第1～4字节nextRelId是与节点相连的第1条边的id；第5～8字节nextPropId是节点的第1个属性的id。,节点记录的第0字节inUse,包含,记录使用标志字节，告诉数据库该记录是否在使用中，还是已经删除并可回收用来装载新的记录
边记录存储在文件neostore.relationshipstore.db中。,neostore.relationshipstore.db,包含,边记录存储
边记录第0字节inUse含义与节点记录相同，表示是否正被数据库使用的标志；第1～4字节secondNode分别是该边的起始节点id和终止节点id；第9～12字节relType是指向该边的关系类型的指针；第13～16字节firstPrevRelId和第17～20字节firstNextRelId分别为指向起始节点上前一个和后一个边记录的指针；第21～24字节secPrevRelId和第25～28字节secNextRelId分别为指向终止节点上前一个和后一个边记录的指针；指向前后边记录的4个指针形成了两个“关系双向链”；第29～32字节nextPropId是边上的第1个属性的id。,边记录,包含,inUse含义与节点记录相同，表示是否正被数据库使用的标志
边记录第0字节inUse含义与节点记录相同，表示是否正被数据库使用的标志；第1～4字节secondNode分别是该边的起始节点id和终止节点id；第9～12字节relType是指向该边的关系类型的指针；第13～16字节firstPrevRelId和第17～20字节firstNextRelId分别为指向起始节点上前一个和后一个边记录的指针；第21～24字节secPrevRelId和第25～28字节secNextRelId分别为指向终止节点上前一个和后一个边记录的指针；指向前后边记录的4个指针形成了两个“关系双向链”；第29～32字节nextPropId是边上的第1个属性的id。,边记录,包含,secondNode分别是该边的起始节点id和终止节点id
边记录第0字节inUse含义与节点记录相同，表示是否正被数据库使用的标志；第1～4字节secondNode分别是该边的起始节点id和终止节点id；第9～12字节relType是指向该边的关系类型的指针；第13～16字节firstPrevRelId和第17～20字节firstNextRelId分别为指向起始节点上前一个和后一个边记录的指针；第21～24字节secPrevRelId和第25～28字节secNextRelId分别为指向终止节点上前一个和后一个边记录的指针；指向前后边记录的4个指针形成了两个“关系双向链”；第29～32字节nextPropId是边上的第1个属性的id。,边记录,包含,relType是指向该边的关系类型的指针
边记录第0字节inUse含义与节点记录相同，表示是否正被数据库使用的标志；第1～4字节secondNode分别是该边的起始节点id和终止节点id；第9～12字节relType是指向该边的关系类型的指针；第13～16字节firstPrevRelId和第17～20字节firstNextRelId分别为指向起始节点上前一个和后一个边记录的指针；第21～24字节secPrevRelId和第25～28字节secNextRelId分别为指向终止节点上前一个和后一个边记录的指针；指向前后边记录的4个指针形成了两个“关系双向链”；第29～32字节nextPropId是边上的第1个属性的id。,边记录,包含,firstPrevRelId和firstNextRelId分别为指向起始节点上前一个和后一个边记录的指针
边记录第0字节inUse含义与节点记录相同，表示是否正被数据库使用的标志；第1～4字节secondNode分别是该边的起始节点id和终止节点id；第9～12字节relType是指向该边的关系类型的指针；第13～16字节firstPrevRelId和第17～20字节firstNextRelId分别为指向起始节点上前一个和后一个边记录的指针；第21～24字节secPrevRelId和第25～28字节secNextRelId分别为指向终止节点上前一个和后一个边记录的指针；指向前后边记录的4个指针形成了两个“关系双向链”；第29～32字节nextPropId是边上的第1个属性的id。,边记录,包含,secPrevRelId和secNextRelId分别为指向终止节点上前一个和后一个边记录的指针
边记录第0字节inUse含义与节点记录相同，表示是否正被数据库使用的标志；第1～4字节secondNode分别是该边的起始节点id和终止节点id；第9～12字节relType是指向该边的关系类型的指针；第13～16字节firstPrevRelId和第17～20字节firstNextRelId分别为指向起始节点上前一个和后一个边记录的指针；第21～24字节secPrevRelId和第25～28字节secNextRelId分别为指向终止节点上前一个和后一个边记录的指针；指向前后边记录的4个指针形成了两个“关系双向链”；第29～32字节nextPropId是边上的第1个属性的id。,边记录,包含,nextPropId是边上的第1个属性的id
和第5～8字节firstNode图3-38Neo4j中节点和边记录的物理存储结构Neo4j实现节点和边快速定位的关键是“定长记录”的存储方案，将具有定长记录的图结构与具有变长记录的属性数据分开存储。,Neo4j中节点和边记录的物理存储结构,包含,定长记录
例如，一个节点记录长度是9字节，如果要查找id为99的节点记录所在位置（id从0开始），则可直接到节点存储文件第891个字节处访问（存储文件从第0个字节开始）。,节点记录长度,包含,9字节
例如，一个节点记录长度是9字节，如果要查找id为99的节点记录所在位置（id从0开始），则可直接到节点存储文件第891个字节处访问（存储文件从第0个字节开始）。,查找id为99的节点记录所在位置,包含,节点存储文件第891个字节处访问
边记录也是“定长记录”，长度为33字节。,边记录,包含,定长记录
这样，数据库已知记录id可以O(1)的代价直接计算其存储地址，而避免了全局索引中O(nlogn)的查找代价。,数据库已知记录id,包含,O(1)的代价直接计算其存储地址
这样，数据库已知记录id可以O(1)的代价直接计算其存储地址，而避免了全局索引中O(nlogn)的查找代价。,数据库已知记录id,包含,避免了全局索引中O(nlogn)的查找代价
存储在节点文件中的节点1和节点4均有指针指向存储在属性文件中各自的第1个属性记录；也有指针指向存储在边文件中各自的第1条边，分别为边7和边8。,节点1,包含,指针指向存储在属性文件中各自的第1个属性记录
存储在节点文件中的节点1和节点4均有指针指向存储在属性文件中各自的第1个属性记录；也有指针指向存储在边文件中各自的第1条边，分别为边7和边8。,节点4,包含,指针指向存储在属性文件中各自的第1个属性记录
存储在节点文件中的节点1和节点4均有指针指向存储在属性文件中各自的第1个属性记录；也有指针指向存储在边文件中各自的第1条边，分别为边7和边8。,节点1,包含,指针指向存储在边文件中各自的第1条边
存储在节点文件中的节点1和节点4均有指针指向存储在属性文件中各自的第1个属性记录；也有指针指向存储在边文件中各自的第1条边，分别为边7和边8。,节点4,包含,指针指向存储在边文件中各自的第1条边
存储在节点文件中的节点1和节点4均有指针指向存储在属性文件中各自的第1个属性记录；也有指针指向存储在边文件中各自的第1条边，分别为边7和边8。,节点1,包含,边7
存储在节点文件中的节点1和节点4均有指针指向存储在属性文件中各自的第1个属性记录；也有指针指向存储在边文件中各自的第1条边，分别为边7和边8。,节点4,包含,边8
如要查找节点属性，可由节点找到其第1个属性记录，再沿着属性记录的单向链表进行查找；如要查找一个节点上的边，可由节点找到其第1条边，再沿着边记录的双向链表进行查找；当找到了所需的边记录后，可由该边进一步找到边上的属性；还可由边记录出发访问该边连接的两个节点记录（图3-39中的虚线箭头）。,查找节点属性,包含,第1个属性记录
如要查找节点属性，可由节点找到其第1个属性记录，再沿着属性记录的单向链表进行查找；如要查找一个节点上的边，可由节点找到其第1条边，再沿着边记录的双向链表进行查找；当找到了所需的边记录后，可由该边进一步找到边上的属性；还可由边记录出发访问该边连接的两个节点记录（图3-39中的虚线箭头）。,查找一个节点上的边,包含,第1条边
如要查找节点属性，可由节点找到其第1个属性记录，再沿着属性记录的单向链表进行查找；如要查找一个节点上的边，可由节点找到其第1条边，再沿着边记录的双向链表进行查找；当找到了所需的边记录后，可由该边进一步找到边上的属性；还可由边记录出发访问该边连接的两个节点记录（图3-39中的虚线箭头）。,所需的边记录,包含,边上的属性
如要查找节点属性，可由节点找到其第1个属性记录，再沿着属性记录的单向链表进行查找；如要查找一个节点上的边，可由节点找到其第1条边，再沿着边记录的双向链表进行查找；当找到了所需的边记录后，可由该边进一步找到边上的属性；还可由边记录出发访问该边连接的两个节点记录（图3-39中的虚线箭头）。,边记录,包含,两个节点记录
需要注意的是，每个边记录实际上维护着两个双向链表，一个是起始节点上的边，一个是终止节点上的边，可以将边记录想象为被起始节点和终止节点共同拥有，双向链表的优势在于不仅可在查找节点上的边时进行双向扫描，而且支持在两个节点间高效率地添加和删除边。,边记录,包含,起始节点上的边
需要注意的是，每个边记录实际上维护着两个双向链表，一个是起始节点上的边，一个是终止节点上的边，可以将边记录想象为被起始节点和终止节点共同拥有，双向链表的优势在于不仅可在查找节点上的边时进行双向扫描，而且支持在两个节点间高效率地添加和删除边。,边记录,包含,终止节点上的边
图3-39Neo4j中图的物理存储例如，由节点1导航到节点4的过程为：（1）由节点1知道其第1条边为边7；（2）在边文件中通过定长记录计算出边7的存储地址；（3）由边7通过双向链表找到边8；（4）由边8获得其中的终止节点id（secondNode），即节点4；（5）在节点文件中通过定长记录计算出节点4的存储地址。,图3-39Neo4j中图的物理存储,包含,由节点1知道其第1条边为边7
图3-39Neo4j中图的物理存储例如，由节点1导航到节点4的过程为：（1）由节点1知道其第1条边为边7；（2）在边文件中通过定长记录计算出边7的存储地址；（3）由边7通过双向链表找到边8；（4）由边8获得其中的终止节点id（secondNode），即节点4；（5）在节点文件中通过定长记录计算出节点4的存储地址。,图3-39Neo4j中图的物理存储,包含,在边文件中通过定长记录计算出边7的存储地址
图3-39Neo4j中图的物理存储例如，由节点1导航到节点4的过程为：（1）由节点1知道其第1条边为边7；（2）在边文件中通过定长记录计算出边7的存储地址；（3）由边7通过双向链表找到边8；（4）由边8获得其中的终止节点id（secondNode），即节点4；（5）在节点文件中通过定长记录计算出节点4的存储地址。,图3-39Neo4j中图的物理存储,包含,由边7通过双向链表找到边8
图3-39Neo4j中图的物理存储例如，由节点1导航到节点4的过程为：（1）由节点1知道其第1条边为边7；（2）在边文件中通过定长记录计算出边7的存储地址；（3）由边7通过双向链表找到边8；（4）由边8获得其中的终止节点id（secondNode），即节点4；（5）在节点文件中通过定长记录计算出节点4的存储地址。,图3-39Neo4j中图的物理存储,包含,由边8获得其中的终止节点id（secondNode），即节点4
图3-39Neo4j中图的物理存储例如，由节点1导航到节点4的过程为：（1）由节点1知道其第1条边为边7；（2）在边文件中通过定长记录计算出边7的存储地址；（3）由边7通过双向链表找到边8；（4）由边8获得其中的终止节点id（secondNode），即节点4；（5）在节点文件中通过定长记录计算出节点4的存储地址。,图3-39Neo4j中图的物理存储,包含,在节点文件中通过定长记录计算出节点4的存储地址
这些操作除了记录字段的读取，就是定长记录地址的计算，均是O(1)时间的高效率操作。,操作,包含,记录字段的读取
这些操作除了记录字段的读取，就是定长记录地址的计算，均是O(1)时间的高效率操作。,操作,包含,定长记录地址的计算
可见，正是由于将边作为“一等公民”，将图结构实现为定长记录的存储方案，赋予了Neo4j作为原生图数据库的“无索引邻接”特性。,Neo4j,包含,将边作为“一等公民”
可见，正是由于将边作为“一等公民”，将图结构实现为定长记录的存储方案，赋予了Neo4j作为原生图数据库的“无索引邻接”特性。,Neo4j,包含,将图结构实现为定长记录的存储方案
3.3.2知识图谱数据库的索引图数据上的索引一种是对节点或边上属性数据的索引，一种是对图结构的索引；前者可应用关系数据库中已有的B+树索引技术直接实现，而后者仍是业界没有达成共识的、开放的研究问题。,索引图数据上的索引,包含,对节点或边上属性数据的索引
3.3.2知识图谱数据库的索引图数据上的索引一种是对节点或边上属性数据的索引，一种是对图结构的索引；前者可应用关系数据库中已有的B+树索引技术直接实现，而后者仍是业界没有达成共识的、开放的研究问题。,索引图数据上的索引,包含,对图结构的索引
1.属性数据索引Neo4j数据库在前述存储方案的基础上还支持用户对属性数据建立索引，目的是加速针对某属性的查询处理性能。,属性数据索引Neo4j数据库,包含,查询处理性能
Neo4j索引的定义通过Cypher语句完成，目前支持对于同一个类型节点的某个属性构建索引。,Neo4j索引,包含,Cypher语句完成
例如，对所有程序员节点的姓名属性构建索引。,对所有程序员节点的姓名属性构建索引,包含,构建索引
在一般情况下，在查询中没有必要指定需要使用的索引，查询优化器会自动选择要用到的索引。,查询优化器,包含,自动选择要用到的索引
例如，下面的查询查找姓名为张三的程序员，显然会用到刚刚建立的索引。,索引,包含,查找姓名为张三的程序员
应用该索引无疑会根据姓名属性的值快速定位到姓名是“张三”的节点，而无须扫描程序员节点的全部属性。,应用该索引,包含,根据姓名属性的值快速定位到姓名是“张三”的节点
应用该索引无疑会根据姓名属性的值快速定位到姓名是“张三”的节点，而无须扫描程序员节点的全部属性。,应用该索引,包含,无须扫描程序员节点的全部属性
删除索引的语句为：不难发现，为图节点或边的属性建立索引与为关系表的某一列建立索引在本质上并无不同之处，完全可以通过B+树或散列表实现。,为图节点或边的属性建立索引,包含,为关系表的某一列建立索引
这种索引并不涉及图数据上的任何图结构信息。,索引,包含,图数据上的任何图结构信息
2.图结构索引图结构索引是为图数据中的点边结构信息建立索引的方法。,图结构索引,包含,为图数据中的点边结构信息建立索引的方法
利用图结构索引可以对图查询中的结构信息进行快速匹配，从而大幅削减查询搜索空间。,图查询,包含,结构信息的快速匹配
利用图结构索引可以对图查询中的结构信息进行快速匹配，从而大幅削减查询搜索空间。,图索引,包含,大幅削减查询搜索空间
大体上，图结构索引分为“基于路径的”和“基于子图的”两种。,图结构索引,包含,基于路径的图结构索引
大体上，图结构索引分为“基于路径的”和“基于子图的”两种。,图结构索引,包含,基于子图的图结构索引
（1）基于路径的图索引。,基于路径的图索引,包含,基于路径的索引
一种典型的基于路径的图索引叫作GraphGrep[36]。,GraphGrep,包含,基于路径的图索引
这种索引将图中长度小于或等于一个固定长度的全部路径构建为索引结构。,倒排索引,包含,将图中长度小于或等于一个固定长度的全部路径构建为索引结构
索引的关键字可以是组成路径的节点或边上属性值或标签的序列。,索引的关键字,包含,组成路径的节点或边上属性值或标签的序列
图3-40是在图3-3的属性图上构建的GraphGrep索引。,GraphGrep索引,包含,在图3-3的属性图上构建
这里构建的是长度小于或等于2的路径索引，关键字为路径上的边标签序列，值为路径经过的节点id序列。,路径索引,包含,长度小于或等于2
这里构建的是长度小于或等于2的路径索引，关键字为路径上的边标签序列，值为路径经过的节点id序列。,路径索引,包含,关键字为路径上的边标签序列
这里构建的是长度小于或等于2的路径索引，关键字为路径上的边标签序列，值为路径经过的节点id序列。,路径索引,包含,值为路径经过的节点id序列
"例如，索引将关键字“认识.参加”映射到节点id序列(1,4,3)和(1,4,5)。",索引,包含,关键字“认识.参加”映射
利用该路径索引，类似前面出现过的“查询年龄为29的参加了项目3的程序员参加的其他项目及其直接或间接认识的程序员参加的项目”的查询处理效率会大幅提高，因为由节点1出发，根据关键字“认识.参加”，可以快速找到满足条件的节点3和节点5。,路径索引,包含,根据关键字“认识.参加”，可以快速找到满足条件的节点3和节点5
（2）基于子图的索引。,基于子图的索引,包含,基于概念的索引
基于子图的索引可以看作是基于路径索引的一般化形式，是将图数据中的某些子图结构信息作为关键字，将该子图的实例数据作为值而构建的索引结构。,基于子图的索引,包含,基于路径索引的一般化形式
图3-41是在图3-3的属性图上构建的一种子图索引。,图3-41,包含,一种子图索引
如果查询中包含某些作为关键字的子图结构，则可以利用该子图索引，快速找到与这些子图结构匹配的节点序列，这样可大幅度减小查询操作的搜索空间。,索引,包含,快速找到与这些子图结构匹配的节点序列
图3-40基于路径的图索引示例图3-41基于子图的图索引示例不过，一个图数据的子图有指数个，将哪些子图作为关键字建立索引尚未得到很好的解决。,图数据的索引,包含,将哪些子图作为关键字建立索引
一种叫作gIndex[37]的索引方法，首先利用数据挖掘方法，在图数据中发现出现次数超过一定阈值的频繁子图，再将去掉冗余之后的频繁子图作为关键字建立子图索引。,gIndex,包含,在图数据中发现出现次数超过一定阈值的频繁子图
一种叫作gIndex[37]的索引方法，首先利用数据挖掘方法，在图数据中发现出现次数超过一定阈值的频繁子图，再将去掉冗余之后的频繁子图作为关键字建立子图索引。,gIndex,包含,去掉冗余之后的频繁子图
一种叫作gIndex[37]的索引方法，首先利用数据挖掘方法，在图数据中发现出现次数超过一定阈值的频繁子图，再将去掉冗余之后的频繁子图作为关键字建立子图索引。,gIndex,包含,建立子图索引
但gIndex建立索引的过程是相当耗时的，而且用户查询中还有可能没有包含任何一个频繁子图，这样就无法利用该子图索引。,gIndex,包含,建立索引的过程是相当耗时的
但gIndex建立索引的过程是相当耗时的，而且用户查询中还有可能没有包含任何一个频繁子图，这样就无法利用该子图索引。,gIndex,包含,用户查询中还有可能没有包含任何一个频繁子图
一种更合理的方法是从用户的查询日志中挖掘频繁使用的子图模式，并以此作为关键字建立索引。,索引,包含,从用户的查询日志中挖掘频繁使用的子图模式
3.4开源工具实践3.4.1三元组数据库Apache_Jena1.开源工具简介Apache_Jena是Apache顶级项目，其前身为惠普实验室开发的Jena工具包。,Apache_Jena,包含,三元组数据库
Jena是语义Web领域主要的开源框架和RDF三元组库，较好地遵循W3C标准，其功能包括：RDF数据管理、RDFS和OWL本体管理、SPARQL查询处理等。,Jena,包含,RDF数据管理
Jena是语义Web领域主要的开源框架和RDF三元组库，较好地遵循W3C标准，其功能包括：RDF数据管理、RDFS和OWL本体管理、SPARQL查询处理等。,Jena,包含,RDFS本体管理
Jena是语义Web领域主要的开源框架和RDF三元组库，较好地遵循W3C标准，其功能包括：RDF数据管理、RDFS和OWL本体管理、SPARQL查询处理等。,Jena,包含,OWL本体管理
Jena是语义Web领域主要的开源框架和RDF三元组库，较好地遵循W3C标准，其功能包括：RDF数据管理、RDFS和OWL本体管理、SPARQL查询处理等。,Jena,包含,SPARQL查询处理
Jena具备一套原生存储引擎，可对RDF三元组进行基于磁盘或内存的存储管理；同时具有一套基于规则的推理引擎，用于执行RDFS和OWL本体推理任务。,Jena,包含,一套原生存储引擎
Jena具备一套原生存储引擎，可对RDF三元组进行基于磁盘或内存的存储管理；同时具有一套基于规则的推理引擎，用于执行RDFS和OWL本体推理任务。,Jena,包含,一套基于规则的推理引擎
本实践相关工具、实验数据及操作说明由OpenKG提供，地址为http://openkg.cn。,本实践相关工具,包含,OpenKG
本实践相关工具、实验数据及操作说明由OpenKG提供，地址为http://openkg.cn。,本实践相关实验数据,包含,OpenKG
本实践相关工具、实验数据及操作说明由OpenKG提供，地址为http://openkg.cn。,本实践相关操作说明,包含,OpenKG
自底向上看，Jena的存储API为上层提供基本三元组存储和本体存储功能，支持的底层存储类型包括：基于内存的存储、基于关系数据库的SDB存储、基于原生三元组的TDB存储和用户定制的存储。,Jena的存储API,包含,基本三元组存储功能
自底向上看，Jena的存储API为上层提供基本三元组存储和本体存储功能，支持的底层存储类型包括：基于内存的存储、基于关系数据库的SDB存储、基于原生三元组的TDB存储和用户定制的存储。,Jena的存储API,包含,本体存储功能
自底向上看，Jena的存储API为上层提供基本三元组存储和本体存储功能，支持的底层存储类型包括：基于内存的存储、基于关系数据库的SDB存储、基于原生三元组的TDB存储和用户定制的存储。,Jena的存储API,包含,基于内存的存储
自底向上看，Jena的存储API为上层提供基本三元组存储和本体存储功能，支持的底层存储类型包括：基于内存的存储、基于关系数据库的SDB存储、基于原生三元组的TDB存储和用户定制的存储。,Jena的存储API,包含,基于关系数据库的SDB存储
自底向上看，Jena的存储API为上层提供基本三元组存储和本体存储功能，支持的底层存储类型包括：基于内存的存储、基于关系数据库的SDB存储、基于原生三元组的TDB存储和用户定制的存储。,Jena的存储API,包含,基于原生三元组的TDB存储
自底向上看，Jena的存储API为上层提供基本三元组存储和本体存储功能，支持的底层存储类型包括：基于内存的存储、基于关系数据库的SDB存储、基于原生三元组的TDB存储和用户定制的存储。,Jena的存储API,包含,用户定制的存储
推理API为上层提供本体推理服务，可以使用Jena内置基于规则的推理机进行RDFS和OWL本体上的推理任务，或者选择通过接口调用第三方外部推理机。,推理API,包含,推理机
Jena对外界应用程序的API包括实现基本三元组管理功能的RDFAPI、实现RDFS和OWL本体推理功能的本体API和实现查询处理功能的SPARQL_API。,Jena,包含,RDFAPI
Jena对外界应用程序的API包括实现基本三元组管理功能的RDFAPI、实现RDFS和OWL本体推理功能的本体API和实现查询处理功能的SPARQL_API。,Jena,包含,本体API
Jena对外界应用程序的API包括实现基本三元组管理功能的RDFAPI、实现RDFS和OWL本体推理功能的本体API和实现查询处理功能的SPARQL_API。,Jena,包含,SPARQL_API
Jena还提供了支持各种RDF三元组格式的解析器和编写器，支持的三元组格式包括：RDF/XML、Turtle、N-Triple和RDFa。,Jena,包含,支持各种RDF三元组格式的解析器和编写器
Jena为了用户使用方便，提供了一个名为Fuseki的独立RDF数据库Web应用程序。,Fuseki,包含,独立RDF数据库Web应用程序
Fuseki是基于Jena的SPARQL服务器，可以作为独立的服务由命令行启动，也可以作为操作系统服务或JavaWeb应用程序。,Fuseki,包含,独立的服务
Fuseki是基于Jena的SPARQL服务器，可以作为独立的服务由命令行启动，也可以作为操作系统服务或JavaWeb应用程序。,Fuseki,包含,操作系统服务
Fuseki是基于Jena的SPARQL服务器，可以作为独立的服务由命令行启动，也可以作为操作系统服务或JavaWeb应用程序。,Fuseki,包含,JavaWeb应用程序
Fuseki底层存储基于TDB，具有SPARQL查询处理的Web用户界面，同时提供服务器监控和管理功能界面。,Fuseki,包含,SPARQL查询处理
Fuseki底层存储基于TDB，具有SPARQL查询处理的Web用户界面，同时提供服务器监控和管理功能界面。,Fuseki,包含,Web用户界面
Fuseki底层存储基于TDB，具有SPARQL查询处理的Web用户界面，同时提供服务器监控和管理功能界面。,Fuseki,包含,服务器监控和管理功能
Fuseki支持最新的SPARQL1.1版本，同时支持SPARQL图存储HTTP协议。,Fuseki,包含,最新的SPARQL1.1版本
Fuseki支持最新的SPARQL1.1版本，同时支持SPARQL图存储HTTP协议。,Fuseki,包含,SPARQL图存储HTTP协议
访问OpenKG可以获取使用实例和整体配置细节。,OpenKG,包含,使用实例
访问OpenKG可以获取使用实例和整体配置细节。,OpenKG,包含,整体配置细节
3.其他类似工具RDF4J是Eclipse基金会旗下的开源孵化项目，其前身是荷兰软件公司Aduna开发的Sesame框架，其功能包括：RDF数据的解析、存储、推理和查询等。,RDF4J,包含,RDF数据的解析功能
3.其他类似工具RDF4J是Eclipse基金会旗下的开源孵化项目，其前身是荷兰软件公司Aduna开发的Sesame框架，其功能包括：RDF数据的解析、存储、推理和查询等。,RDF4J,包含,RDF数据的存储功能
3.其他类似工具RDF4J是Eclipse基金会旗下的开源孵化项目，其前身是荷兰软件公司Aduna开发的Sesame框架，其功能包括：RDF数据的解析、存储、推理和查询等。,RDF4J,包含,RDF数据的推理功能
3.其他类似工具RDF4J是Eclipse基金会旗下的开源孵化项目，其前身是荷兰软件公司Aduna开发的Sesame框架，其功能包括：RDF数据的解析、存储、推理和查询等。,RDF4J,包含,RDF数据的查询功能
RDF4J提供内存和磁盘两种RDF存储机制，支持SPARQL1.1查询和更新语言。,RDF4J,包含,内存RDF存储机制
RDF4J提供内存和磁盘两种RDF存储机制，支持SPARQL1.1查询和更新语言。,RDF4J,包含,磁盘RDF存储机制
RDF4J提供内存和磁盘两种RDF存储机制，支持SPARQL1.1查询和更新语言。,RDF4J,包含,SPARQL1.1查询语言
RDF4J提供内存和磁盘两种RDF存储机制，支持SPARQL1.1查询和更新语言。,RDF4J,包含,更新语言
gStore是由北京大学开发的基于图的RDF三元组数据库。,gStore,包含,基于图的RDF三元组数据库
AllegroGraph是Franz公司开发的RDF三元组数据库。,AllegroGraph,包含,RDF三元组数据库
AllegroGraph对语义推理功能具有较为完善的支持。,AllegroGraph,包含,语义推理功能
除了三元组数据库的基本功能，AllegroGraph_RDFS++推理机、OWL2RL推理机、Prolog规则推理系统、时空推理机制、社会网络分析还支持动态物化的库、可视化RDF图浏览器等。,AllegroGraph_RDFS++推理机,包含,动态物化的库
除了三元组数据库的基本功能，AllegroGraph_RDFS++推理机、OWL2RL推理机、Prolog规则推理系统、时空推理机制、社会网络分析还支持动态物化的库、可视化RDF图浏览器等。,OWL2RL推理机,包含,动态物化的库
除了三元组数据库的基本功能，AllegroGraph_RDFS++推理机、OWL2RL推理机、Prolog规则推理系统、时空推理机制、社会网络分析还支持动态物化的库、可视化RDF图浏览器等。,Prolog规则推理系统,包含,动态物化的库
除了三元组数据库的基本功能，AllegroGraph_RDFS++推理机、OWL2RL推理机、Prolog规则推理系统、时空推理机制、社会网络分析还支持动态物化的库、可视化RDF图浏览器等。,时空推理机制,包含,动态物化的库
除了三元组数据库的基本功能，AllegroGraph_RDFS++推理机、OWL2RL推理机、Prolog规则推理系统、时空推理机制、社会网络分析还支持动态物化的库、可视化RDF图浏览器等。,社会网络分析,包含,动态物化的库
除了三元组数据库的基本功能，AllegroGraph_RDFS++推理机、OWL2RL推理机、Prolog规则推理系统、时空推理机制、社会网络分析还支持动态物化的库、可视化RDF图浏览器等。,可视化RDF图浏览器,包含,支持
GraphDB是由Ontotext软件公司开发的RDF三元组数据库。,GraphDB,包含,RDF三元组数据库
GraphDB实现了RDF4J框架的SAIL层，可以使用RDF4J的RDF模型、解析器和查询引擎直接访问GraphDB。,GraphDB,包含,RDF模型
GraphDB实现了RDF4J框架的SAIL层，可以使用RDF4J的RDF模型、解析器和查询引擎直接访问GraphDB。,GraphDB,包含,解析器
GraphDB实现了RDF4J框架的SAIL层，可以使用RDF4J的RDF模型、解析器和查询引擎直接访问GraphDB。,GraphDB,包含,查询引擎
GraphDB的特色是对于RDF推理功能的良好支持。,GraphDB,包含,对于RDF推理功能的良好支持
3.4.2面向RDF的三元组数据库gStore1.开源工具简介gStore是由北京大学计算机科学技术研究所数据管理实验室自2011年开始研发的面向RDF知识图谱的开源图数据库系统，遵循Apache开源协议。,gStore,包含,开源工具
不同于传统基于关系数据库的RDF数据管理方法，gStore原生基于图数据模型，在存储RDF数据时维持并根据其图结构构建了基于二进制位图索引的新型索引结构——VS树。,gStore,包含,基于二进制位图索引的新型索引结构——VS树
本实践相关工具、实验数据及操作说明由OpenKG提供，下载链接为http://openkg.cn/tool/gstore。,本实践相关工具,包含,OpenKG
本实践相关工具、实验数据及操作说明由OpenKG提供，下载链接为http://openkg.cn/tool/gstore。,本实践相关工具,包含,实验数据及操作说明
2.开源工具的技术架构如图3-43所示为gStore的整体处理流程，gStore的RDF数据管理可分为两部分：离线数据存储和在线查询处理。,gStore的整体处理流程,包含,离线数据存储
2.开源工具的技术架构如图3-43所示为gStore的整体处理流程，gStore的RDF数据管理可分为两部分：离线数据存储和在线查询处理。,gStore的整体处理流程,包含,在线查询处理
图3-43gStore的整体处理流程在离线数据存储阶段，gStore将RDF数据解析成图格式并以邻接表的方式存储在键值数据库上。,gStore的离线数据存储,包含,将RDF数据解析成图格式并以邻接表的方式存储在键值数据库上
同时，gStore将RDF数据上的所有点和边通过二进制编码的方式编码成若干位图索引，并将这些位图索引组织成VS树。,gStore,包含,RDF数据上的所有点和边
在在线查询处理阶段，gStore也将SPARQL查询解析成查询图。,查询图,包含,SPARQL查询解析成查询图
然后，gStore按照对RDF数据图的编码方式，将SPARQL查询图进行编码以形成一个标签图，并在VS树和RDF数据图的邻接表上进行检索以得到每个查询变量的候选匹配。,gStore,包含,将SPARQL查询图进行编码以形成一个标签图
然后，gStore按照对RDF数据图的编码方式，将SPARQL查询图进行编码以形成一个标签图，并在VS树和RDF数据图的邻接表上进行检索以得到每个查询变量的候选匹配。,gStore,包含,在VS树和RDF数据图的邻接表上进行检索以得到每个查询变量的候选匹配
最后，gStore将所有查询变量的候选匹配连接成最终匹配。,gStore,包含,查询变量的候选匹配连接成最终匹配
同时，gStore官网还提供了gStore_Workbench，方便用户操作RDF数据库。,gStore,包含,gStore_Workbench
具体包括：（1）环境配置。,SPO三元组,包含,环境配置
Linux中编译、安装与运行gStore需要预安装一些C++库，包括readline、curl和boost等。,gStore,包含,C++库
同时，通过OpenKG网站或gStore官网可以下载gStore_Workbench，进行编译安装后可以得到gStore_Workbench。,gStore_Workbench,包含,编译安装
（2）数据导入。,数据导入,包含,概念/产品
gStore目前支持NT格式的RDF数据，利用gStore安装路径下bin目录中gbuild或者gStore_Workbench中的数据库管理页面导入数据。,gStore,包含,NT格式的RDF数据
gStore_Workbench中的数据库管理页面还记录目前gStore包括的数据库统计信息。,gStore_Workbench中的数据库管理页面,包含,目前gStore包括的数据库统计信息
gStore目前完全支持SPARQL1.0查询语法，利用gStore安装路径下bin目录中gquery或者gStoreWorkbench中的图数据库查询页面，就可以输入查询然后得到结果。,gStore,包含,SPARQL1.0查询语法
gStore同时还提供HTTP接口，可以利用gStore安装路径下bin目录中ghttp启动HTTP服务，进而接收其他机器远程通过HTTP发来的SPARQL查询请求。,gStore,包含,HTTP接口
3.其他类似工具Jena的前身是惠普实验室（HP_Labs）2000年开发的工具包。,Jena,包含,惠普实验室（HP_Labs）2000年开发的工具包
Jena从发布起就一直是语义Web领域最为流行的开源Java框架和RDF数据库之一，并始终遵循W3C标准，其提供的API功能包括：RDF数据管理、RDFS和OWL本体管理、SPARQL查询处理。,Jena,包含,RDF数据管理
Jena从发布起就一直是语义Web领域最为流行的开源Java框架和RDF数据库之一，并始终遵循W3C标准，其提供的API功能包括：RDF数据管理、RDFS和OWL本体管理、SPARQL查询处理。,Jena,包含,RDFS本体管理
Jena从发布起就一直是语义Web领域最为流行的开源Java框架和RDF数据库之一，并始终遵循W3C标准，其提供的API功能包括：RDF数据管理、RDFS和OWL本体管理、SPARQL查询处理。,Jena,包含,OWL本体管理
Jena从发布起就一直是语义Web领域最为流行的开源Java框架和RDF数据库之一，并始终遵循W3C标准，其提供的API功能包括：RDF数据管理、RDFS和OWL本体管理、SPARQL查询处理。,Jena,包含,SPARQL查询处理
针对RDF数据，Jena维护了一张大的三元组表和三种属性表，包括单值属性表、多值属性表和属性类表。,Jena,包含,单值属性表
针对RDF数据，Jena维护了一张大的三元组表和三种属性表，包括单值属性表、多值属性表和属性类表。,Jena,包含,多值属性表
针对RDF数据，Jena维护了一张大的三元组表和三种属性表，包括单值属性表、多值属性表和属性类表。,Jena,包含,属性类表
Virtuoso是OpenLink公司开发的知识图谱管理系统，有免费的社区版和收费的商业版。,Virtuoso,包含,知识图谱管理系统
其基础源自开发了多年的传统关系数据库管理系统，因此具备较为完善的事务管理、并发控制和完整性机制。,关系数据库管理系统,包含,较为完善的事务管理、并发控制和完整性机制
