input,subject,subject_type,relation,object,object_type
第3章知识存储王鑫天津大学随着知识图谱规模的日益增长，数据管理愈加重要。,知识存储,,,知识图谱数据管理,
一方面，以文件形式保存的知识图谱显然无法满足用户的查询、检索、推理、分析及各种应用需求；另一方面，传统数据库的关系模型与知识图谱的图模型之间存在显著差异，关系数据库无法有效地管理大规模知识图谱数据。,知识图谱,,,数据库,
为了更好地进行三元组数据的存储，语义万维网领域发展出专门存储RDF数据的三元组库；数据库领域发展出用于管理属性图的图数据库。,三元组数据库,,,存储RDF数据,
为了更好地进行三元组数据的存储，语义万维网领域发展出专门存储RDF数据的三元组库；数据库领域发展出用于管理属性图的图数据库。,三元组库,,,triplestore,
为了更好地进行三元组数据的存储，语义万维网领域发展出专门存储RDF数据的三元组库；数据库领域发展出用于管理属性图的图数据库。,图数据库,,,graph database,
3.1知识图谱数据库基本知识本节首先介绍目前表示知识图谱的两种主要图数据模型：RDF图和属性图。,知识图谱数据库,,,目前表示知识图谱的两种主要图数据模型,
3.1.1知识图谱数据模型从数据模型角度来看，知识图谱本质上是一种图数据。,知识图谱,,,图数据,
不同领域的知识图谱均须遵循相应的数据模型。,知识图谱,,,数据模型,
往往一个数据模型的生命力要看其数学基础的强弱，关系模型长盛不衰的一个重要原因是其数学基础为关系代数。,关系模型,,,关系代数,
知识图谱数据模型的数学基础源于有着近300年历史的数学分支——图论。,知识图谱数据模型,,,图论,
"在图论中，图是二元组G=（V,E），其中V是节点集合，E是边集合。",图,,,"二元组G=（V,E）",
"在图论中，图是二元组G=（V,E），其中V是节点集合，E是边集合。",图,,,graph,
知识图谱数据模型基于图论中图的定义，用节点集合表示实体，用边集合表示实体间的联系，这种一般和通用的数据表示恰好能够自然地刻画现实世界中事物的广泛联系。,知识图谱数据模型,,,图的定义,
1.RDF图RDF是W3C制定的在语义万维网上表示和交换机器可理解信息的标准数据模型[1]。,RDF,,,W3C制定的在语义万维网上表示和交换机器可理解信息的标准数据模型,
1.RDF图RDF是W3C制定的在语义万维网上表示和交换机器可理解信息的标准数据模型[1]。,RDF,,,语义万维网上表示和交换机器可理解信息的标准数据模型,
"在RDF三元组集合中，每个Web资源具有一个HTTPURI作为其唯一的id；一个RDF图定义为三元组(s,p,o)的有限集合；每个三元组代表一个陈述句，其中s是主语，p是谓语，o是宾语；(s,p,o)表示资源s与资源o之间具有联系p，或表示资源s具有属性p且其取值为o。",RDF三元组,,,RDF图,
"在RDF三元组集合中，每个Web资源具有一个HTTPURI作为其唯一的id；一个RDF图定义为三元组(s,p,o)的有限集合；每个三元组代表一个陈述句，其中s是主语，p是谓语，o是宾语；(s,p,o)表示资源s与资源o之间具有联系p，或表示资源s具有属性p且其取值为o。",三元组,,,"(s,p,o)的有限集合",
实际上，RDF三元组集合即为图中的有向边集合。,RDF三元组集合,,,图中的有向边集合,
如图3-1所示，是一个虚构的软件开发公司的社会网络图，其中有张三、李四、王五和赵六4名程序员，有“图数据库”和“RDF三元组库”2个项目；张三认识李四和王五；张三、王五和赵六参加“图数据库”的开发，该项目使用Java语言；王五参加“RDF三元组库”的开发，该项目使用C++语言。,图3-1所示的软件开发公司的社会网络图,,,虚构,
如图3-1所示，是一个虚构的软件开发公司的社会网络图，其中有张三、李四、王五和赵六4名程序员，有“图数据库”和“RDF三元组库”2个项目；张三认识李四和王五；张三、王五和赵六参加“图数据库”的开发，该项目使用Java语言；王五参加“RDF三元组库”的开发，该项目使用C++语言。,等价,,,equivalence,
如图3-1所示，是一个虚构的软件开发公司的社会网络图，其中有张三、李四、王五和赵六4名程序员，有“图数据库”和“RDF三元组库”2个项目；张三认识李四和王五；张三、王五和赵六参加“图数据库”的开发，该项目使用Java语言；王五参加“RDF三元组库”的开发，该项目使用C++语言。,英文名,,,English name,
图3-1RDF图示例值得注意的是，RDF图对于节点和边上的属性没有内置的支持。,RDF图,,,图3-1RDF图示例,
图3-1RDF图示例值得注意的是，RDF图对于节点和边上的属性没有内置的支持。,RDF图,,,RDF图示例,
节点属性可用三元组表示，这类三元组的宾语称为字面量，即图中的矩形。,节点属性,,,三元组,
边上的属性表示起来稍显烦琐，最常见的是利用RDF中一种叫作“具体化”（reification）的技术[2]，需要引入额外的点表示整个三元组，将边属性表示为以该节点为主语的三元组。,边上的属性,,,具体化技术,
边上的属性表示起来稍显烦琐，最常见的是利用RDF中一种叫作“具体化”（reification）的技术[2]，需要引入额外的点表示整个三元组，将边属性表示为以该节点为主语的三元组。,边上的属性,,,reification,
例如在图3-2中，引入节点ex:participate代表三元组(ex:zhangsan，参加，ex:graphdb)，该节点通过RDF内置属性rdf:subject、rdf:predicate和rdf:object分别与代表的三元组的主语、谓语和宾语建立起联系，这样三元组(ex:participate，权重，0.4)就实现了为原三元组增加边属性的效果。,ex:participate,,,为原三元组增加边属性的效果,
例如在图3-2中，引入节点ex:participate代表三元组(ex:zhangsan，参加，ex:graphdb)，该节点通过RDF内置属性rdf:subject、rdf:predicate和rdf:object分别与代表的三元组的主语、谓语和宾语建立起联系，这样三元组(ex:participate，权重，0.4)就实现了为原三元组增加边属性的效果。,等价,,,equivalent,
图3-2RDF图中边属性的表示2.属性图属性图可以说是目前被图数据库业界采纳最广的一种图数据模型[3]。,属性图,,,目前被图数据库业界采纳最广的一种图数据模型[3]。,
图3-2RDF图中边属性的表示2.属性图属性图可以说是目前被图数据库业界采纳最广的一种图数据模型[3]。,属性图,,,property graph,
属性图由节点集和边集组成，且满足如下性质：（1）每个节点具有唯一的id；（2）每个节点具有若干条出边；（3）每个节点具有若干条入边；（4）每个节点具有一组属性，每个属性是一个键值对；（5）每条边具有唯一的id；（6）每条边具有一个头节点；（7）每条边具有一个尾节点；（8）每条边具有一个标签，表示联系；（9）每条边具有一组属性，每个属性是一个键值对。,属性图,,,property graph,
图3-3给出的属性图不仅表达了RDF图的全部数据，而且还增加了边上的“权重”属性。,属性图,,,RDF图的全部数据,
图3-3给出的属性图不仅表达了RDF图的全部数据，而且还增加了边上的“权重”属性。,属性图,,,边上的“权重”属性,
图3-3属性图示例图3-3的每个节点和每条边均有id。,图3-3,,,属性图,
图3-3属性图示例图3-3的每个节点和每条边均有id。,图3-3的每个节点,,,属性图示例,
图3-3属性图示例图3-3的每个节点和每条边均有id。,图3-3的每条边,,,id,
"遵照属性图的要素，节点4的出边集合为{边10,边11}，入边集合为{边8}，属性集合为{姓名=""王五""，年龄=32}；边11的头节点是节点3，尾节点是节点4，标签是“参加”，属性集合为{权重=0.4}。",节点4的出边集合,,,"{边10,边11}",
"遵照属性图的要素，节点4的出边集合为{边10,边11}，入边集合为{边8}，属性集合为{姓名=""王五""，年龄=32}；边11的头节点是节点3，尾节点是节点4，标签是“参加”，属性集合为{权重=0.4}。",节点4的入边集合,,,{边8},
"遵照属性图的要素，节点4的出边集合为{边10,边11}，入边集合为{边8}，属性集合为{姓名=""王五""，年龄=32}；边11的头节点是节点3，尾节点是节点4，标签是“参加”，属性集合为{权重=0.4}。",节点4的属性集合,,,"{姓名=""王五""，年龄=32}",
3.1.2知识图谱查询语言在知识图谱数据模型上，需要借助知识图谱查询语言进行查询操作。,知识图谱查询语言,,,知识图谱数据模型,
目前，RDF图上的查询语言是SPARQL；属性图上的查询语言常用的是Cypher和Gremlin。,SPARQL,,,RDF图上的查询语言,
目前，RDF图上的查询语言是SPARQL；属性图上的查询语言常用的是Cypher和Gremlin。,SPARQL,,,查询语言,
目前，RDF图上的查询语言是SPARQL；属性图上的查询语言常用的是Cypher和Gremlin。,Cypher,,,属性图上的查询语言,
1.SPARQLSPARQL是W3C制定的RDF图数据的标准查询语言[4]。,SPARQL,,,W3C制定的RDF图数据的标准查询语言,
SPARQL从语法上借鉴了SQL，同样属于声明式查询语言。,SPARQL,,,声明式查询语言,
最新的SPARQL1.1版本为有效查询RDF图专门设计了三元组模式、子图模式、属性路径等多种查询机制。,SPARQL1.1,,,查询RDF图专门设计了三元组模式、子图模式、属性路径等多种查询机制,
最新的SPARQL1.1版本为有效查询RDF图专门设计了三元组模式、子图模式、属性路径等多种查询机制。,三元组模式,,,triadic pattern,
最新的SPARQL1.1版本为有效查询RDF图专门设计了三元组模式、子图模式、属性路径等多种查询机制。,子图模式,,,subgraph pattern,
最新的SPARQL1.1版本为有效查询RDF图专门设计了三元组模式、子图模式、属性路径等多种查询机制。,属性路径,,,property path,
几乎全部的RDF三元组数据库都实现了SPARQL语言。,SPARQL,,,RDF三元组数据库,
下面通过几个例子介绍SPARQL语言的基本功能。,SPARQL语言,,,几个例子介绍SPARQL语言的基本功能,
查询使用的是RDF图数据。,查询,,,RDF图数据,
"（1）查询程序员张三认识的其他程序员输出：说明：PREFIX关键字将ex定义为URI“http://www.example.com/”的前缀缩写，WHERE关键字指明了查询的三元组模式（Triple_Pattern）,SELECT关键字列出了要返回的结果变量。",查询程序员张三认识的其他程序员,,,属于查询其他程序员,
三元组模式查询是最基本的SPARQL查询。,SPARQL查询,,,三元组模式查询,
三元组模式查询是最基本的SPARQL查询。,SPARQL查询,,,三元组模式查询,
（2）查询程序员张三认识的其他程序员参加的项目输出：说明：这是由两个三元组模式组成的一个基本图模式（Basic_Graph_Pattern）查询，简称为BGP查询。,BGP查询,,,两个三元组模式组成的一个基本图模式（Basic_Graph_Pattern）查询，简称为BGP查询。,
（2）查询程序员张三认识的其他程序员参加的项目输出：说明：这是由两个三元组模式组成的一个基本图模式（Basic_Graph_Pattern）查询，简称为BGP查询。,BGP查询,,,（2）查询程序员张三认识的其他程序员参加的项目,
实际上，这两个三元组模式之间通过公共变量？p连接为一个链式查询。,三元组模式,,,链式查询,
实际上，这两个三元组模式之间通过公共变量？p连接为一个链式查询。,链式查询,,,chain query,
（3）查询节点ex:zhangsan认识的30岁以上的程序员参加的项目名称输出：说明：关键字FILTER用于指明过滤条件，对变量匹配结果进行按条件筛选。,查询节点,,,ex:zhangsan认识的30岁以上的程序员参加的项目名称,
这里既有？p和？pr分别作为两个三元组模式的宾语和主语连接起来的链式模式，也有？p作为两个三元组模式的主语连接起来的星形结构，该查询是一个更加一般的BGP查询。,p,,,两个三元组模式的链式模式,
这里既有？p和？pr分别作为两个三元组模式的宾语和主语连接起来的链式模式，也有？p作为两个三元组模式的主语连接起来的星形结构，该查询是一个更加一般的BGP查询。,p,,,星形结构,
这里既有？p和？pr分别作为两个三元组模式的宾语和主语连接起来的链式模式，也有？p作为两个三元组模式的主语连接起来的星形结构，该查询是一个更加一般的BGP查询。,三元组模式,,,链式模式,
这里既有？p和？pr分别作为两个三元组模式的宾语和主语连接起来的链式模式，也有？p作为两个三元组模式的主语连接起来的星形结构，该查询是一个更加一般的BGP查询。,三元组模式,,,星形结构,
实际上，BGP查询相当于一个带有变量的查询图，查询过程是在数据图中寻找与查询图映射Isomorphism）或子图同态匹配的所有子图，等价于图论中的子图同构（Subgraph（Subgraph_Homomorphism）问题[5]，所以也将BGP查询称为子图匹配查询。,BGP查询,,,子图匹配查询,
实际上，BGP查询相当于一个带有变量的查询图，查询过程是在数据图中寻找与查询图映射Isomorphism）或子图同态匹配的所有子图，等价于图论中的子图同构（Subgraph（Subgraph_Homomorphism）问题[5]，所以也将BGP查询称为子图匹配查询。,BGP查询,,,子图匹配查询,
（4）查询年龄为29的参加了项目ex:graphdb的程序员参加的其他项目及其直接或间接认识的程序员参加的项目输出：说明：这里使用了Path）机制，ex:knows*/ex:participate类似于正则表达式，其表示经过0条、1条或多条ex:knows边，再经过一条ex:participate边。,ex:graphdb,,,查询年龄为29的参加了项目ex:graphdb的程序员参加的其他项目及其直接或间接认识的程序员参加的项目,
（4）查询年龄为29的参加了项目ex:graphdb的程序员参加的其他项目及其直接或间接认识的程序员参加的项目输出：说明：这里使用了Path）机制，ex:knows*/ex:participate类似于正则表达式，其表示经过0条、1条或多条ex:knows边，再经过一条ex:participate边。,ex:graphdb,,,图数据库,
1.1引入的属性路径（Property_SPARQL_SPARQL实际上是一整套知识服务标准体系。,Property_SPARQL_SPARQL,,,知识服务标准体系,
SPARQL1.1语言的语法和语义的完整定义请参见W3C的推荐标准“SPARQL1.1查询语言”[4]，该标准连同其他10个推荐标准共同组成了SPARQL知识平台，包括查询[4]、更新[6]、服务描述[7]、联邦查询[8]、查询结果格式[9]、蕴涵推理[10]和接口协议[11]等。,SPARQL1.1查询语言,,,SPARQL,
开放的SPARQL学习教程有WikiBooks_SPARQL教程[12]、WikidataSPARQL教程[13]和Apache_Jena_SPARQL教程[14]等。,开放的SPARQL学习教程,,,WikiBooks_SPARQL教程[12],
开放的SPARQL学习教程有WikiBooks_SPARQL教程[12]、WikidataSPARQL教程[13]和Apache_Jena_SPARQL教程[14]等。,开放的SPARQL学习教程,,,WikidataSPARQL教程[13],
开放的SPARQL学习教程有WikiBooks_SPARQL教程[12]、WikidataSPARQL教程[13]和Apache_Jena_SPARQL教程[14]等。,开放的SPARQL学习教程,,,Apache_Jena_SPARQL教程[14],
开放的SPARQL学习教程有WikiBooks_SPARQL教程[12]、WikidataSPARQL教程[13]和Apache_Jena_SPARQL教程[14]等。,WikiBooks_SPARQL教程,,,WikiBooks SPARQL教程,
开放的SPARQL学习教程有WikiBooks_SPARQL教程[12]、WikidataSPARQL教程[13]和Apache_Jena_SPARQL教程[14]等。,WikidataSPARQL教程,,,WikidataSPARQL教程,
开放的SPARQL学习教程有WikiBooks_SPARQL教程[12]、WikidataSPARQL教程[13]和Apache_Jena_SPARQL教程[14]等。,Apache_Jena_SPARQL教程,,,Apache Jena SPARQL教程,
本章3.4节将以Apache_Jena作为实践工具，讲解如何使用SPARQL进行知识图谱的查询和更新。,本章3.4节,,,讲解如何使用SPARQL进行知识图谱的查询和更新,
2.CypherCypher最初是图数据库Neo4j中实现的属性图数据查询语言[15]。,Cypher,,,属性图数据查询语言,
2.CypherCypher最初是图数据库Neo4j中实现的属性图数据查询语言[15]。,Cypher,,,属性图数据查询语言,
与SPARQL一样，Cypher也是一种声明式语言，即用户只需要声明“查什么”，而无须关心“怎么查”，这就好比乘坐出租车到一个目的地，只需要告诉司机要到哪里，具体的行车路线可由司机安排，乘客并不需要关心。,Cypher,,,声明式语言,
与SPARQL一样，Cypher也是一种声明式语言，即用户只需要声明“查什么”，而无须关心“怎么查”，这就好比乘坐出租车到一个目的地，只需要告诉司机要到哪里，具体的行车路线可由司机安排，乘客并不需要关心。,Cypher,,,声明式语言,
这类语言的优点是便于用户学习掌握，同时给予数据库进行查询优化的空间，缺点是不能满足高级用户导航式查询的要求，数据库规划的查询执行计划有可能并不是最优方案。,数据库查询语言,,,便于用户学习掌握同时给予数据库进行查询优化的空间,
2015年，Neo4j公司发起开源项目openCypher[16]，旨在对Cypher进行标准化工作，为其他实现者提供语法和语义的参考标准。,openCypher,,,Cypher标准化工作,
虽然Cypher的发展目前仍由Neo4j主导，但包括SAP_HANA_Graph[17]、Redis_Graph[18]、AgensGraph[19]和Memgraph[20]等在内的图数据库产品已经实现了Cypher。,Cypher,,,Neo4j主导的图数据库产品,
下面通过例子了解Cypher语言的基本功能。,Cypher,,,语言的基本功能,
使用的知识图谱是图3-3中的属性图。,图3-3中的属性图,,,使用的知识图谱,
（1）查询图中的所有程序员节点输出：说明：MATCH关键字指明需要匹配的模式，这里将节点分为了程序员和项目两类，p作为查询变量会依次绑定到每个类型为Programmer的节点，RETURN关键字返回变量p的值作为查询结果。,MATCH,,,查询图中的所有程序员节点,
（1）查询图中的所有程序员节点输出：说明：MATCH关键字指明需要匹配的模式，这里将节点分为了程序员和项目两类，p作为查询变量会依次绑定到每个类型为Programmer的节点，RETURN关键字返回变量p的值作为查询结果。,查询图中的所有程序员节点,,,输出：说明：MATCH关键字指明需要匹配的模式，这里将节点分为了程序员和项目两类，p作为查询变量会依次绑定到每个类型为Programmer的节点，RETURN关键字返回变量p的值作为查询结果。,
（2）查询程序员与“图数据库”项目之间的边输出：说明：此查询返回边及其属性，程序员类型节点与图数据库项目节点之前存在3条标签为参加的边。,程序员,,,“图数据库”项目,
（2）查询程序员与“图数据库”项目之间的边输出：说明：此查询返回边及其属性，程序员类型节点与图数据库项目节点之前存在3条标签为参加的边。,等价,,,equivalence,
（2）查询程序员与“图数据库”项目之间的边输出：说明：此查询返回边及其属性，程序员类型节点与图数据库项目节点之前存在3条标签为参加的边。,英文名,,,equivalence,
（3）查询从节点1出发的标签为“认识”的边输出：说明：从节点1出发沿“认识”边到达节点2和节点4。,查询从节点1出发的标签为“认识”的边,,,从节点1出发沿“认识”边到达节点2和节点4,
（3）查询从节点1出发的标签为“认识”的边输出：说明：从节点1出发沿“认识”边到达节点2和节点4。,等价,,,equivalence,
（4）查询节点1认识的30岁以上的程序员参加的项目名称输出：说明：该查询MATCH子句等价于SPARQLBGP查询的链式查询。,查询节点1认识的30岁以上的程序员参加的项目名称,,,SPARQLBGP查询的链式查询,
（5）查询年龄为29的参加了项目3的程序员参加的其他项目及其直接或间接认识的程序员参加的项目输出：说明：“：认识*0..”表示由一个节点到达另一个节点的路径包括0个、1个或多个“认识”边。,查询年龄为29的参加了项目3的程序员参加的其他项目,,,参加的其他项目,
（5）查询年龄为29的参加了项目3的程序员参加的其他项目及其直接或间接认识的程序员参加的项目输出：说明：“：认识*0..”表示由一个节点到达另一个节点的路径包括0个、1个或多个“认识”边。,查询年龄为29的参加了项目3的程序员,,,直接或间接认识的程序员参加的项目,
（5）查询年龄为29的参加了项目3的程序员参加的其他项目及其直接或间接认识的程序员参加的项目输出：说明：“：认识*0..”表示由一个节点到达另一个节点的路径包括0个、1个或多个“认识”边。,等价,,,等价,
对比该查询的SPARQL版本。,查询的SPARQL版本。,,,对比该查询的SPARQL版本。,
3.GremlinGremlin是Apache_TinkerPop图计算框架[21]提供的属性图查询语言[22]。,Gremlin,,,属性图查询语言,
3.GremlinGremlin是Apache_TinkerPop图计算框架[21]提供的属性图查询语言[22]。,Gremlin,,,属性图查询语言,
ApacheTinkerPop被设计为访问图数据库的通用API接口，其作用类似于关系数据库上的JDBC接口。,ApacheTinkerPop,,,访问图数据库的通用API接口,
Gremlin的定位是图遍历语言，其执行机制好比是一个人置身于图中沿着有向边，从一个节点到另一个节点进行导航式的游走。,Gremlin,,,图遍历语言,
Gremlin的定位是图遍历语言，其执行机制好比是一个人置身于图中沿着有向边，从一个节点到另一个节点进行导航式的游走。,Gremlin,,,图遍历语言,
这种执行方式决定了用户使用Gremlin需要指明具体的导航步骤，这和自己驾驶汽车到一个目的地需要知道行车路线是一个道理，所以将Gremlin归为过程式语言，即需要明确“怎么做”。,Gremlin,,,过程式语言,
这类语言的优点是可以时刻知道自己在图中所处的位置，以及是如何到达该位置的；缺点是用户需要“认识路”！与受到SQL影响的声明式语言SPARQL和Cypher不同，Gremlin更像一种函数式的编程语言接口。,Gremlin,,,函数式的编程语言接口,
这类语言的优点是可以时刻知道自己在图中所处的位置，以及是如何到达该位置的；缺点是用户需要“认识路”！与受到SQL影响的声明式语言SPARQL和Cypher不同，Gremlin更像一种函数式的编程语言接口。,Gremlin,,,函数式的编程语言接口,
下面通过几个例子认识Gremlin语言，假设用g代表图3-3中的属性图。,Gremlin,,,图查询语言,
（1）列出图中所有节点的属性输出：说明：V表示节点集合。,V,,,列出图中所有节点的属性,
（1）列出图中所有节点的属性输出：说明：V表示节点集合。,V,,,节点集合,
（2）列出图中所有的边输出：说明：E表示边集合。,E,,,边,
（2）列出图中所有的边输出：说明：E表示边集合。,E,,,边,
（3）查询从节点1出发的标签为“认识”的边输出：说明：v(1)选取id为1的节点；outE表示节点的出边集合，outE(’认识’)是标签为“认识”的出边集合。,等价,,,equivalence,
（4）查询节点1认识的30岁以上的程序员参加的项目名称输出：说明：out(’认识’)选取标签为“认识”的出边指向的邻接节点集合；filter为过滤器，filter{it.年龄>30}的意思是后面只处理年龄大于30的节点。,认识,,,选取标签为“认识”的出边指向的邻接节点集合,
对比该查询的SPARQL和Cypher版本。,SPARQL,,,对比该查询的SPARQL和Cypher版本。,
对比该查询的SPARQL和Cypher版本。,Cypher,,,对比该查询的SPARQL和Cypher版本。,
3.2常见知识图谱存储方法本节介绍三类知识图谱数据库：基于关系数据库的存储方案、面向RDF的三元组数据库和原生图数据库，多数系统给出了演示操作步骤。,基于关系数据库的存储方案,,,based on relation database storage,
3.2.1基于关系数据库的存储方案关系数据库拥有40多年的发展历史，从理论到实践有着一整套成熟体系。,关系数据库,,,关系数据库的存储方案,
在历史上，关系数据库曾经取代了层次数据库和网状数据库；成功吸收容纳了面向对象数据库和XML数据库，成为现今数据管理的主流数据库产品。,关系数据库,,,历史数据管理的主流数据库产品,
商业数据库包括Oracle、DB2和SQL_Server等，开源数据库包括PostgreSQL和MySQL等。,商业数据库,,,Oracle,
商业数据库包括Oracle、DB2和SQL_Server等，开源数据库包括PostgreSQL和MySQL等。,商业数据库,,,DB2,
商业数据库包括Oracle、DB2和SQL_Server等，开源数据库包括PostgreSQL和MySQL等。,商业数据库,,,SQL_Server,
商业数据库包括Oracle、DB2和SQL_Server等，开源数据库包括PostgreSQL和MySQL等。,开源数据库,,,PostgreSQL,
商业数据库包括Oracle、DB2和SQL_Server等，开源数据库包括PostgreSQL和MySQL等。,开源数据库,,,MySQL,
因此基于历史上的成功经验，人们容易想到使用关系数据库存储知识图谱。,知识图谱,,,关系数据库,
因此基于历史上的成功经验，人们容易想到使用关系数据库存储知识图谱。,关系数据库,,,relational database,
基于关系数据库的存储方案是目前知识图谱采用的一种主要存储方法。,基于关系数据库的存储方案,,,知识图谱存储方法,
本小节将按照时间发展顺序简要介绍各种基于关系表的知识图谱存储结构，包括三元组表、水平表、属性表、垂直划分、六重索引和DB2RDF。,基于关系表的知识图谱存储结构,,,三元组表,
本小节将按照时间发展顺序简要介绍各种基于关系表的知识图谱存储结构，包括三元组表、水平表、属性表、垂直划分、六重索引和DB2RDF。,基于关系表的知识图谱存储结构,,,基于关系表的知识图谱存储结构,
如图3-4所示，下面以摘自DBpedia数据集[23]的RDF数据作为知识图谱进行讲解和举例。,RDF数据,,,知识图谱进行讲解和举例,
该知识图谱描述了IBM公司及其创始人Charles_Flint和Google公司及其创始人LarryPage的一些属性和联系。,IBM公司,,,知识图谱,
对于其他格式的知识图谱，这些存储方案同样适用。,知识图谱的存储方案,,,其他格式的知识图谱,
图3-4摘自DBpedia数据集的RDF知识图谱1.三元组表三元组表是将知识图谱存储到关系数据库的最简单、最直接的办法，就是在关系数据库中建立一张具有3列的表，该表的模式为：三元组表(主语，谓语，宾语)将知识图谱中的每条三元组存储为三元组表中的一行记录。,三元组表,,,triple table,
表3-1是图3-4中知识图谱对应的三元组表，由于一共有21行，限于篇幅仅列出了前5行。,表3-1,,,图3-4中知识图谱对应的三元组表,
表3-1是图3-4中知识图谱对应的三元组表，由于一共有21行，限于篇幅仅列出了前5行。,图3-4中知识图谱,,,表3-1,
表3-1三元组表三元组表存储方案虽然简单明了，但三元组表的行数与知识图谱的边数一样，其最大问题在于将知识图谱查询翻译为SQL查询后的三元组表自连接。,三元组表,,,存储方案,
表3-1三元组表三元组表存储方案虽然简单明了，但三元组表的行数与知识图谱的边数一样，其最大问题在于将知识图谱查询翻译为SQL查询后的三元组表自连接。,三元组表,,,triad table,
例如，如图3-5所示的SPARQL查询是查找1850年出生且1934年逝世的创办了某公司的人，翻译为等价的SQL查询后如图3-6所示，这里三元组表的表名为t。,SPARQL查询,,,查找1850年出生且1934年逝世的创办了某公司的人,
例如，如图3-5所示的SPARQL查询是查找1850年出生且1934年逝世的创办了某公司的人，翻译为等价的SQL查询后如图3-6所示，这里三元组表的表名为t。,SPARQL查询,,,查找1850年出生且1934年逝世的创办了某公司的人,
一般自连接的数量与SPARQL中三元组模式数量相当。,自连接,,,SPARQL中三元组模式数量相当,
当三元组表规模较大时，多个自连接操作会使SQL查询性能低下。,自连接操作,,,降低SQL查询性能低下,
采用三元组表存储方案的代表是RDF数据库系统3store[24]。,RDF数据库系统3store,,,采用三元组表存储方案,
图3-5一个星形SPARQL查询图3-6三元组表方案中SPARQL查询转换为等价的SQL查询2.水平表水平表存储方案同样非常简单，与三元组表不同，其每行记录存储一个知识图谱中一个主语的所有谓语和宾语。,SPARQL查询,,,一个星形SPARQL查询,
图3-5一个星形SPARQL查询图3-6三元组表方案中SPARQL查询转换为等价的SQL查询2.水平表水平表存储方案同样非常简单，与三元组表不同，其每行记录存储一个知识图谱中一个主语的所有谓语和宾语。,SPARQL查询,,,一个星形SPARQL查询,
实际上，水平表就相当于知识图谱的邻接表。,水平表,,,知识图谱的邻接表,
表3-2是图3-4中知识图谱对应的水平表，共有5行、13列，限于篇幅省略了若干列。,表3-2,,,图3-4中知识图谱对应的水平表,
表3-2是图3-4中知识图谱对应的水平表，共有5行、13列，限于篇幅省略了若干列。,水平表,,,table,
不难看出，水平表的列数是知识图谱中不同谓语的数量，行数是知识图谱中不同主语的数量。,水平表的列数,,,知识图谱中不同谓语的数量,
不难看出，水平表的列数是知识图谱中不同谓语的数量，行数是知识图谱中不同主语的数量。,水平表的行数,,,知识图谱中不同主语的数量,
不难看出，水平表的列数是知识图谱中不同谓语的数量，行数是知识图谱中不同主语的数量。,水平表的列数,,,知识图谱中不同谓语的数量,
不难看出，水平表的列数是知识图谱中不同谓语的数量，行数是知识图谱中不同主语的数量。,水平表的行数,,,知识图谱中不同主语的数量,
表3-2水平表在水平表存储方案中，图3-5所示的SPARQL查询可以等价地翻译为图3-7中的SQL查询。,水平表存储方案,,,图3-5所示的SPARQL查询,
表3-2水平表在水平表存储方案中，图3-5所示的SPARQL查询可以等价地翻译为图3-7中的SQL查询。,水平表存储方案,,,水平表存储方案,
这里水平表的表名为t。,水平表,,,t,
可见，与三元组表相比，水平表的查询大为简化，仅需单表查询即可完成该任务，不用进行连接操作。,水平表,,,单表查询完成该任务，不用进行连接操作,
可见，与三元组表相比，水平表的查询大为简化，仅需单表查询即可完成该任务，不用进行连接操作。,水平表,,,level table,
采用水平表存储方案的代表是早期的RDF数据库系统DLDB[25]。,DLDB,,,采用水平表存储方案,
采用水平表存储方案的代表是早期的RDF数据库系统DLDB[25]。,采用水平表存储方案,,,DLDB,
3.属性表属性表（Property_Table）存储方案是对水平表的细化，将同类主语分到一个表中，不同类主语分到不同表中。,属性表属性表,,,水平表的细化,
3.属性表属性表（Property_Table）存储方案是对水平表的细化，将同类主语分到一个表中，不同类主语分到不同表中。,属性表属性表,,,Property_Table,
这样就解决了表中列的数目过多的问题。,表中的列,,,表中列的数目过多的问题,
对于图3-5中的SPARQL查询，在属性表存储方案上等价的SQL查询如图3-9所示；该查询与图3-7中水平表上查询的唯一区别是将表名由t变为了person。,图3-5中的SPARQL查询,,,属性表存储方案上等价的SQL查询,
对于图3-5中的SPARQL查询，在属性表存储方案上等价的SQL查询如图3-9所示；该查询与图3-7中水平表上查询的唯一区别是将表名由t变为了person。,SPARQL查询,,,在属性表存储方案上等价的SQL查询,
图3-8属性表图3-9属性表方案中SPARQL查询转换为等价的SQL查询属性表既克服了三元组表的自连接问题，又解决了水平表中列数目过多的问题。,属性表,,,SPARQL查询转换为等价的SQL查询,
图3-8属性表图3-9属性表方案中SPARQL查询转换为等价的SQL查询属性表既克服了三元组表的自连接问题，又解决了水平表中列数目过多的问题。,属性表,,,SPARQL查询,
实际上，水平表方案是属性表存储方案的一种极端情况，即水平表是将所有主语划归为一类，因此属性表中的空值问题与水平表相比会大为缓解。,水平表方案,,,属性表存储方案,
实际上，水平表方案是属性表存储方案的一种极端情况，即水平表是将所有主语划归为一类，因此属性表中的空值问题与水平表相比会大为缓解。,水平表方案,,,属性表存储方案的一种极端情况,
采用属性表存储方案的代表是RDF三元组库Jena[26]。,RDF三元组库Jena,,,采用属性表存储方案,
采用属性表存储方案的代表是RDF三元组库Jena[26]。,RDF三元组库Jena,,,采用属性表存储方案,
4.垂直划分垂直划分（Vertical_Partitioning）存储方案是由美国麻省理工学院的Abadi等人在2007年提出的RDF数据存储方法[27]。,垂直划分,,,存储方案,
4.垂直划分垂直划分（Vertical_Partitioning）存储方案是由美国麻省理工学院的Abadi等人在2007年提出的RDF数据存储方法[27]。,垂直划分,,,Vertical_Partitioning,
该方法以三元组的谓语作为划分维度，将RDF知识图谱划分为若干张只包含(主语，宾语)两列的表，表的总数量即知识图谱中不同谓语的数量；也就是说，为每种谓语建立一张表，表中存放知识图谱中由该谓语连接的主语和宾语值。,RDF知识图谱的划分方法,,,为每种谓语建立一张表，表中存放知识图谱中由该谓语连接的主语和宾语值,
该方法以三元组的谓语作为划分维度，将RDF知识图谱划分为若干张只包含(主语，宾语)两列的表，表的总数量即知识图谱中不同谓语的数量；也就是说，为每种谓语建立一张表，表中存放知识图谱中由该谓语连接的主语和宾语值。,三元组的谓语,,,划分维度,
对于图3-5中的SPARQL查询，在垂直划分存储方案中等价的SQL查询如图3-11所示；该查询涉及3张谓语表born、died和founder的连接操作。,SPARQL查询,,,垂直划分存储方案,
对于图3-5中的SPARQL查询，在垂直划分存储方案中等价的SQL查询如图3-11所示；该查询涉及3张谓语表born、died和founder的连接操作。,SPARQL查询,,,等价的SQL查询,
由于谓语表中的行都是按照主语列进行排序的，可以快速执行这种以“主语-主语”作为连接条件的查询操作，而这种连接操作又是常用的。,谓语表,,,查询操作,
由于谓语表中的行都是按照主语列进行排序的，可以快速执行这种以“主语-主语”作为连接条件的查询操作，而这种连接操作又是常用的。,谓语表,,,query operation,
与之前基于关系数据库的知识图谱存储方案相比，垂直划分有一些突出的优点：谓语表仅存储出现在知识图谱中的三元组，解决了空值问题；一个主语的一对多联系或多值属性存储在谓语表的多行中，解决了多值问题；每个谓语表都按主语列的值进行排序，能够使用归并排序连接（Merge-sort_Join）快速执行不同谓语表的连接查询操作。,谓语表,,,mapping table,
与之前基于关系数据库的知识图谱存储方案相比，垂直划分有一些突出的优点：谓语表仅存储出现在知识图谱中的三元组，解决了空值问题；一个主语的一对多联系或多值属性存储在谓语表的多行中，解决了多值问题；每个谓语表都按主语列的值进行排序，能够使用归并排序连接（Merge-sort_Join）快速执行不同谓语表的连接查询操作。,谓语表,,,mapping table,
图3-10垂直划分存储方案图3-11垂直划分方案中等价的SQL查询不过，垂直划分存储方案依然存在几个缺点：需要创建的表的数目与知识图谱中不同谓语数目相等，而大规模的真实知识图谱（如DBpedia、YAGO、Wikidata等）中谓语数目可能超过几千个，在关系数据库中维护如此规模的表需要很大的开销；越是复杂的知识图谱查询操作，需要执行的表连接操作数量越多，而对于未指定谓语的三元组查询，将发生需要连接全部谓语表进行查询的极端情况；谓语表的数量越多，数据更新维护代价越大，对于一个主语的更新将涉及多张表，产生很高的更新时I/O开销。,垂直划分存储方案,,,vertical partitioning storage,
采用垂直划分存储方案的代表数据库是SW-Store[28]。,SW-Store,,,采用垂直划分存储方案的代表数据库,
不难看出，其中spo表就是原来的三元组表。,spo表,,,三元组表,
不难看出，其中spo表就是原来的三元组表。,spo表,,,三元组表,
六重索引通过6张表的连接操作不仅缓解了三元组表的单表自连接问题，而且加速了某些典型知识图谱查询的效率。,六重索引,,,缓解三元组表的单表自连接问题以及加速某些典型知识图谱查询的效率,
六重索引通过6张表的连接操作不仅缓解了三元组表的单表自连接问题，而且加速了某些典型知识图谱查询的效率。,六重索引,,,six-level index,
使用六重索引方法的典型系统有RDF-3X[28]和Hexastore[29]。,RDF-3X,,,六重索引方法,
使用六重索引方法的典型系统有RDF-3X[28]和Hexastore[29]。,六重索引方法的典型系统,,,RDF-3X,
使用六重索引方法的典型系统有RDF-3X[28]和Hexastore[29]。,六重索引方法的典型系统,,,Hexastore,
表3-3三元组模式查询能够使用的索引表图3-12一个链式SPARQL查询六重索引存储方案存在的问题包括：虽然部分缓解了三元组表的单表自连接问题，但需要花费6倍的存储空间开销、索引维护代价和数据更新时的一致性维护代价，随着知识图谱规模的增大，该问题会愈加突出；当知识图谱查询变得复杂时，会产生大量的连接索引表查询操作，索引表的自连接依然不可避免。,索引表,,,index table,
6.DB2RDFDB2RDF是由IBM研究中心于2013年提出的一种面向实体的RDF知识图谱存储方案[30]，该方案是以往RDF关系存储方案的一种权衡折中，既具备了三元组表、属性表和垂直划分方案的部分优点，又克服了这些方案的部分缺点。,DB2RDF,,,面向实体的RDF知识图谱存储方案,
三元组表的优势在于“行维度”上的灵活性，即存储模式不会随行的增加而变化；DB2RDF方案将这种灵活性扩展到“列维度”上，即将表的列作为谓语和宾语的存储位置，而不将列与谓语进行绑定。,三元组表的优势,,,flexibility on row dimension,
三元组表的优势在于“行维度”上的灵活性，即存储模式不会随行的增加而变化；DB2RDF方案将这种灵活性扩展到“列维度”上，即将表的列作为谓语和宾语的存储位置，而不将列与谓语进行绑定。,DB2RDF方案,,,将表的列作为谓语和宾语的存储位置,
当插入数据时，将谓语动态地映射存储到某列；方案能够确保将相同的谓语映射到同一组列上。,方案,,,将相同的谓语映射到同一组列上,
当插入数据时，将谓语动态地映射存储到某列；方案能够确保将相同的谓语映射到同一组列上。,将谓语动态地映射存储到某列,,,map the predicate dynamically to a column,
当插入数据时，将谓语动态地映射存储到某列；方案能够确保将相同的谓语映射到同一组列上。,方案,,,ensure that the same predicate is mapped to the same group of columns,
DB2RDF存储方案由4张表组成，即dph表、rph表、ds表和rs表；图3-13给出了图3-4中知识图谱对应的DB2RDF存储方案。,DB2RDF存储方案,,,DB2RDF storage scheme,
"dph（direct_primary_hash）是存储方案的主表，该表中一行存储一个主语（主语列）及其全部谓语（predi列）和宾语（vali列）,0≤i≤k,k为图着色结果值或某个给定值。",dph,,,存储方案的主表,
"dph（direct_primary_hash）是存储方案的主表，该表中一行存储一个主语（主语列）及其全部谓语（predi列）和宾语（vali列）,0≤i≤k,k为图着色结果值或某个给定值。",dph,,,direct_primary_hash,
如果一个主语的谓语数量大于k，则一行不足以容纳下一个实体，将在下一行存储第k+1到2k个谓语和宾语，以此类推，这种情况叫作溢出。,溢出,,,主语的谓语数量大于k,
如果一个主语的谓语数量大于k，则一行不足以容纳下一个实体，将在下一行存储第k+1到2k个谓语和宾语，以此类推，这种情况叫作溢出。,溢出,,,overflow,
spill列是溢出标志，即对于一行能存储下的实体，该行spill列为0，对于溢出的实体，该实体所有行的spill列为1。,spill列,,,溢出标志,
spill列是溢出标志，即对于一行能存储下的实体，该行spill列为0，对于溢出的实体，该实体所有行的spill列为1。,spill列,,,溢出标志,
例如，在图3-13的dph表中，除实体Android溢出外，其余实体均存储为一行。,图3-13的dph表,,,存储为一行,
例如，在图3-13的dph表中，除实体Android溢出外，其余实体均存储为一行。,实体Android溢出,,,Android溢出,
对于多值谓语的处理，引入ds（direct_secondary_hash）表。,ds表,,,多值谓语的处理,
当dph表中遇到一个多值谓语时，则在相应的宾语处生成一个唯一的id值；将该id值和每个对应的宾语存储为ds表的一行。,dph表,,,在相应的宾语处生成一个唯一的id值,
当dph表中遇到一个多值谓语时，则在相应的宾语处生成一个唯一的id值；将该id值和每个对应的宾语存储为ds表的一行。,dph表,,,将id值和每个对应的宾语存储为ds表的一行,
当dph表中遇到一个多值谓语时，则在相应的宾语处生成一个唯一的id值；将该id值和每个对应的宾语存储为ds表的一行。,等价,,,equivalent,
例如，在图3-13的dph表中，主语Google的谓语industry（pred1列）是多值谓语，则在其宾语列（val1）存储id值lid:1；在ds表中存储lid:1关联的两个宾语Software和Internet。,Google,,,多值谓语,
例如，在图3-13的dph表中，主语Google的谓语industry（pred1列）是多值谓语，则在其宾语列（val1）存储id值lid:1；在ds表中存储lid:1关联的两个宾语Software和Internet。,等价,,,等价,
实际上，dph表实现了列的共享：一方面，不同实体的相同谓语总是会被分配到相同的列上；另一方面，同一列中可以存储多个不同的谓语。,dph表,,,列的共享,
实际上，dph表实现了列的共享：一方面，不同实体的相同谓语总是会被分配到相同的列上；另一方面，同一列中可以存储多个不同的谓语。,dph表,,,等价,
例如，主语Charles_Flint和Larry_Page的谓语founder都被分配到pred3列，该列也存储了主语Android的谓语kernel和graphics。,pred3,,,founder,
例如，主语Charles_Flint和Larry_Page的谓语founder都被分配到pred3列，该列也存储了主语Android的谓语kernel和graphics。,pred3,,,kernel,
例如，主语Charles_Flint和Larry_Page的谓语founder都被分配到pred3列，该列也存储了主语Android的谓语kernel和graphics。,pred3,,,graphics,
正是由于DB2RDF方案具备“列共享”机制，才使得在关系表中最大列数目上限的情况下可以存储远超出该上限的谓语数目，也能够有效地解决水平表方案中存在的谓语稀疏性空值问题。,DB2RDF方案,,,“列共享”机制,
正是由于DB2RDF方案具备“列共享”机制，才使得在关系表中最大列数目上限的情况下可以存储远超出该上限的谓语数目，也能够有效地解决水平表方案中存在的谓语稀疏性空值问题。,DB2RDF方案,,,列共享,
在真实的知识图谱中，不同主语往往具有不同的谓语集合，例如，谓语born只有人才具有，谓语employees只有公司才具有，这也是能够实现列共享的原因所在。,谓语born,,,不同主语的谓语集合,
在真实的知识图谱中，不同主语往往具有不同的谓语集合，例如，谓语born只有人才具有，谓语employees只有公司才具有，这也是能够实现列共享的原因所在。,谓语born,,,出生,
在真实的知识图谱中，不同主语往往具有不同的谓语集合，例如，谓语born只有人才具有，谓语employees只有公司才具有，这也是能够实现列共享的原因所在。,谓语employees,,,员工,
图3-13DB2RDF方案从图数据模型的角度来看，dph表和ds表实际上存储了实体节点（主语）的出边信息（从主语经谓语到宾语）；为了提高查询处理效率，还需要存储实体节点的入边信息（从宾语经谓语到主语）。,dph表,,,图数据模型中存储实体节点出边信息,
图3-13DB2RDF方案从图数据模型的角度来看，dph表和ds表实际上存储了实体节点（主语）的出边信息（从主语经谓语到宾语）；为了提高查询处理效率，还需要存储实体节点的入边信息（从宾语经谓语到主语）。,dph表,,,出边信息,
图3-13DB2RDF方案从图数据模型的角度来看，dph表和ds表实际上存储了实体节点（主语）的出边信息（从主语经谓语到宾语）；为了提高查询处理效率，还需要存储实体节点的入边信息（从宾语经谓语到主语）。,ds表,,,出边信息,
图3-13DB2RDF方案从图数据模型的角度来看，dph表和ds表实际上存储了实体节点（主语）的出边信息（从主语经谓语到宾语）；为了提高查询处理效率，还需要存储实体节点的入边信息（从宾语经谓语到主语）。,dph表,,,入边信息,
图3-13DB2RDF方案从图数据模型的角度来看，dph表和ds表实际上存储了实体节点（主语）的出边信息（从主语经谓语到宾语）；为了提高查询处理效率，还需要存储实体节点的入边信息（从宾语经谓语到主语）。,ds表,,,入边信息,
为此，DB2RDF方案提供了rph（reverse_primary_hash）表和rs（reverse_secondary_hash）表，如图3-13所示。,rph表,,,DB2RDF方案,
DB2RDF方案中SPARQL查询转换为等价的SQL查询如图3-14所示。,DB2RDF方案中SPARQL查询,,,等价的SQL查询,
DB2RDF方案中SPARQL查询转换为等价的SQL查询如图3-14所示。,SPARQL查询,,,等价的SQL查询,
从中可以看出，对于知识图谱的星型查询，DB2RDF存储方案只需要查询dph表即可完成，无须进行连接操作。,DB2RDF存储方案,,,星型查询,
从中可以看出，对于知识图谱的星型查询，DB2RDF存储方案只需要查询dph表即可完成，无须进行连接操作。,DB2RDF存储方案,,,等价查询dph表,
图3-14DB2RDF方案中SPARQL查询转换为等价的SQL查询在DB2RDF方案中，谓语到列的映射是需要重点考虑的问题。,谓语到列的映射,,,DB2RDF方案中SPARQL查询转换为等价的SQL查询,
图3-14DB2RDF方案中SPARQL查询转换为等价的SQL查询在DB2RDF方案中，谓语到列的映射是需要重点考虑的问题。,谓语到列的映射,,,mapping,
因为关系表中最大列的数目是固定的，该映射的两个优化目标是：使用的列的数目不要超过某个值m；尽量减少将同一主语的两个不同谓语分配到同一列的情况，从而减少溢出现象，因为溢出会导致查询时发生自连接。,映射的两个优化目标,,,使用的列数目不要超过某个值m,
因为关系表中最大列的数目是固定的，该映射的两个优化目标是：使用的列的数目不要超过某个值m；尽量减少将同一主语的两个不同谓语分配到同一列的情况，从而减少溢出现象，因为溢出会导致查询时发生自连接。,映射的两个优化目标,,,尽量减少将同一主语的两个不同谓语分配到同一列的情况,
因为关系表中最大列的数目是固定的，该映射的两个优化目标是：使用的列的数目不要超过某个值m；尽量减少将同一主语的两个不同谓语分配到同一列的情况，从而减少溢出现象，因为溢出会导致查询时发生自连接。,映射的两个优化目标,,,使用的列的数目不要超过某个值m,
因为关系表中最大列的数目是固定的，该映射的两个优化目标是：使用的列的数目不要超过某个值m；尽量减少将同一主语的两个不同谓语分配到同一列的情况，从而减少溢出现象，因为溢出会导致查询时发生自连接。,映射的两个优化目标,,,尽量减少将同一主语的两个不同谓语分配到同一列的情况,
谓语到列映射的一种方法是使用一组散列函数，将谓语映射到一组列编号，并将谓语及其宾语存储到这组列中的第一个空列上；在一个主语对应的一行中，如果存储某谓语（及其宾语）时，散列函数计算得出的这组列中的所有列都被之前存储的该主语的谓语占用了，则产生溢出，到下一行存储该谓语。,谓语到列映射,,,一组散列函数,
谓语到列映射的一种方法是使用一组散列函数，将谓语映射到一组列编号，并将谓语及其宾语存储到这组列中的第一个空列上；在一个主语对应的一行中，如果存储某谓语（及其宾语）时，散列函数计算得出的这组列中的所有列都被之前存储的该主语的谓语占用了，则产生溢出，到下一行存储该谓语。,谓语到列映射,,,将谓语映射到一组列编号,
谓语到列映射的一种方法是使用一组散列函数，将谓语映射到一组列编号，并将谓语及其宾语存储到这组列中的第一个空列上；在一个主语对应的一行中，如果存储某谓语（及其宾语）时，散列函数计算得出的这组列中的所有列都被之前存储的该主语的谓语占用了，则产生溢出，到下一行存储该谓语。,谓语到列映射,,,将谓语及其宾语存储到这组列中的第一个空列上,
谓语到列映射的一种方法是使用一组散列函数，将谓语映射到一组列编号，并将谓语及其宾语存储到这组列中的第一个空列上；在一个主语对应的一行中，如果存储某谓语（及其宾语）时，散列函数计算得出的这组列中的所有列都被之前存储的该主语的谓语占用了，则产生溢出，到下一行存储该谓语。,谓语到列映射,,,"use a set of hash functions, to a group of column numbers, and the subject and object stored in this group of columns the first empty column",
谓语到列映射的一种方法是使用一组散列函数，将谓语映射到一组列编号，并将谓语及其宾语存储到这组列中的第一个空列上；在一个主语对应的一行中，如果存储某谓语（及其宾语）时，散列函数计算得出的这组列中的所有列都被之前存储的该主语的谓语占用了，则产生溢出，到下一行存储该谓语。,散列函数,,,将谓语映射到一组列编号，并将谓语及其宾语存储到这组列中的第一个空列上,
例如，表3-4给出了谓语到列映射的散列函数表，其中包括h2两个散列函数，映射了5个谓语到列编号组。,表3-4,,,谓语到列映射的散列函数表,
例如，表3-4给出了谓语到列映射的散列函数表，其中包括h2两个散列函数，映射了5个谓语到列编号组。,散列函数表,,,hash function table,
"现在开始存储以h1和Android作为主语的三元组：当存储(Android,developer,Google)时，在dph表中为主语Android插入一个新行，根据h1的值将谓语developer存入列pred1；当存储(Android,version,8.1)时，根据h1的值将谓语version存储列pred2；当存储(Android,kernel,Linux)时，谓语kernel被h1映射到列pred1，但该列已被占用，因而接着被h2映射到列pred3；当存储(Android,preceded,8.0)时，谓语preceded被h1映射到列predk；当存储(Android,graphics,OpenGL)时，谓语graphics被h1映射到列pred3，被h2映射到列pred2，但这两列都已被占用，这时产生溢出，将谓语graphics溢出到下一行的列pred3中存储，如图3-13的dph表所示。",等价,,,equivalent,
表3-4谓语到列映射的散列函数表如果可以事先获取知识图谱的一个子集，则可以利用知识图谱的内在结构优化谓语到列的映射。,谓语到列的映射,,,知识图谱的内在结构优化谓语到列的映射,
表3-4谓语到列映射的散列函数表如果可以事先获取知识图谱的一个子集，则可以利用知识图谱的内在结构优化谓语到列的映射。,谓语到列的映射,,,in-schema,
方法是将谓语到列的映射转化为图着色（Graph_Coloring）问题[31]。,将谓语到列的映射,,,图着色（Graph_Coloring）问题,
方法是将谓语到列的映射转化为图着色（Graph_Coloring）问题[31]。,图着色,,,Graph_Coloring,
将一个主语上出现的不同谓语称为共现谓语（Co-occurrence_Predicates），目标是让共现谓语着上不同颜色（映射到不同列中），非共现谓语可以着上相同颜色（映射到同一列中）。,共现谓语,,,将一个主语上出现的不同谓语称为,
将一个主语上出现的不同谓语称为共现谓语（Co-occurrence_Predicates），目标是让共现谓语着上不同颜色（映射到不同列中），非共现谓语可以着上相同颜色（映射到同一列中）。,共现谓语,,,Co-occurrence_Predicates,
将一个主语上出现的不同谓语称为共现谓语（Co-occurrence_Predicates），目标是让共现谓语着上不同颜色（映射到不同列中），非共现谓语可以着上相同颜色（映射到同一列中）。,非共现谓语,,,映射到同一列中,
为此，构建图着色算法的冲突图（Interference_Graph）：图中节点为知识图谱中的所有谓语；每对共现谓语节点之间由一条边相连。,图着色算法的冲突图,,,知识图谱中的所有谓语,
为此，构建图着色算法的冲突图（Interference_Graph）：图中节点为知识图谱中的所有谓语；每对共现谓语节点之间由一条边相连。,等价,,,equivalence,
图着色问题的要求是为冲突图中的节点着上颜色，使得每个节点的颜色不同于其任一邻接节点的颜色，并使所用颜色数最少；对应到谓语映射问题，即为冲突图中的谓语节点分配列，使得每个谓语映射到的列不同于其任一共现谓语映射到的列，并使所用的列数目最少。,图着色问题,,,谓语映射问题,
图着色问题的要求是为冲突图中的节点着上颜色，使得每个节点的颜色不同于其任一邻接节点的颜色，并使所用颜色数最少；对应到谓语映射问题，即为冲突图中的谓语节点分配列，使得每个谓语映射到的列不同于其任一共现谓语映射到的列，并使所用的列数目最少。,图着色问题,,,图着色,
可见，对于13个谓语，仅使用了5种颜色，即只需使用5列。,颜色,,,谓语,
可见，对于13个谓语，仅使用了5种颜色，即只需使用5列。,颜色,,,color,
需要指出的是，图着色是经典的NP难问题，对于规模较大的冲突图可用贪心算法（如Welsh-Powell算法）[32]求得近似解。,贪心算法,,,Welsh-Powell算法,
需要指出的是，图着色是经典的NP难问题，对于规模较大的冲突图可用贪心算法（如Welsh-Powell算法）[32]求得近似解。,贪心算法,,,Welsh-Powell算法,
图3-15冲突图如果在大规模真实知识图谱（如DBpedia）中，图着色所需颜色数量超过了关系数据表的列数上限m，则根据某种策略（如最频繁使用的前k个谓语）选取一个谓语子集，使得该谓语子集到列的映射满足图着色要求；对于不在该子集中的谓语，再使用前面提到的散列函数组策略进行映射。,图着色,,,graph coloring,
3.2.2面向RDF的三元组数据库由于RDF是W3C推荐的表示语义网上关联数据（Linked_Data）的标准格式，RDF也是表示和发布Web上知识图谱的最主要数据格式之一。,RDF,,,三元组数据库,
3.2.2面向RDF的三元组数据库由于RDF是W3C推荐的表示语义网上关联数据（Linked_Data）的标准格式，RDF也是表示和发布Web上知识图谱的最主要数据格式之一。,三元组数据库,,,TRIP,
面向RDF的三元组数据库是专门为存储大规模RDF数据而开发的知识图谱数据库，其支持RDF的标准查询语言SPARQL。,面向RDF的三元组数据库,,,知识图谱数据库,
面向RDF的三元组数据库是专门为存储大规模RDF数据而开发的知识图谱数据库，其支持RDF的标准查询语言SPARQL。,面向RDF的三元组数据库,,,SPARQL,
本节将分别介绍几种主要的开源和商业RDF三元组数据库。,开源RDF三元组数据库,,,本节将分别介绍几种主要的开源和商业RDF三元组数据库。,
主要的开源RDF三元组数据库包括：Apache旗下的Jena、Eclipse旗下的RDF4J以及源自学术界的RDF-3X和gStore；主要的商业RDF三元组数据库包括：Virtuoso、AllegroGraph、GraphDB和BlazeGraph。,RDF三元组数据库,,,Apache旗下的Jena,
主要的开源RDF三元组数据库包括：Apache旗下的Jena、Eclipse旗下的RDF4J以及源自学术界的RDF-3X和gStore；主要的商业RDF三元组数据库包括：Virtuoso、AllegroGraph、GraphDB和BlazeGraph。,RDF三元组数据库,,,Eclipse旗下的RDF4J,
主要的开源RDF三元组数据库包括：Apache旗下的Jena、Eclipse旗下的RDF4J以及源自学术界的RDF-3X和gStore；主要的商业RDF三元组数据库包括：Virtuoso、AllegroGraph、GraphDB和BlazeGraph。,RDF三元组数据库,,,RDF-3X,
主要的开源RDF三元组数据库包括：Apache旗下的Jena、Eclipse旗下的RDF4J以及源自学术界的RDF-3X和gStore；主要的商业RDF三元组数据库包括：Virtuoso、AllegroGraph、GraphDB和BlazeGraph。,RDF三元组数据库,,,gStore,
主要的开源RDF三元组数据库包括：Apache旗下的Jena、Eclipse旗下的RDF4J以及源自学术界的RDF-3X和gStore；主要的商业RDF三元组数据库包括：Virtuoso、AllegroGraph、GraphDB和BlazeGraph。,主要的商业RDF三元组数据库,,,Virtuoso,
主要的开源RDF三元组数据库包括：Apache旗下的Jena、Eclipse旗下的RDF4J以及源自学术界的RDF-3X和gStore；主要的商业RDF三元组数据库包括：Virtuoso、AllegroGraph、GraphDB和BlazeGraph。,主要的商业RDF三元组数据库,,,AllegroGraph,
主要的开源RDF三元组数据库包括：Apache旗下的Jena、Eclipse旗下的RDF4J以及源自学术界的RDF-3X和gStore；主要的商业RDF三元组数据库包括：Virtuoso、AllegroGraph、GraphDB和BlazeGraph。,主要的商业RDF三元组数据库,,,GraphDB,
主要的开源RDF三元组数据库包括：Apache旗下的Jena、Eclipse旗下的RDF4J以及源自学术界的RDF-3X和gStore；主要的商业RDF三元组数据库包括：Virtuoso、AllegroGraph、GraphDB和BlazeGraph。,主要的商业RDF三元组数据库,,,BlazeGraph,
主要的开源RDF三元组数据库包括：Apache旗下的Jena、Eclipse旗下的RDF4J以及源自学术界的RDF-3X和gStore；主要的商业RDF三元组数据库包括：Virtuoso、AllegroGraph、GraphDB和BlazeGraph。,Apache旗下的Jena,,,Jena,
主要的开源RDF三元组数据库包括：Apache旗下的Jena、Eclipse旗下的RDF4J以及源自学术界的RDF-3X和gStore；主要的商业RDF三元组数据库包括：Virtuoso、AllegroGraph、GraphDB和BlazeGraph。,Eclipse旗下的RDF4J,,,RDF4J,
主要的开源RDF三元组数据库包括：Apache旗下的Jena、Eclipse旗下的RDF4J以及源自学术界的RDF-3X和gStore；主要的商业RDF三元组数据库包括：Virtuoso、AllegroGraph、GraphDB和BlazeGraph。,源自学术界的RDF-3X,,,RDF-3X,
主要的开源RDF三元组数据库包括：Apache旗下的Jena、Eclipse旗下的RDF4J以及源自学术界的RDF-3X和gStore；主要的商业RDF三元组数据库包括：Virtuoso、AllegroGraph、GraphDB和BlazeGraph。,源自学术界的gStore,,,gStore,
主要的开源RDF三元组数据库包括：Apache旗下的Jena、Eclipse旗下的RDF4J以及源自学术界的RDF-3X和gStore；主要的商业RDF三元组数据库包括：Virtuoso、AllegroGraph、GraphDB和BlazeGraph。,Virtuoso,,,Virtuoso,
主要的开源RDF三元组数据库包括：Apache旗下的Jena、Eclipse旗下的RDF4J以及源自学术界的RDF-3X和gStore；主要的商业RDF三元组数据库包括：Virtuoso、AllegroGraph、GraphDB和BlazeGraph。,AllegroGraph,,,AllegroGraph,
主要的开源RDF三元组数据库包括：Apache旗下的Jena、Eclipse旗下的RDF4J以及源自学术界的RDF-3X和gStore；主要的商业RDF三元组数据库包括：Virtuoso、AllegroGraph、GraphDB和BlazeGraph。,GraphDB,,,GraphDB,
主要的开源RDF三元组数据库包括：Apache旗下的Jena、Eclipse旗下的RDF4J以及源自学术界的RDF-3X和gStore；主要的商业RDF三元组数据库包括：Virtuoso、AllegroGraph、GraphDB和BlazeGraph。,BlazeGraph,,,BlazeGraph,
ApacheJena将以实践形式进行详细介绍；下面分别介绍RDF4J、RDF-3X、gStore、Virtuoso、AllegroGraph、GraphDB和BlazeGraph。,ApacheJena,,,Apache Jena,
1.开源RDF三元组数据库RDF4JRDF4J目前是Eclipse基金会旗下的开源孵化项目，其前身是荷兰软件公司Aduna开发的Sesame框架。,RDF4J,,,Eclipse基金会旗下的开源孵化项目,
1.开源RDF三元组数据库RDF4JRDF4J目前是Eclipse基金会旗下的开源孵化项目，其前身是荷兰软件公司Aduna开发的Sesame框架。,RDF4J,,,Eclipse基金会旗下的开源孵化项目，其前身是荷兰软件公司Aduna开发的Sesame框架,
RDF4J框架的重要特点是其模块化的软件架构设计。,RDF4J框架,,,模块化的软件架构设计,
图3-16RDF4J的高层架构图（1）底层的RDF模型定义了URI、空节点（Blank_Node）、字面值（Literal）和语句（Statement）等RDF基本元素。,RDF模型,,,底层的RDF元素,
图3-16RDF4J的高层架构图（1）底层的RDF模型定义了URI、空节点（Blank_Node）、字面值（Literal）和语句（Statement）等RDF基本元素。,RDF模型,,,RDF基本元素,
（2）Rio代表“RDF_I/O”，即RDF输入/输出，包括各种RDF文件格式的解析器（Parser）和编写器（Writer），解析器负责将RDF文件解析为RDF模型中的三元组语句，编写器负责将三元组语句写为RDF文件。,Rio,,,RDF_I/O,
（2）Rio代表“RDF_I/O”，即RDF输入/输出，包括各种RDF文件格式的解析器（Parser）和编写器（Writer），解析器负责将RDF文件解析为RDF模型中的三元组语句，编写器负责将三元组语句写为RDF文件。,Rio,,,RDF_I/O,
（4）存储库API（Repository_API）是用户使用的RDF管理和处理高层API，提供RDF的存储、查询和推理等服务，面向终端用户，简单易用；存储库API的一种实现是基于本地SAIL实现的SailRepository，另一种是基于远程HTTP服务器实现的HttpRepository。,存储库API,,,RDF管理和处理高层API,
（4）存储库API（Repository_API）是用户使用的RDF管理和处理高层API，提供RDF的存储、查询和推理等服务，面向终端用户，简单易用；存储库API的一种实现是基于本地SAIL实现的SailRepository，另一种是基于远程HTTP服务器实现的HttpRepository。,存储库API,,,Repository_API,
（5）架构图的顶层是用户开发的应用程序和HTTP服务器，用户应用程序直接调用存储库API;HTTP服务器实现了通过HTTP访问存储库API的Web服务，可通过HttpClient库与HTTP服务器进行远程通信，从而访问远程RDF4J存储库。,用户应用程序,,,顶层,
（5）架构图的顶层是用户开发的应用程序和HTTP服务器，用户应用程序直接调用存储库API;HTTP服务器实现了通过HTTP访问存储库API的Web服务，可通过HttpClient库与HTTP服务器进行远程通信，从而访问远程RDF4J存储库。,架构图的顶层,,,用户开发的应用程序和HTTP服务器,
（5）架构图的顶层是用户开发的应用程序和HTTP服务器，用户应用程序直接调用存储库API;HTTP服务器实现了通过HTTP访问存储库API的Web服务，可通过HttpClient库与HTTP服务器进行远程通信，从而访问远程RDF4J存储库。,用户应用程序,,,直接调用存储库API,
（5）架构图的顶层是用户开发的应用程序和HTTP服务器，用户应用程序直接调用存储库API;HTTP服务器实现了通过HTTP访问存储库API的Web服务，可通过HttpClient库与HTTP服务器进行远程通信，从而访问远程RDF4J存储库。,HTTP服务器,,,通过HTTP访问存储库API的Web服务,
（5）架构图的顶层是用户开发的应用程序和HTTP服务器，用户应用程序直接调用存储库API;HTTP服务器实现了通过HTTP访问存储库API的Web服务，可通过HttpClient库与HTTP服务器进行远程通信，从而访问远程RDF4J存储库。,HTTP服务器,,,可通过HttpClient库与HTTP服务器进行远程通信,
（5）架构图的顶层是用户开发的应用程序和HTTP服务器，用户应用程序直接调用存储库API;HTTP服务器实现了通过HTTP访问存储库API的Web服务，可通过HttpClient库与HTTP服务器进行远程通信，从而访问远程RDF4J存储库。,HTTP服务器,,,访问远程RDF4J存储库,
正是由于RDF4J规范的模块化设计，使其成为很多其他RDF三元组数据库（如GraphDB）的上层标准框架，这些三元组库只需要实现各自的SAIL_API，依赖于RDF4J存储库API的应用程序而无须修改，便可以在不同的三元组库之间实现透明切换。,RDF4J,,,RDFS-ABSTRACT-SYNTAX,
目前，RDF-3X只支持Linux系统。,RDF-3X,,,Linux系统,
RDF-3X的最大特点在于其为RDF数据精心打造的压缩物理存储方案、查询处理和查询优化技术。,RDF-3X,,,为RDF数据精心打造的压缩物理存储方案、查询处理和查询优化技术,
在逻辑存储上，虽然以简单的三元组表为基础，但首次提出全索引方案：建立6种三元组索引spo、sop、osp、ops、pso和pos；建立6种二元聚合索引sp、ps、so、os、po和op；建立3种一元聚合索引s、p、o。,spo,,,全索引方案,
在物理存储上，采用基于B+树的压缩方案：使用字典快速查找表建立RDF字符串到整数id的映射；使用面向字节的增量编码B+树页面内部，不会跨越不同页压缩技术，实现三元组的压缩存放；三元组压缩限于面，避免了不必要的解压缩操作，能够提高查询效率。,压缩存放,,,面向字节的增量编码B+树页面内部,
在物理存储上，采用基于B+树的压缩方案：使用字典快速查找表建立RDF字符串到整数id的映射；使用面向字节的增量编码B+树页面内部，不会跨越不同页压缩技术，实现三元组的压缩存放；三元组压缩限于面，避免了不必要的解压缩操作，能够提高查询效率。,压缩存放,,,compression storage,
借助巧妙设计的三元组压缩技术，全索引方案的空间开销是可以接受的，全索引为查询处理和优化带来了巨大便利。,全索引,,,查询处理和优化带来便利,
对于利用全索引方案的查找，仅以spo索引为例进行举例。,全索引方案的查找,,,spo索引,
"如图3-18所示，利用spo索引查找三元组模式(Albert_Einstein,invented,?x),spo索引中存储的是已经进行字典编码之后的由整数id值组成的(s,p,o)三元组，并且已按照s、p、o值由小到大的顺序进行了排序。",spo索引,,,查找三元组模式,
图3-18使用spo索引进行三元组模式查找RDF-3X的查询处理器首先对SPARQL查询进行转化，生成若干查询执行计划；对于仅包含一个三元组模式的查询，可以通过一次相应索引查找操作完成；对于由多个三元组模式组成的查询，需要对多个连接的顺序进行优化。,查询处理器,,,查询执行计划生成,
图3-18使用spo索引进行三元组模式查找RDF-3X的查询处理器首先对SPARQL查询进行转化，生成若干查询执行计划；对于仅包含一个三元组模式的查询，可以通过一次相应索引查找操作完成；对于由多个三元组模式组成的查询，需要对多个连接的顺序进行优化。,查询处理器,,,query processor,
RDF-3X采用的是一种自底向上的动态规划优化算法，其优化过程充分考虑了SPARQL查询的特点，并且最大限度地保持了有利于用全索引方案进行归并连接的连接顺序。,RDF-3X,,,自底向上的动态规划优化算法,
RDF-3X采用的是一种自底向上的动态规划优化算法，其优化过程充分考虑了SPARQL查询的特点，并且最大限度地保持了有利于用全索引方案进行归并连接的连接顺序。,自底向上的动态规划优化算法,,,bottom-up dynamic programming optimization algorithm,
同时，RDF-3X还开发了基于代价模型的选择度评估（Selectivity_Estimates）机制，采用选择度直方图和频繁连接路径相结合的方法进行查询执行计划的选择度评估。,RDF-3X,,,基于代价模型的选择度评估（Selectivity_Estimates）机制,
同时，RDF-3X还开发了基于代价模型的选择度评估（Selectivity_Estimates）机制，采用选择度直方图和频繁连接路径相结合的方法进行查询执行计划的选择度评估。,基于代价模型的选择度评估,,,Selectivity_Estimates,
RDF-3X是命令行程序，使用RDF-3X装载RDF文件music_1000_triples.nt的命令如图3-19所示，其中的rdf3xload是命令名称，testds是数据库名称；进行SPARQL查询的命令如图3-20所示，rdf3query是命令名称，sparql.rq是SPARQL查询文件名称。,RDF-3X,,,命令行程序,
RDF-3X是命令行程序，使用RDF-3X装载RDF文件music_1000_triples.nt的命令如图3-19所示，其中的rdf3xload是命令名称，testds是数据库名称；进行SPARQL查询的命令如图3-20所示，rdf3query是命令名称，sparql.rq是SPARQL查询文件名称。,RDF-3X,,,RDF-3 Command-Line,
图3-19使用RDF-3X装载RDF文件图3-20使用RDF-3X进行SPARQL查询3.开源RDF三元组数据库gStoregStore是基于图的RDF三元组数据库。,gStore,,,基于图的RDF三元组数据库,
图3-19使用RDF-3X装载RDF文件图3-20使用RDF-3X进行SPARQL查询3.开源RDF三元组数据库gStoregStore是基于图的RDF三元组数据库。,gStore,,,基于图的RDF三元组数据库,
gStore将RDF图G中的每个实体节点及其邻居属性和属性值编码成一个二进制位串，由这些位串作为节点组成一张与RDF图G对应的标签图G*。,gStore,,,将RDF图G中的每个实体节点及其邻居属性和属性值编码成一个二进制位串，由这些位串作为节点组成一张与RDF图G对应的标签图G*,
在执行SPARQL查询时，将查询图Q也转化为一张查询的标签图Q*。,查询图Q,,,查询的标签图Q*,
gStore的研究工作已经证明了Q*在G*上的匹配是Q在G上匹配的超集。,Q*,,,gStore的研究工作已经证明了Q*在G*上的匹配是Q在G上匹配的超集,
目前，gStore已经作为开源项目发布，源代码和文档可以从其GitHub项目网站下载。,gStore,,,开源项目,
与RDF-3X一样，gStore只能在Linux系统上运行。,gStore,,,Linux系统上的应用,
关于gStore内部实现的详细信息可参见文献[33]。,gStore,,,内部实现的详细信息,
4.商业RDF三元组数据库VirtuosoVirtuoso虽然是可以支持多种数据模型的混合数据库管理系统，但其基础源自开发了多年的传统关系数据库管理系统，因此具备较为完善的事务管理、并发控制和完整性机制。,Virtuoso,,,商业RDF三元组数据库,
Virtuoso同时发布了商业版本VirtuosoUniversalServer（Virtuoso统一服务器）和开源版本OpenLinkVirtuoso。,Virtuoso,,,VirtuosoUniversalServer,
Virtuoso同时发布了商业版本VirtuosoUniversalServer（Virtuoso统一服务器）和开源版本OpenLinkVirtuoso。,Virtuoso,,,OpenLinkVirtuoso,
图3-21使用Virtuoso进行SPARQL查询5.商业RDF三元组数据库AllegroGraphAllegroGraph是Franz公司开发的RDF三元组数据库。,AllegroGraph,,,商业RDF三元组数据库,
图3-21使用Virtuoso进行SPARQL查询5.商业RDF三元组数据库AllegroGraphAllegroGraph是Franz公司开发的RDF三元组数据库。,AllegroGraph,,,Franz公司开发的RDF三元组数据库,
由于Franz公司有着深厚的人工智能背景，早期一直开发Common_Lisp和Prolog语言的实现工具，这使得AllegroGraph对语义推理功能具有较为完善的支持。,AllegroGraph,,,知识图谱,
AllegroGraph除了三元组数据库的基本功能外，还支持动态物化的RDFS++推理机、OWL2_RL推理机、Prolog规则推理系统、时空推理机制、社会网络分析库、可视化RDF图浏览器等。,AllegroGraph,,,三元组数据库,
同时，AllegroGraph支持Java、Python、C#、Ruby、Clojure/Scala、Lisp等多种语言的编程访问接口。,AllegroGraph,,,编程访问接口,
6.商业RDF三元组数据库GraphDBGraphDB是RDF三元组数据库，其前身OWLIM一直是支持W3C语义Web标准的主流产品。,GraphDB,,,RDF三元组数据库,
6.商业RDF三元组数据库GraphDBGraphDB是RDF三元组数据库，其前身OWLIM一直是支持W3C语义Web标准的主流产品。,GraphDB,,,RDF三元组数据库,
GraphDB目前有社区免费版、标准版和企业版，其中企业版支持多台机器的集群分布式部署。,GraphDB,,,社区免费版,
GraphDB目前有社区免费版、标准版和企业版，其中企业版支持多台机器的集群分布式部署。,GraphDB,,,标准版,
GraphDB目前有社区免费版、标准版和企业版，其中企业版支持多台机器的集群分布式部署。,GraphDB,,,企业版,
GraphDB的高层架构如图3-26所示。,GraphDB,,,高层架构,
图3-26GraphDB的高层架构对于GraphDB的各部分组件自顶向下进行介绍：（1）Workbench是GraphDB的Web管理工具；（2）Engine是查询处理和推理引擎，由查询优化器（Query_Optimiser）、推理机（Reasoner）、存储层（Storage）和插件管理器（Plugin_Manager）组成；●查询优化器能够在多种查询执行计划中挑选出较高效的一种，查询经过解析后会交由查询优化器进行优化；●推理机执行基于RDF规则的前向链推理，由显式三元组推导出全部导出三元组，导出三元组会随显式三元组的更新而同步更新；●存储层使用pos和pso两种三元组索引、psco和pocs两种带有上下文信息的四元组索引以及字面值（Literal）索引存储RDF数据；实体池（Entity_Pool）是GraphDB存储层的核心部件，起到将RDF实体（URI、空节点和字面值）映射到内部整数ID的字典编码器的作用，同时还实现了对事务管理的支持机制。,GraphDB,,,GraphDB,
（3）Connectors是GraphDB连接外部工具的桥梁，包括用于建立快速关键字查找功能的Lucene和用于建立搜索引擎的Solr和Elasticsearch。,Connectors,,,GraphDB连接外部工具的桥梁,
（4）插件管理器在Engine内起到插件管理作用，既包括GraphDB内部实现的插件，也包括各种外部工具连接器。,插件管理器,,,Engine内的插件管理作用,
7.商业RDF三元组数据库BlazegraphBlazegraph在1.5版本之前叫作Bigdata，但众所周知的“大数据”的兴起使得这个不温不火的RDF三元组库软件被淹没其中。,Blazegraph,,,商业RDF三元组数据库,
7.商业RDF三元组数据库BlazegraphBlazegraph在1.5版本之前叫作Bigdata，但众所周知的“大数据”的兴起使得这个不温不火的RDF三元组库软件被淹没其中。,Blazegraph,,,Bigdata,
但这个软件在“大数据”兴起前很多年就叫Bigdata，迫不得已改名叫Blazegraph之后，其开发理念也有所调整。,Blazegraph,,,Bigdata,
原来仅仅是支持RDF三元组存储和SPARQL，现在已经定位为全面支持Blueprints标准的图数据库。,图数据库,,,全面支持Blueprints标准的图数据库,
不过，其内部实现技术仍是面向RDF三元组和SPARQL的，因而可以理解为是“基于RDF三元组库的图数据库”。,图数据库,,,基于RDF三元组库的图数据库,
不过，其内部实现技术仍是面向RDF三元组和SPARQL的，因而可以理解为是“基于RDF三元组库的图数据库”。,图数据库,,,基于RDF三元组库的图数据库,
从2006年发布至今，Blazegraph一直由SYSTAP公司开发，虽然它既不是最知名的RDF三元组库，也不是最流行的图数据库，但开发进展稳扎稳打，积累了相对全面的功能。,Blazegraph,,,SYSTAP公司开发,
从2006年发布至今，Blazegraph一直由SYSTAP公司开发，虽然它既不是最知名的RDF三元组库，也不是最流行的图数据库，但开发进展稳扎稳打，积累了相对全面的功能。,Blazegraph,,,Blazegraph,
Blazegraph可以通过其官方网站下载。,Blazegraph,,,官方网站下载,
既可以将Blazegraph作为War包部署为Web程序，也可以将其配置为单机或分布式数据库服务器。,Blazegraph,,,War包部署为Web程序,
既可以将Blazegraph作为War包部署为Web程序，也可以将其配置为单机或分布式数据库服务器。,Blazegraph,,,单机或分布式数据库服务器,
图3-27Blazegraph的Web用户界面8.商业RDF三元组数据库StardogStardog是由美国Stardog_Union公司开发的RDF三元组数据库，其首个公开发布版本是2012年2月发布的Stardog_0.9。,Stardog,,,RDF三元组数据库,
图3-27Blazegraph的Web用户界面8.商业RDF三元组数据库StardogStardog是由美国Stardog_Union公司开发的RDF三元组数据库，其首个公开发布版本是2012年2月发布的Stardog_0.9。,Stardog,,,星图,
Stardog分为企业版和社区版，社区版可以免费用于非商业用途。,Stardog,,,企业版,
Stardog分为企业版和社区版，社区版可以免费用于非商业用途。,Stardog,,,社区版,
3.2.3原生图数据库1.最流行的图数据库Neo4jNeo4j的1.0版本发布于2010年。,Neo4j,,,最流行的图数据库,
3.2.3原生图数据库1.最流行的图数据库Neo4jNeo4j的1.0版本发布于2010年。,Neo4j,,,Neo4j,
Neo4j基于属性图模型，其存储管理层为属性图结构中的节点、节点属性、边、边属性等设计了专门的存储方案。,Neo4j,,,属性图模型,
Neo4j基于属性图模型，其存储管理层为属性图结构中的节点、节点属性、边、边属性等设计了专门的存储方案。,Neo4j,,,属性图模型,
这使得Neo4j在存储层对于图数据的存取效率天生就优于关系数据库。,Neo4j,,,关系数据库,
同时，Neo4j还具备OLTP数据库必需的ACID事务处理功能。,Neo4j,,,OLTP数据库,
如果图数据超过一定规模，系统性能就会因为磁盘、内存等限制而大幅降低。,图数据规模,,,系统性能降低,
Neo4j浏览器是功能完善的Neo4j可视化交互式客户端工具，可以用于执行Cypher语言。,Neo4j浏览器,,,功能完善的Neo4j可视化交互式客户端工具,
使用Neo4j内置的Movie图数据库执行Cypher查询，返回“TomHanks”所出演的全部电影，如图3-31所示。,Neo4j内置的Movie图数据库,,,Cypher查询,
使用Neo4j内置的Movie图数据库执行Cypher查询，返回“TomHanks”所出演的全部电影，如图3-31所示。,Neo4j,,,Movie图数据库,
此外，成功启动Neo4j服务器之后，会在7474和7473端口分别开启HTTP和HTTPS服务。,Neo4j,,,HTTP服务,
此外，成功启动Neo4j服务器之后，会在7474和7473端口分别开启HTTP和HTTPS服务。,Neo4j,,,HTTPS服务,
此外，成功启动Neo4j服务器之后，会在7474和7473端口分别开启HTTP和HTTPS服务。,7474,,,HTTP,
此外，成功启动Neo4j服务器之后，会在7474和7473端口分别开启HTTP和HTTPS服务。,7473,,,HTTPS,
例如，使用浏览器访问http://localhost:7474/进入Web界面，执行Cypher查询，其功能与Neo4j浏览器是一致的。,Neo4j浏览器,,,功能,
例如，使用浏览器访问http://localhost:7474/进入Web界面，执行Cypher查询，其功能与Neo4j浏览器是一致的。,Neo4j浏览器,,,Neo4j browser,
图3-31Neo4j浏览器界面2.分布式图数据库JanusGraphJanusGraph借助第三方分布式索引库Elasticsearch、Solr和Lucene实现各种类型数据的快速检索功能，包括地理信息数据、数值数据和全文搜索。,Neo4j,,,分布式图数据库,
JanusGraph的前身Titan是由Aurelius公司开发的，而该公司的创始人Rodriguez博士恰恰就是Blueprints标准及Gremlin语言的主要开发者，Titan对于Blueprints标准和Gremlin语言的全面支持便不难理解，JanusGraph基本上继承了Titan的这一特性。,JanusGraph,,,Titan,
同时，JanusGraph也是OLTP图数据库，其支持多用户并发访问和实时图遍历查询。,JanusGraph,,,OLTP图数据库,
另一方面，JanusGraph还具备基于Hadoop_MapReduce的图分析引擎，其可以将Gremlin导航查询自动转化为MapReduce任务。,JanusGraph,,,基于Hadoop_MapReduce的图分析引擎,
另一方面，JanusGraph还具备基于Hadoop_MapReduce的图分析引擎，其可以将Gremlin导航查询自动转化为MapReduce任务。,JanusGraph,,,基于Hadoop_MapReduce的图分析引擎,
从这个角度看，JanusGraph也可作为图计算引擎使用。,JanusGraph,,,图计算引擎,
从这个角度看，JanusGraph也可作为图计算引擎使用。,图计算引擎,,,JanusGraph,
3.图数据库OrientDBOrientDB对于数据模式的支持也相对灵活，可以管理无模式数据（Schema-less），也可以像关系数据库那样定义完整的模式（Schema-full），还可以适应介于两者之间的混合模式（Schema-mixed）数据。,OrientDB,,,对于数据模式的支持也相对灵活,
3.图数据库OrientDBOrientDB对于数据模式的支持也相对灵活，可以管理无模式数据（Schema-less），也可以像关系数据库那样定义完整的模式（Schema-full），还可以适应介于两者之间的混合模式（Schema-mixed）数据。,OrientDB,,,Schema-less,
3.图数据库OrientDBOrientDB对于数据模式的支持也相对灵活，可以管理无模式数据（Schema-less），也可以像关系数据库那样定义完整的模式（Schema-full），还可以适应介于两者之间的混合模式（Schema-mixed）数据。,OrientDB,,,Schema-full,
3.图数据库OrientDBOrientDB对于数据模式的支持也相对灵活，可以管理无模式数据（Schema-less），也可以像关系数据库那样定义完整的模式（Schema-full），还可以适应介于两者之间的混合模式（Schema-mixed）数据。,OrientDB,,,Schema-mixed,
在查询语言方面，OrientDB支持扩展的SQL和Gremlin用于图上的导航式查询；值得注意的是，在2.2版本引入的MATCH语句实现了声明式的模式匹配，这类似于Cypher语言查询模式。,OrientDB,,,查询语言,
在查询语言方面，OrientDB支持扩展的SQL和Gremlin用于图上的导航式查询；值得注意的是，在2.2版本引入的MATCH语句实现了声明式的模式匹配，这类似于Cypher语言查询模式。,OrientDB,,,OrientDB,
需要指出的是，Cayley虽然可以存储N-Quads格式的RDF文件，但目前尚不支持SPARQL查询。,Cayley,,,存储N-Quads格式的RDF文件,
需要指出的是，Cayley虽然可以存储N-Quads格式的RDF文件，但目前尚不支持SPARQL查询。,Cayley,,,Cayley,
总体来讲，基于关系的存储系统继承了关系数据库的优势，成熟度较高，在硬件性能和存储容量满足的前提下，通常能够适应千万到十亿级三元组规模的管理。,基于关系的存储系统,,,关系数据库的优势,
对于一般在百万到上亿级三元组的管理，使用稍高配置的单机系统和主流RDF三元组数据库（如Jena、RDF4J、Virtuoso等）完全可以胜任。,RDF三元组数据库,,,稍高配置的单机系统,
对于一般在百万到上亿级三元组的管理，使用稍高配置的单机系统和主流RDF三元组数据库（如Jena、RDF4J、Virtuoso等）完全可以胜任。,单机系统,,,single-machine-system,
对于一般在百万到上亿级三元组的管理，使用稍高配置的单机系统和主流RDF三元组数据库（如Jena、RDF4J、Virtuoso等）完全可以胜任。,RDF三元组数据库,,,主流RDF三元组数据库,
如果需要管理几亿到十几亿以上大规模的RDF三元组，则可尝试部署具备分布式存储与查询能力的数据库系统（如商业版的GraphDB和BlazeGraph、开源的JanusGraph等）。,GraphDB,,,具备分布式存储与查询能力的数据库系统,
近年来，以Neo4j为代表的图数据库系统发展迅猛，使用图数据库管理RDF三元组也是一种很好的选择；但目前大部分图数据库还不能直接支持RDF三元组存储，对于这种情况，可采用数据转换方式，先将RDF预处理为图数据库支持的数据格式（如属性图模型），再进行后续管理操作。,图数据库管理系统,,,RDF三元组管理,
近年来，以Neo4j为代表的图数据库系统发展迅猛，使用图数据库管理RDF三元组也是一种很好的选择；但目前大部分图数据库还不能直接支持RDF三元组存储，对于这种情况，可采用数据转换方式，先将RDF预处理为图数据库支持的数据格式（如属性图模型），再进行后续管理操作。,图数据库系统,,,graph database system,
近年来，以Neo4j为代表的图数据库系统发展迅猛，使用图数据库管理RDF三元组也是一种很好的选择；但目前大部分图数据库还不能直接支持RDF三元组存储，对于这种情况，可采用数据转换方式，先将RDF预处理为图数据库支持的数据格式（如属性图模型），再进行后续管理操作。,RDF三元组,,,RDF triples,
近年来，以Neo4j为代表的图数据库系统发展迅猛，使用图数据库管理RDF三元组也是一种很好的选择；但目前大部分图数据库还不能直接支持RDF三元组存储，对于这种情况，可采用数据转换方式，先将RDF预处理为图数据库支持的数据格式（如属性图模型），再进行后续管理操作。,图数据库,,,graph database,
本节首先以图数据库Neo4j为例介绍其内部存储方案，然后简要描述知识图谱数据库的两类索引技术。,Neo4j,,,内部存储方案,
本节首先以图数据库Neo4j为例介绍其内部存储方案，然后简要描述知识图谱数据库的两类索引技术。,Neo4j,,,图数据库,
3.3.1知识图谱数据库的存储：以Neo4j为例这一节将深入Neo4j图数据库底层，探究其原生的图存储方案。,知识图谱数据库的存储,,,Neo4j,
对于遵循属性图的图数据库，存储管理层的任务是将属性图编码表示为在磁盘上存储的数据格式。,存储管理层,,,将属性图编码表示为在磁盘上存储的数据格式,
虽然不同图数据库的具体存储方案各有差异，但一般认为具有“无索引邻接”特性（Index-FreeAdjacency）的图数据库才称为原生图数据库[35]。,原生图数据库,,,Index-FreeAdjacency,
在实现了“无索引邻接”的图数据库中，每个节点维护着指向其邻接节点的直接引用，这相当于每个节点都可看作是其邻接节点的一个“局部索引”，用其查找邻接节点比使用“全局索引”更能节省时间。,无索引邻接的图数据库,,,每个节点维护着指向其邻接节点的直接引用,
在实现了“无索引邻接”的图数据库中，每个节点维护着指向其邻接节点的直接引用，这相当于每个节点都可看作是其邻接节点的一个“局部索引”，用其查找邻接节点比使用“全局索引”更能节省时间。,局部索引,,,指向其邻接节点的直接引用,
这就意味着图导航操作代价与图大小无关，仅与图的遍历范围成正比。,图导航操作,,,图大小无关,
这就意味着图导航操作代价与图大小无关，仅与图的遍历范围成正比。,图导航操作代价,,,graph navigation cost,
作为对比，来看看在非原生图数据库中使用全局索引关联邻接节点的情形。,非原生图数据库,,,全局索引关联邻接节点,
如果觉得这样的查找代价还是可以接受的话，那么换一个问题，“谁认识张三”的查找代价是多少？显然，对于这个查询，需要通过全局索引检查每个节点，看其认识的人中有没有张三，总代价为O(nlogn)，这样的复杂度对于大图数据的遍历操作是不可接受的。,查找代价,,,通过全局索引检查每个节点，看其认识的人中有没有张三,
有人说，可为“被认识”关系再建一个同样的全局索引，但那样索引的维护开销就会翻倍，而且仍然不能做到图遍历操作代价与图规模无关。,“被认识”关系,,,equivalent,
只有将图数据的边表示的关系当作数据库的“一等公民”（即数据库中最基本、最核心的概念，如关系数据库中的“关系”），才能实现真正的“无索引邻接”特性。,图数据的边表示的关系,,,“一等公民”,
只有将图数据的边表示的关系当作数据库的“一等公民”（即数据库中最基本、最核心的概念，如关系数据库中的“关系”），才能实现真正的“无索引邻接”特性。,无索引邻接,,,“无索引邻接”特性,
图3-36邻接关系的全局索引示例图3-37将关系作为“一等公民”在Neo4j数据库中，属性图的不同部分是被分开存储在不同文件中的。,图3-36,,,邻接关系的全局索引,
图3-36邻接关系的全局索引示例图3-37将关系作为“一等公民”在Neo4j数据库中，属性图的不同部分是被分开存储在不同文件中的。,属性图,,,property graph,
正是这种将图结构与图上属性分开存储的策略，使得Neo4j具有高效率的图遍历操作。,Neo4j,,,将图结构与图上属性分开存储的策略,
首先，来看在Neo4j中是如何存储图节点和边的。,Neo4j,,,图数据库,
节点记录存储在文件neostore.nodestore.db中。,节点记录,,,文件neostore.nodestore.db,
节点记录的第0字节inUse是记录使用标志字节的，告诉数据库该记录是否在使用中，还是已经删除并可回收用来装载新的记录；第1～4字节nextRelId是与节点相连的第1条边的id；第5～8字节nextPropId是节点的第1个属性的id。,节点记录的第0字节inUse,,,记录使用标志字节,
节点记录的第0字节inUse是记录使用标志字节的，告诉数据库该记录是否在使用中，还是已经删除并可回收用来装载新的记录；第1～4字节nextRelId是与节点相连的第1条边的id；第5～8字节nextPropId是节点的第1个属性的id。,inUse,,,记录使用标志字节,
边记录存储在文件neostore.relationshipstore.db中。,neostore.relationshipstore.db,,,边记录存储,
边记录第0字节inUse含义与节点记录相同，表示是否正被数据库使用的标志；第1～4字节secondNode分别是该边的起始节点id和终止节点id；第9～12字节relType是指向该边的关系类型的指针；第13～16字节firstPrevRelId和第17～20字节firstNextRelId分别为指向起始节点上前一个和后一个边记录的指针；第21～24字节secPrevRelId和第25～28字节secNextRelId分别为指向终止节点上前一个和后一个边记录的指针；指向前后边记录的4个指针形成了两个“关系双向链”；第29～32字节nextPropId是边上的第1个属性的id。,inUse,,,是否正被数据库使用的标志,
和第5～8字节firstNode图3-38Neo4j中节点和边记录的物理存储结构Neo4j实现节点和边快速定位的关键是“定长记录”的存储方案，将具有定长记录的图结构与具有变长记录的属性数据分开存储。,定长记录,,,fixed-length record,
例如，一个节点记录长度是9字节，如果要查找id为99的节点记录所在位置（id从0开始），则可直接到节点存储文件第891个字节处访问（存储文件从第0个字节开始）。,节点记录长度,,,一个节点记录长度是9字节,
例如，一个节点记录长度是9字节，如果要查找id为99的节点记录所在位置（id从0开始），则可直接到节点存储文件第891个字节处访问（存储文件从第0个字节开始）。,节点记录长度,,,9字节,
例如，一个节点记录长度是9字节，如果要查找id为99的节点记录所在位置（id从0开始），则可直接到节点存储文件第891个字节处访问（存储文件从第0个字节开始）。,查找id为99的节点记录所在位置,,,节点存储文件第891个字节处访问（存储文件从第0个字节开始）,
边记录也是“定长记录”，长度为33字节。,边记录,,,定长记录,
这样，数据库已知记录id可以O(1)的代价直接计算其存储地址，而避免了全局索引中O(nlogn)的查找代价。,数据库已知记录id,,,O(1)的代价直接计算其存储地址,
这样，数据库已知记录id可以O(1)的代价直接计算其存储地址，而避免了全局索引中O(nlogn)的查找代价。,数据库已知记录id,,,O(1)的代价直接计算其存储地址,
这样，数据库已知记录id可以O(1)的代价直接计算其存储地址，而避免了全局索引中O(nlogn)的查找代价。,全局索引,,,O(nlogn)的查找代价,
图3-39展示了Neo4j中各种存储文件之间是如何交互的。,存储文件,,,交互,
存储在节点文件中的节点1和节点4均有指针指向存储在属性文件中各自的第1个属性记录；也有指针指向存储在边文件中各自的第1条边，分别为边7和边8。,节点文件,,,节点1和节点4,
存储在节点文件中的节点1和节点4均有指针指向存储在属性文件中各自的第1个属性记录；也有指针指向存储在边文件中各自的第1条边，分别为边7和边8。,节点文件中的节点1,,,指针指向存储在属性文件中各自的第1个属性记录,
存储在节点文件中的节点1和节点4均有指针指向存储在属性文件中各自的第1个属性记录；也有指针指向存储在边文件中各自的第1条边，分别为边7和边8。,节点文件中的节点4,,,指针指向存储在属性文件中各自的第1个属性记录,
存储在节点文件中的节点1和节点4均有指针指向存储在属性文件中各自的第1个属性记录；也有指针指向存储在边文件中各自的第1条边，分别为边7和边8。,节点文件中的节点1,,,指针指向存储在边文件中各自的第1条边,
存储在节点文件中的节点1和节点4均有指针指向存储在属性文件中各自的第1个属性记录；也有指针指向存储在边文件中各自的第1条边，分别为边7和边8。,节点文件中的节点4,,,指针指向存储在边文件中各自的第1条边,
存储在节点文件中的节点1和节点4均有指针指向存储在属性文件中各自的第1个属性记录；也有指针指向存储在边文件中各自的第1条边，分别为边7和边8。,节点1,,,节点文件中的节点1,
需要注意的是，每个边记录实际上维护着两个双向链表，一个是起始节点上的边，一个是终止节点上的边，可以将边记录想象为被起始节点和终止节点共同拥有，双向链表的优势在于不仅可在查找节点上的边时进行双向扫描，而且支持在两个节点间高效率地添加和删除边。,边记录,,,edge record,
这些操作除了记录字段的读取，就是定长记录地址的计算，均是O(1)时间的高效率操作。,操作,,,记录字段的读取,
这些操作除了记录字段的读取，就是定长记录地址的计算，均是O(1)时间的高效率操作。,操作,,,定长记录地址的计算,
这些操作除了记录字段的读取，就是定长记录地址的计算，均是O(1)时间的高效率操作。,操作,,,记录字段的读取,
这些操作除了记录字段的读取，就是定长记录地址的计算，均是O(1)时间的高效率操作。,操作,,,定长记录地址的计算,
可见，正是由于将边作为“一等公民”，将图结构实现为定长记录的存储方案，赋予了Neo4j作为原生图数据库的“无索引邻接”特性。,Neo4j,,,无索引邻接,
3.3.2知识图谱数据库的索引图数据上的索引一种是对节点或边上属性数据的索引，一种是对图结构的索引；前者可应用关系数据库中已有的B+树索引技术直接实现，而后者仍是业界没有达成共识的、开放的研究问题。,索引图数据上的索引,,,对节点或边上属性数据的索引,
3.3.2知识图谱数据库的索引图数据上的索引一种是对节点或边上属性数据的索引，一种是对图结构的索引；前者可应用关系数据库中已有的B+树索引技术直接实现，而后者仍是业界没有达成共识的、开放的研究问题。,索引图数据上的索引,,,对图结构的索引,
3.3.2知识图谱数据库的索引图数据上的索引一种是对节点或边上属性数据的索引，一种是对图结构的索引；前者可应用关系数据库中已有的B+树索引技术直接实现，而后者仍是业界没有达成共识的、开放的研究问题。,索引图数据上的索引,,,对节点或边上属性数据的索引,
3.3.2知识图谱数据库的索引图数据上的索引一种是对节点或边上属性数据的索引，一种是对图结构的索引；前者可应用关系数据库中已有的B+树索引技术直接实现，而后者仍是业界没有达成共识的、开放的研究问题。,索引图数据上的索引,,,对图结构的索引,
1.属性数据索引Neo4j数据库在前述存储方案的基础上还支持用户对属性数据建立索引，目的是加速针对某属性的查询处理性能。,属性数据索引,,,Neo4j数据库,
1.属性数据索引Neo4j数据库在前述存储方案的基础上还支持用户对属性数据建立索引，目的是加速针对某属性的查询处理性能。,属性数据索引,,,Neo4j数据库属性数据建立索引,
Neo4j索引的定义通过Cypher语句完成，目前支持对于同一个类型节点的某个属性构建索引。,Neo4j索引,,,Cypher语句完成,
Neo4j索引的定义通过Cypher语句完成，目前支持对于同一个类型节点的某个属性构建索引。,Neo4j索引,,,构建索引,
例如，对所有程序员节点的姓名属性构建索引。,对程序员节点姓名属性构建索引,,,对所有程序员节点的姓名属性构建索引,
在一般情况下，在查询中没有必要指定需要使用的索引，查询优化器会自动选择要用到的索引。,查询,,,查询优化器自动选择要用到的索引,
在一般情况下，在查询中没有必要指定需要使用的索引，查询优化器会自动选择要用到的索引。,查询优化器,,,自动选择要用到的索引,
例如，下面的查询查找姓名为张三的程序员，显然会用到刚刚建立的索引。,索引,,,查找姓名为张三的程序员,
应用该索引无疑会根据姓名属性的值快速定位到姓名是“张三”的节点，而无须扫描程序员节点的全部属性。,应用该索引,,,根据姓名属性的值快速定位到姓名是“张三”的节点,
删除索引的语句为：不难发现，为图节点或边的属性建立索引与为关系表的某一列建立索引在本质上并无不同之处，完全可以通过B+树或散列表实现。,为图节点或边的属性建立索引,,,为关系表的某一列建立索引,
删除索引的语句为：不难发现，为图节点或边的属性建立索引与为关系表的某一列建立索引在本质上并无不同之处，完全可以通过B+树或散列表实现。,为图节点或边的属性建立索引,,,为关系表的某一列建立索引,
这种索引并不涉及图数据上的任何图结构信息。,倒排索引,,,非图结构信息,
2.图结构索引图结构索引是为图数据中的点边结构信息建立索引的方法。,图结构索引,,,为图数据中的点边结构信息建立索引的方法,
2.图结构索引图结构索引是为图数据中的点边结构信息建立索引的方法。,图结构索引,,,graph structure index,
利用图结构索引可以对图查询中的结构信息进行快速匹配，从而大幅削减查询搜索空间。,图查询,,,利用图结构索引可以对图查询中的结构信息进行快速匹配，从而大幅削减查询搜索空间。,
大体上，图结构索引分为“基于路径的”和“基于子图的”两种。,图结构索引,,,基于路径的,
（1）基于路径的图索引。,基于路径的图索引,,,基于索引,
一种典型的基于路径的图索引叫作GraphGrep[36]。,GraphGrep,,,基于路径的图索引,
一种典型的基于路径的图索引叫作GraphGrep[36]。,GraphGrep,,,基于路径的图索引,
这种索引将图中长度小于或等于一个固定长度的全部路径构建为索引结构。,倒排索引,,,构建为索引结构,
索引的关键字可以是组成路径的节点或边上属性值或标签的序列。,索引的关键字,,,组成路径的节点或边上属性值或标签的序列,
图3-40是在图3-3的属性图上构建的GraphGrep索引。,GraphGrep,,,在图3-3的属性图上构建的索引,
这里构建的是长度小于或等于2的路径索引，关键字为路径上的边标签序列，值为路径经过的节点id序列。,路径索引,,,长度小于或等于2的路径索引,
这里构建的是长度小于或等于2的路径索引，关键字为路径上的边标签序列，值为路径经过的节点id序列。,路径索引,,,path index,
"例如，索引将关键字“认识.参加”映射到节点id序列(1,4,3)和(1,4,5)。",索引,,,关键字“认识.参加”映射,
"例如，索引将关键字“认识.参加”映射到节点id序列(1,4,3)和(1,4,5)。",索引,,,inxe,
利用该路径索引，类似前面出现过的“查询年龄为29的参加了项目3的程序员参加的其他项目及其直接或间接认识的程序员参加的项目”的查询处理效率会大幅提高，因为由节点1出发，根据关键字“认识.参加”，可以快速找到满足条件的节点3和节点5。,路径索引,,,查询处理效率提高,
利用该路径索引，类似前面出现过的“查询年龄为29的参加了项目3的程序员参加的其他项目及其直接或间接认识的程序员参加的项目”的查询处理效率会大幅提高，因为由节点1出发，根据关键字“认识.参加”，可以快速找到满足条件的节点3和节点5。,路径索引,,,path index,
（2）基于子图的索引。,基于子图的索引,,,基于概念的索引,
基于子图的索引可以看作是基于路径索引的一般化形式，是将图数据中的某些子图结构信息作为关键字，将该子图的实例数据作为值而构建的索引结构。,基于子图的索引,,,基于路径索引的一般化形式,
基于子图的索引可以看作是基于路径索引的一般化形式，是将图数据中的某些子图结构信息作为关键字，将该子图的实例数据作为值而构建的索引结构。,基于子图的索引,,,基于路径索引的一般化形式,
图3-41是在图3-3的属性图上构建的一种子图索引。,图3-41,,,在图3-3的属性图上构建的一种子图索引,
"满足第1个关键字子图的节点序列为(1,2,4)，满足第2个关键字子图的节点序列为(1,4,3)。",关键字子图,,,第1个关键字子图节点序列,
如果查询中包含某些作为关键字的子图结构，则可以利用该子图索引，快速找到与这些子图结构匹配的节点序列，这样可大幅度减小查询操作的搜索空间。,索引,,,快速找到与这些子图结构匹配的节点序列，这样可大幅度减小查询操作的搜索空间,
如果查询中包含某些作为关键字的子图结构，则可以利用该子图索引，快速找到与这些子图结构匹配的节点序列，这样可大幅度减小查询操作的搜索空间。,子图索引,,,subgraph index,
如果查询中包含某些作为关键字的子图结构，则可以利用该子图索引，快速找到与这些子图结构匹配的节点序列，这样可大幅度减小查询操作的搜索空间。,快速找到与这些子图结构匹配的节点序列,,,find the node sequence matching these subgraph structures,
图3-40基于路径的图索引示例图3-41基于子图的图索引示例不过，一个图数据的子图有指数个，将哪些子图作为关键字建立索引尚未得到很好的解决。,基于路径的图索引,,,基于图索引,
图3-40基于路径的图索引示例图3-41基于子图的图索引示例不过，一个图数据的子图有指数个，将哪些子图作为关键字建立索引尚未得到很好的解决。,基于路径的图索引,,,based on path,
一种叫作gIndex[37]的索引方法，首先利用数据挖掘方法，在图数据中发现出现次数超过一定阈值的频繁子图，再将去掉冗余之后的频繁子图作为关键字建立子图索引。,gIndex,,,索引方法,
一种叫作gIndex[37]的索引方法，首先利用数据挖掘方法，在图数据中发现出现次数超过一定阈值的频繁子图，再将去掉冗余之后的频繁子图作为关键字建立子图索引。,gIndex,,,g索引,
但gIndex建立索引的过程是相当耗时的，而且用户查询中还有可能没有包含任何一个频繁子图，这样就无法利用该子图索引。,gIndex,,,建立索引的过程是相当耗时的,
但gIndex建立索引的过程是相当耗时的，而且用户查询中还有可能没有包含任何一个频繁子图，这样就无法利用该子图索引。,gIndex,,,等价索引,
一种更合理的方法是从用户的查询日志中挖掘频繁使用的子图模式，并以此作为关键字建立索引。,频繁使用的子图模式,,,从用户的查询日志中挖掘,
一种更合理的方法是从用户的查询日志中挖掘频繁使用的子图模式，并以此作为关键字建立索引。,频繁使用的子图模式,,,从用户的查询日志中挖掘频繁使用的子图模式,
一种更合理的方法是从用户的查询日志中挖掘频繁使用的子图模式，并以此作为关键字建立索引。,关键字建立索引,,,以此作为关键字建立索引,
3.4开源工具实践3.4.1三元组数据库Apache_Jena1.开源工具简介Apache_Jena是Apache顶级项目，其前身为惠普实验室开发的Jena工具包。,Apache_Jena,,,三元组数据库,
3.4开源工具实践3.4.1三元组数据库Apache_Jena1.开源工具简介Apache_Jena是Apache顶级项目，其前身为惠普实验室开发的Jena工具包。,Apache_Jena,,,Jena工具包,
Jena是语义Web领域主要的开源框架和RDF三元组库，较好地遵循W3C标准，其功能包括：RDF数据管理、RDFS和OWL本体管理、SPARQL查询处理等。,Jena,,,语义Web领域主要的开源框架和RDF三元组库,
Jena具备一套原生存储引擎，可对RDF三元组进行基于磁盘或内存的存储管理；同时具有一套基于规则的推理引擎，用于执行RDFS和OWL本体推理任务。,Jena,,,一套原生存储引擎,
Jena具备一套原生存储引擎，可对RDF三元组进行基于磁盘或内存的存储管理；同时具有一套基于规则的推理引擎，用于执行RDFS和OWL本体推理任务。,Jena,,,一套基于规则的推理引擎,
Jena具备一套原生存储引擎，可对RDF三元组进行基于磁盘或内存的存储管理；同时具有一套基于规则的推理引擎，用于执行RDFS和OWL本体推理任务。,原生存储引擎,,,original storage engine,
Jena具备一套原生存储引擎，可对RDF三元组进行基于磁盘或内存的存储管理；同时具有一套基于规则的推理引擎，用于执行RDFS和OWL本体推理任务。,推理引擎,,,rule-based reasoning engine,
本实践相关工具、实验数据及操作说明由OpenKG提供，地址为http://openkg.cn。,本实践相关工具,,,OpenKG,
2.开源工具的技术架构ApacheJena框架如图3-42所示。,ApacheJena,,,开源工具的技术架构,
推理API为上层提供本体推理服务，可以使用Jena内置基于规则的推理机进行RDFS和OWL本体上的推理任务，或者选择通过接口调用第三方外部推理机。,推理API,,,上层提供本体推理服务,
推理API为上层提供本体推理服务，可以使用Jena内置基于规则的推理机进行RDFS和OWL本体上的推理任务，或者选择通过接口调用第三方外部推理机。,推理API,,,reasoning API,
Jena对外界应用程序的API包括实现基本三元组管理功能的RDFAPI、实现RDFS和OWL本体推理功能的本体API和实现查询处理功能的SPARQL_API。,Jena,,,对外界应用程序的API,
Jena对外界应用程序的API包括实现基本三元组管理功能的RDFAPI、实现RDFS和OWL本体推理功能的本体API和实现查询处理功能的SPARQL_API。,Jena,,,等价,
Java应用程序代码可以通过导入类库的形式直接调用这些API。,Java应用程序代码,,,导入类库的形式直接调用这些API,
Jena还提供了支持各种RDF三元组格式的解析器和编写器，支持的三元组格式包括：RDF/XML、Turtle、N-Triple和RDFa。,RDF/XML,,,RDF XML,
图3-42Apache_Jena框架实质上，Jena是一个Java框架类库。,Jena,,,一个Java框架类库,
在一般情况下，上述功能需要在Java程序中进行调用。,上述功能,,,Java程序中进行调用,
Jena为了用户使用方便，提供了一个名为Fuseki的独立RDF数据库Web应用程序。,Fuseki,,,Jena,
本实践将使用Fuseki作为认识知识图谱数据库的入门工具。,Fuseki,,,认识知识图谱数据库的入门工具,
Fuseki是基于Jena的SPARQL服务器，可以作为独立的服务由命令行启动，也可以作为操作系统服务或JavaWeb应用程序。,Fuseki,,,基于Jena的SPARQL服务器,
Fuseki是基于Jena的SPARQL服务器，可以作为独立的服务由命令行启动，也可以作为操作系统服务或JavaWeb应用程序。,Fuseki,,,基于Jena的SPARQL服务器,
Fuseki底层存储基于TDB，具有SPARQL查询处理的Web用户界面，同时提供服务器监控和管理功能界面。,Fuseki,,,TDB,
Fuseki支持最新的SPARQL1.1版本，同时支持SPARQL图存储HTTP协议。,Fuseki,,,SPARQL1.1版本同时支持SPARQL图存储HTTP协议,
访问OpenKG可以获取使用实例和整体配置细节。,访问OpenKG,,,使用实例和整体配置细节,
3.其他类似工具RDF4J是Eclipse基金会旗下的开源孵化项目，其前身是荷兰软件公司Aduna开发的Sesame框架，其功能包括：RDF数据的解析、存储、推理和查询等。,RDF4J,,,Eclipse基金会旗下的开源孵化项目,
RDF4J提供内存和磁盘两种RDF存储机制，支持SPARQL1.1查询和更新语言。,RDF4J,,,内存RDF存储机制,
RDF4J提供内存和磁盘两种RDF存储机制，支持SPARQL1.1查询和更新语言。,RDF4J,,,磁盘RDF存储机制,
RDF4J提供内存和磁盘两种RDF存储机制，支持SPARQL1.1查询和更新语言。,RDF4J,,,RDF for Java,
gStore是由北京大学开发的基于图的RDF三元组数据库。,gStore,,,北京大学开发的基于图的RDF三元组数据库,
AllegroGraph是Franz公司开发的RDF三元组数据库。,AllegroGraph,,,Franz公司开发的RDF三元组数据库,
AllegroGraph对语义推理功能具有较为完善的支持。,AllegroGraph,,,语义推理功能,
除了三元组数据库的基本功能，AllegroGraph_RDFS++推理机、OWL2RL推理机、Prolog规则推理系统、时空推理机制、社会网络分析还支持动态物化的库、可视化RDF图浏览器等。,AllegroGraph_RDFS++推理机,,,三元组数据库的基本功能,
除了三元组数据库的基本功能，AllegroGraph_RDFS++推理机、OWL2RL推理机、Prolog规则推理系统、时空推理机制、社会网络分析还支持动态物化的库、可视化RDF图浏览器等。,AllegroGraph_RDFS++推理机,,,AllegroGraph RDFS++ Reasoner,
除了三元组数据库的基本功能，AllegroGraph_RDFS++推理机、OWL2RL推理机、Prolog规则推理系统、时空推理机制、社会网络分析还支持动态物化的库、可视化RDF图浏览器等。,OWL2RL推理机,,,OWL2RL Reasoner,
除了三元组数据库的基本功能，AllegroGraph_RDFS++推理机、OWL2RL推理机、Prolog规则推理系统、时空推理机制、社会网络分析还支持动态物化的库、可视化RDF图浏览器等。,Prolog规则推理系统,,,Prolog Rule Reasoner,
除了三元组数据库的基本功能，AllegroGraph_RDFS++推理机、OWL2RL推理机、Prolog规则推理系统、时空推理机制、社会网络分析还支持动态物化的库、可视化RDF图浏览器等。,时空推理机制,,,Temporal Reasoning Mechanism,
除了三元组数据库的基本功能，AllegroGraph_RDFS++推理机、OWL2RL推理机、Prolog规则推理系统、时空推理机制、社会网络分析还支持动态物化的库、可视化RDF图浏览器等。,社会网络分析,,,Social Network Analysis,
GraphDB是由Ontotext软件公司开发的RDF三元组数据库。,GraphDB,,,Ontotext软件公司开发的RDF三元组数据库,
GraphDB实现了RDF4J框架的SAIL层，可以使用RDF4J的RDF模型、解析器和查询引擎直接访问GraphDB。,GraphDB,,,RDF4J框架的SAIL层,
GraphDB实现了RDF4J框架的SAIL层，可以使用RDF4J的RDF模型、解析器和查询引擎直接访问GraphDB。,GraphDB,,,RDF4J框架的SAIL层,
GraphDB的特色是对于RDF推理功能的良好支持。,GraphDB,,,对于RDF推理功能的良好支持,
3.4.2面向RDF的三元组数据库gStore1.开源工具简介gStore是由北京大学计算机科学技术研究所数据管理实验室自2011年开始研发的面向RDF知识图谱的开源图数据库系统，遵循Apache开源协议。,gStore,,,面向RDF的知识图谱的开源图数据库系统,
3.4.2面向RDF的三元组数据库gStore1.开源工具简介gStore是由北京大学计算机科学技术研究所数据管理实验室自2011年开始研发的面向RDF知识图谱的开源图数据库系统，遵循Apache开源协议。,gStore,,,面向RDF的知识图谱的开源图数据库系统,
不同于传统基于关系数据库的RDF数据管理方法，gStore原生基于图数据模型，在存储RDF数据时维持并根据其图结构构建了基于二进制位图索引的新型索引结构——VS树。,gStore,,,基于图数据模型的RDF数据管理方法,
本实践相关工具、实验数据及操作说明由OpenKG提供，下载链接为http://openkg.cn/tool/gstore。,本实践相关工具,,,OpenKG提供,
2.开源工具的技术架构如图3-43所示为gStore的整体处理流程，gStore的RDF数据管理可分为两部分：离线数据存储和在线查询处理。,gStore的整体处理流程,,,开源工具的技术架构,
图3-43gStore的整体处理流程在离线数据存储阶段，gStore将RDF数据解析成图格式并以邻接表的方式存储在键值数据库上。,gStore,,,离线数据存储,
图3-43gStore的整体处理流程在离线数据存储阶段，gStore将RDF数据解析成图格式并以邻接表的方式存储在键值数据库上。,gStore,,,gStore,
同时，gStore将RDF数据上的所有点和边通过二进制编码的方式编码成若干位图索引，并将这些位图索引组织成VS树。,gStore,,,RDF数据上的所有点和边通过二进制编码的方式编码成若干位图索引，并将这些位图索引组织成VS树,
同时，gStore将RDF数据上的所有点和边通过二进制编码的方式编码成若干位图索引，并将这些位图索引组织成VS树。,gStore,,,VS树,
在在线查询处理阶段，gStore也将SPARQL查询解析成查询图。,gStore,,,在线查询处理阶段,
然后，gStore按照对RDF数据图的编码方式，将SPARQL查询图进行编码以形成一个标签图，并在VS树和RDF数据图的邻接表上进行检索以得到每个查询变量的候选匹配。,gStore,,,对RDF数据图的编码方式,
然后，gStore按照对RDF数据图的编码方式，将SPARQL查询图进行编码以形成一个标签图，并在VS树和RDF数据图的邻接表上进行检索以得到每个查询变量的候选匹配。,SPARQL查询图,,,SPARQL query graph,
最后，gStore将所有查询变量的候选匹配连接成最终匹配。,gStore,,,查询变量的候选匹配连接成最终匹配,
目前，gStore只能在Linux系统上通过Shell命令编译、安装与运行。,gStore,,,Linux系统上通过Shell命令编译、安装与运行,
同时，gStore官网还提供了gStore_Workbench，方便用户操作RDF数据库。,gStore_Workbench,,,gStore官网,
具体包括：（1）环境配置。,SPO,,,环境配置,
可以从OpenKG网站或gStore官网上下载gStore源代码，然后通过make来编译得到gStore运行程序。,gStore,,,OpenKG网站或gStore官网上下载gStore源代码,
同时，通过OpenKG网站或gStore官网可以下载gStore_Workbench，进行编译安装后可以得到gStore_Workbench。,gStore_Workbench,,,OpenKG网站或gStore官网下载,
同时，通过OpenKG网站或gStore官网可以下载gStore_Workbench，进行编译安装后可以得到gStore_Workbench。,gStore_Workbench,,,gStore工作台,
（2）数据导入。,数据导入,,,SPO三元组,
gStore目前支持NT格式的RDF数据，利用gStore安装路径下bin目录中gbuild或者gStore_Workbench中的数据库管理页面导入数据。,gStore,,,NT格式的RDF数据,
gStore_Workbench中的数据库管理页面还记录目前gStore包括的数据库统计信息。,gStore_Workbench中的数据库管理页面,,,记录目前gStore包括的数据库统计信息,
（3）查询处理。,查询处理,,,SPO,
gStore目前完全支持SPARQL1.0查询语法，利用gStore安装路径下bin目录中gquery或者gStoreWorkbench中的图数据库查询页面，就可以输入查询然后得到结果。,gStore,,,SPARQL1.0查询语法,
gStore目前完全支持SPARQL1.0查询语法，利用gStore安装路径下bin目录中gquery或者gStoreWorkbench中的图数据库查询页面，就可以输入查询然后得到结果。,gStore,,,gStore,
gStore同时还提供HTTP接口，可以利用gStore安装路径下bin目录中ghttp启动HTTP服务，进而接收其他机器远程通过HTTP发来的SPARQL查询请求。,gStore,,,HTTP接口,
gStore同时还提供HTTP接口，可以利用gStore安装路径下bin目录中ghttp启动HTTP服务，进而接收其他机器远程通过HTTP发来的SPARQL查询请求。,gStore,,,gStore,
访问OpenKG网站可以获取使用实例和整体配置细节。,OpenKG,,,使用实例和整体配置细节,
3.其他类似工具Jena的前身是惠普实验室（HP_Labs）2000年开发的工具包。,Jena,,,惠普实验室（HP_Labs）2000年开发的工具包,
Jena从发布起就一直是语义Web领域最为流行的开源Java框架和RDF数据库之一，并始终遵循W3C标准，其提供的API功能包括：RDF数据管理、RDFS和OWL本体管理、SPARQL查询处理。,Jena,,,语义Web领域最为流行的开源Java框架和RDF数据库之一,
针对RDF数据，Jena维护了一张大的三元组表和三种属性表，包括单值属性表、多值属性表和属性类表。,Jena,,,维护三元组表和属性表,
针对RDF数据，Jena维护了一张大的三元组表和三种属性表，包括单值属性表、多值属性表和属性类表。,三元组表,,,三元组,
针对RDF数据，Jena维护了一张大的三元组表和三种属性表，包括单值属性表、多值属性表和属性类表。,属性表,,,属性表,
Virtuoso是OpenLink公司开发的知识图谱管理系统，有免费的社区版和收费的商业版。,Virtuoso,,,OpenLink公司开发的知识图谱管理系统,
Virtuoso是可以支持包括RDF在内的多种数据模型的混合数据库管理系统。,Virtuoso,,,混合数据库管理系统,
其基础源自开发了多年的传统关系数据库管理系统，因此具备较为完善的事务管理、并发控制和完整性机制。,ER模型,,,关系数据库管理系统,