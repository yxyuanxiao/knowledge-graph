{"text": "知识图谱是一种用图模型来描述知识和建模世界万物之间的关联关系的技术方法[1]。", "relation": [{"head": "知识图谱", "head_type": "概念", "relation": "被定义为", "tail": "技术方法", "tail_type": "概念"}]}
{"text": "知识图谱由节点和边组成。", "relation": [{"head": "知识图谱", "head_type": "概念", "relation": "包含", "tail": "节点", "tail_type": "概念"}, {"head": "知识图谱", "head_type": "概念", "relation": "包含", "tail": "边", "tail_type": "概念"}]}
{"text": "节点可以是实体，如一个人、一本书等，或是抽象的概念，如人工智能、知识图谱等。", "relation": [{"head": "节点", "head_type": "概念", "relation": "包含", "tail": "实体", "tail_type": "概念"}, {"head": "节点", "head_type": "概念", "relation": "包含", "tail": "概念", "tail_type": "概念"}]}
{"text": "边可以是实体的属性，如姓名、书名，或是实体之间的关系，如朋友、配偶。", "relation": [{"head": "边", "head_type": "概念", "relation": "包含", "tail": "属性", "tail_type": "概念"}, {"head": "边", "head_type": "概念", "relation": "包含", "tail": "关系", "tail_type": "概念"}]}
{"text": "知识图谱的早期理念来自Semantic_Web[2,3]（语义网），其最初理想是把基于文本链接的万维网转化成基于实体链接的语义网。", "relation": [{"head": "知识图谱", "head_type": "概念", "relation": "源于", "tail": "Semantic_Web", "tail_type": "产品"}, {"head": "Semantic_Web", "head_type":"产品" ,"relation": "中文名", "tail": "语义网", "tail_type": "产品"}]}
{"text": "相对于传统的网页互联网，Semantic_Web的本质是数据的互联网（Web_of_Data）或事物的互联网（Web_of_Things）。", "relation": [{"head": "Semantic_Web", "head_type":"产品", "relation": "被定义为", "tail": "数据的互联网", "tail_type": "概念"}, {"head": "Semantic_Web", "head_type":"产品", "relation": "被定义为", "tail": "事物的互联网", "tail_type": "概念"}]}
{"text": "如图1-1所示，知识图谱旨在从数据中识别、发现和推断事物与概念之间的复杂关系，是事物关系的可计算模型。", "relation": [{"head": "知识图谱", "head_type": "概念", "relation": "被定义为", "tail": "事物关系的可计算模型", "tail_type": "概念"}]}
{"text": "构建并利用好知识图谱需要系统性地利用包括知识表示（Knowledge_Representation）、图数据库、自然语言处理、机器学习等多方面的技术。", "relation": [{"head": "知识图谱", "head_type": "概念", "relation": "包含", "tail": "知识表示", "tail_type": "概念"}, {"head": "知识图谱", "head_type": "概念", "relation": "包含", "tail": "图数据库", "tail_type": "概念"}, {"head": "知识图谱", "head_type": "概念", "relation": "包含", "tail": "自然语言处理", "tail_type": "概念"}, {"head": "知识图谱", "head_type": "概念", "relation": "包含", "tail": "机器学习", "tail_type": "概念"}, {"head": "知识表示", "head_type":"概念" ,"relation": "英文名", "tail": "Knowledge_Representation", "tail_type": "概念"}]}
{"text": "从早期的人工智能发展历史来看，Semantic_Web是传统人工智能与Web融合发展的结果，是知识表示与推理在Web中的应用；RDF（Resource_Description_Framework，资源描述框架）、OWL（Web_Ontology_Language，网络本体语言）都是面向Web设计实现的标准化的知识表示语言；而知识图谱则可以看作是Semantic_Web的一种简化后的商业实现，如图1-2所示。", "relation": [{"head": "Semantic_Web", "head_type":"概念", "relation": "被定义为", "tail": "知识表示与推理在Web中的应用", "tail_type": "概念"}, {"head": "RDF", "head_type": "概念", "relation": "被定义为", "tail": "知识表示语言", "tail_type": "概念"}, {"head": "OWL", "head_type": "概念", "relation": "被定义为", "tail": "知识表示语言", "tail_type": "概念"}, {"head": "知识图谱", "head_type": "概念", "relation": "被定义为", "tail": "Semantic_Web的一种简化后的商业实现", "tail_type": "概念"}]}
{"text": "图1-2从语义网络到知识图谱在人工智能的早期发展流派中，符号派（Symbolism）侧重于模拟人的心智，研究怎样用计算机符号表示人脑中的知识并模拟心智的推理过程；连接派（Connectionism）侧重于模拟人脑的生理结构，即人工神经网络。", "relation": [{"head": "符号派", "head_type": "概念", "relation": "研究", "tail": "用计算机符号表示人脑中的知识并模拟心智的推理过程", "tail_type": "概念"}, {"head": "连接派", "head_type": "概念", "relation": "研究", "tail": "模拟人脑的生理结构", "tail_type": "概念"}]}
{"text": "哲学家柏拉图把知识（Knowledge）定义为“Justified_True_Belief”，即知识需要满足三个核心要素：合理性（Justified）、真实性（True）和被相信（Believed）。","relation": [{"head": "知识", "head_type": "概念", "relation": "被定义为", "tail": "Justified_True_Belief", "tail_type": "概念"}, {"head": "知识", "head_type": "概念", "relation": "被定义为", "tail": "合理性、真实性和被相信", "tail_type":"概念"}]}
{"text": "简而言之，知识是人类通过观察、学习和思考有关客观世界的各种现象而获得并总结出的所有事实（Fact）、概念（Concept）、规则（Rule）或原则（Principle）的集合。", "relation": [{"head": "知识", "head_type": "知识", "relation": "被定义为", "tail": "人类通过观察、学习和思考有关客观世界的各种现象而获得并总结出的所有事实、概念、规则或原则的集合", "tail_type": "概念"}]}
{"text": "人工智能的核心也是研究怎样用计算机易于处理的方式表示、学习和处理各种各样的知识。", "relation": [{"head": "人工智能", "head_type":"概念", "relation": "研究", "tail": "研究怎样用计算机易于处理的方式表示、学习和处理各种各样的知识", "tail_type": "概念"}]}
{"text": "知识表示是现实世界的可计算模型（Computable_Model_of_Reality）。", "relation": [{"head": "知识表示", "head_type":"概念", "relation": "被定义为", "tail": "现实世界的可计算模型", "tail_type":"概念"}]}
{"text": "而知识图谱和语义技术提供了关于这些事物的分类、属性和关系的描述，使得搜索引擎可以直接对事物进行索引和搜索，如图1-5所示。","relation": [{"head": "知识图谱", "head_type":"概念", "relation": "研究", "tail": "关于这些事物的分类、属性和关系的描述", "tail_type":"概念"}]}
{"text": "在产业界，IBM Watson背后依托DBpedia和Yago等百科知识库和WordNet等语言学知识库实现深度知识问答。", "relation": [{"head": "IBM_Watson", "head_type":"产品", "relation": "依靠", "tail": "百科知识库", "tail_type": "概念"}, {"head": "IBM_Watson", "head_type":"产品", "relation": "依靠", "tail": "语言学知识库", "tail_type": "概念"}, {"head": "IBM_Watson", "head_type":"产品", "relation": "实现", "tail": "知识问答", "tail_type": "概念"}]}
{"text": "度秘、Siri的进化版Viv、小爱机器人、天猫精灵背后都有海量知识图谱作为支撑。", "relation": [{"head": "度秘", "head_type":"概念", "relation": "依靠", "tail": "知识图谱", "tail_type":"概念"}, {"head": "Viv", "head_type":"概念", "relation": "依靠", "tail": "知识图谱", "tail_type":"概念"}, {"head": "小爱机器人", "head_type":"概念", "relation": "依靠", "tail": "知识图谱", "tail_type":"概念"}, {"head": "天猫精灵", "head_type":"概念", "relation": "依靠", "tail": "知识图谱", "tail_type":"概念"}]}
{"text": "伴随着机器人和IoT设备的智能化浪潮的掀起，基于知识图谱的问答对话在智能驾驶、智能家居和智能厨房等领域的应用层出不穷。","relation": [{"head": "基于知识图谱的问答对话", "head_type":"概念", "relation": "实现", "tail": "智能驾驶", "tail_type":"概念"}, {"head": "基于知识图谱的问答对话", "head_type":"概念", "relation": "实现", "tail": "智能家居", "tail_type":"概念"}, {"head": "基于知识图谱的问答对话", "head_type":"概念", "relation": "实现", "tail": "智能厨房", "tail_type":"概念"}]}
{"text": "典型的基于知识图谱的问答技术或方法包括：基于语义解析、基于图匹配、基于模板学习、基于表示学习和深度学习以及基于混合模型等。","relation": [{"head": "基于知识图谱的问答对话", "head_type":"概念", "relation": "包含", "tail": "语义解析", "tail_type":"概念"}, {"head": "基于知识图谱的问答对话", "head_type":"概念", "relation": "包含", "tail": "图匹配", "tail_type":"概念"}, {"head": "基于知识图谱的问答对话", "head_type":"概念", "relation": "包含", "tail": "模板学习", "tail_type":"概念"}, {"head": "基于知识图谱的问答对话", "head_type":"概念", "relation": "包含", "tail": "表示学习", "tail_type":"概念"}]}
{"text": "在这些方法中，知识图谱既被用来辅助实现语义解析，也被用来匹配问句实体，还被用来训练神经网络和排序模型等。", "relation": [{"head": "知识图谱", "head_type":"概念", "relation": "实现", "tail": "语义解析", "tail_type":"概念"}, {"head": "知识图谱", "head_type":"概念", "relation": "实现", "tail": "匹配问句实体", "tail_type":"概念"}, {"head": "知识图谱", "head_type":"概念", "relation": "实现", "tail": "训练神经网络和排序模型", "tail_type":"概念"}]}
{"text": "3.辅助大数据分析知识图谱和语义技术也被用于辅助进行数据分析与决策。","relation": [{"head": "知识图谱", "head_type":"概念", "relation": "实现", "tail": "数据分析与决策", "tail_type":"概念"}]}
{"text": "知识图谱在文本数据的处理和分析中也能发挥独特的作用。", "relation": [{"head": "知识图谱", "head_type":"概念", "relation": "实现", "tail": "文本数据的处理和分析", "tail_type":"概念"}]}
{"text": "例如，知识图谱被广泛用来作为先验知识从文本中抽取实体和关系，如在远程监督中的应用。", "relation": [{"head": "知识图谱", "head_type":"概念", "relation": "实现", "tail": "从文本中抽取实体和关系", "tail_type":"概念"}]}
{"text": "在这些方法中，知识图谱既被用来辅助实现语义解析，也被用来匹配问句实体，还被用来训练神经网络和排序模型等。", "relation": [{"head": "知识图谱", "head_type":"概念", "relation": "实现", "tail": "辅助实现语义解析", "tail_type":"概念"}, {"head": "知识图谱", "head_type":"概念", "relation": "实现", "tail": "匹配问句实体", "tail_type":"概念"}, {"head": "知识图谱", "head_type":"概念", "relation": "实现", "tail": "训练神经网络和排序模型", "tail_type":"概念"}]}
{"text": "OpenKG.CN聚集了大量开放的中文知识图谱数据、工具及文献，如图1-7所示。", "relation": [{"head": "OpenKG.CN", "head_type":"产品", "relation": "包含", "tail": "知识图谱数据", "tail_type": "概念"}, {"head": "OpenKG.CN", "head_type":"产品", "relation": "包含", "tail": "知识图谱工具", "tail_type": "概念"}, {"head": "OpenKG.CN", "head_type":"产品", "relation": "包含", "tail": "知识图谱文献", "tail_type": "概念"}]}
{"text": "典型的推理包括演绎推理（Deductive_Reasoning）、溯因推理（Reasoning）、归纳推理（Inductive_Abductive_Reasoning）、类比推理（Analogical_Reasoning）等。", "relation": [{"head": "推理", "head_type": "概念", "relation": "包含", "tail": "演绎推理", "tail_type": "概念"}, {"head": "推理", "head_type": "概念", "relation": "包含", "tail": "溯因推理", "tail_type": "概念"}, {"head": "推理", "head_type": "概念", "relation": "包含", "tail": "归纳推理", "tail_type": "概念"}, {"head": "推理", "head_type": "概念", "relation": "包含", "tail": "类比推理", "tail_type": "概念"}]}
{"text": "在知识图谱中，推理主要用于对知识图谱进行补全（Knowledge_Base_Completion,KBC）和知识图谱质量的校验。", "relation": [{"head": "推理", "head_type": "概念", "relation": "实现", "tail": "补全知识图谱", "tail_type": "概念"}, {"head": "推理", "head_type": "概念", "relation": "实现", "tail": "校验知识图谱质量", "tail_type": "概念"}]}
{"text": "知识图谱中的知识可分为概念层和实体层。", "relation": [{"head": "知识图谱", "head_type":"概念", "relation": "包含", "tail": "概念层", "tail_type": "概念"}, {"head": "知识图谱", "head_type":"概念", "relation": "包含", "tail": "实体层", "tail_type": "概念"}]}
{"text": "知识图谱推理的任务是根据知识图谱中已有的知识推理出新的知识或识别出错误的知识。", "relation": [{"head": "知识图谱推理", "head_type":"概念", "relation": "研究", "tail": "根据已有的知识推理出新的知识或识别出错误的知识", "tail_type":"概念"}]}
{"text": "其中，概念层的推理主要包括概念之间的包含关系推理，实体层的推理主要包括链接预测与冲突检测，实体层与概念层之间的推理主要包括实例检测。", "relation": [{"head": "概念层推理", "head_type":"概念", "relation": "包含", "tail": "概念之间的包含关系推理", "tail_type":"概念"}, {"head": "实体层推理", "head_type":"概念", "relation": "包含", "tail": "链接预测与冲突检测", "tail_type":"概念"}, {"head": "实体层与概念层推理", "head_type":"概念", "relation": "包含", "tail": "实例检测", "tail_type":"概念"}]}
{"text": "推理的方法主要包含基于规则的推理、基于分布式表示学习的推理、基于神经网络的推理以及混合推理。", "relation": [{"head": "推理方法", "head_type":"概念", "relation": "包含", "tail": "基于规则的推理", "tail_type":"概念"}, {"head": "推理方法", "head_type":"概念", "relation": "包含", "tail": "基于分布式表示学习的推理", "tail_type":"概念"}, {"head": "推理方法", "head_type":"概念", "relation": "包含", "tail": "基于分布式表示学习的推理", "tail_type":"基于神经网络的推理"}, {"head": "推理方法", "head_type":"概念", "relation": "包含", "tail": "混合推理", "tail_type":"概念"}]}
{"text": "1.基于规则的推理基于规则的推理通过定义或学习知识中存在的规则进行推理。", "relation": [{"head": "基于规则的推理", "head_type":"概念", "relation": "被定义为", "tail": "通过定义或学习知识中存在的规则进行推理", "tail_type":"概念"}]}
{"text": "2.基于分布式表示学习的推理分布式表示学习的核心是将知识图谱映射到连续的向量空间中，并为知识图谱中的元素学习分布式表示为低维稠密的向量或矩阵。", "relation": [{"head": "基于分布式表示学习的推理", "head_type":"概念", "relation": "被定义为", "tail": "将知识图谱映射到连续的向量空间中", "tail_type":"概念"}, {"head": "分布式表示学习", "head_type":"概念", "relation": "被定义为", "tail": "为知识图谱中的元素学习分布式表示为低维稠密的向量或矩阵", "tail_type":"概念"}]}
{"text": "基于规则的知识图谱推理研究主要分为两部分：一是自动规则挖掘系统，二是基于规则的推理系统。", "relation": [{"head": "基于规则的知识图谱推理研究", "head_type":"概念", "relation": "包含", "tail": "自动规则挖掘系统", "tail_type":"概念"}, {"head": "基于规则的知识图谱推理研究", "head_type":"概念", "relation": "包含", "tail": "基于规则的推理系统", "tail_type":"概念"}]}
{"text": "例如，WordNet[23]是典型的语义网络，它定义了名词、动词、形容词和副词之间的语义关系。", "relation": [{"head": "WordNet", "head_type":"产品", "relation": "属于", "tail": "语义网络", "tail_type":"概念"}]}
{"text": "除了辅助搜索，知识图谱也被广泛用于人机问答交互中。", "relation": [{"head": "知识图谱", "head_type":"概念", "relation": "实现", "tail": "人机问答交互", "tail_type":"概念"}]}
{"text": "近几年，知识问答聚焦于解决事实型问答，问题的答案是一个实义词或实义短语。", "relation": [{"head": "知识问答", "head_type":"概念", "relation": "研究", "tail": "解决事实型问答", "tail_type":"概念"}]}
{"text": "事实型问题按问题类型可分为单知识点问题（Single-hop_Questions）和多知识点问题（Multi-hop_Questions）；按问题的领域可分为垂直领域问题和通用领域问题。", "relation": [{"head": "事实型问题", "head_type":"概念", "relation": "包含", "tail": "单知识点问题", "tail_type":"概念"}, {"head": "事实型问题", "head_type":"概念", "relation": "包含", "tail": "多知识点问题", "tail_type":"概念"}, {"head": "事实型问题", "head_type":"概念", "relation": "包含", "tail": "垂直领域问题", "tail_type":"概念"}, {"head": "事实型问题", "head_type":"概念", "relation": "包含", "tail": "通用领域问题", "tail_type":"概念"}]}
{"text": "攻克知识问答的关键在于理解并解析用户提出的自然语言问句。", "relation": [{"head": "知识问答", "head_type":"概念", "relation": "研究", "tail": "理解并解析用户提出的自然语言问句", "tail_type":"概念"}]}
{"text": "相关研究工作在近五年来受到越来越多国内外学者的关注，研究方法主要可分为三大类：基于语义解析（Semantic_Parsing）的方法、基于信息检索（Information_Retrieval）的方法和基于概率模型（Probabilistic_Models）的方法。", "relation": [{"head": "知识问答", "head_type":"概念", "relation": "包含", "tail": "基于语义解析的方法", "tail_type":"概念"}, {"head": "知识问答", "head_type":"概念", "relation": "包含", "tail": "基于信息检索的方法", "tail_type":"概念"}, {"head": "知识问答", "head_type":"概念", "relation": "包含", "tail": "基于概率模型的方法", "tail_type":"概念"}]}
{"text": "第2章知识图谱表示与建模漆桂林东南大学，潘志霖阿伯丁大学，陈华钧浙江大学知识图谱表示（Knowledge_Graph_Representation）指的是用什么语言对知识图谱进行建模，从而可以方便知识计算。","relation": [{"head": "知识图谱表示", "head_type": "概念", "relation": "被定义为", "tail": "用什么语言对知识图谱进行建模而可以方便知识计算", "tail_type": "概念"}]}
{"text": "从图的角度来看，知识图谱是一个语义网络，即一种用互联的节点和弧表示知识的一个结构[1]。","relation": [{"head": "知识图谱", "head_type": "概念", "relation": "属于", "tail": "语义网络", "tail_type": "概念"}, {"head": "语义网络", "head_type": "概念", "relation": "被定义为", "tail": "一种用互联的节点和弧表示知识的一个结构", "tail_type": "概念"}]}
{"text": "语义网络中的节点可以代表一个概念（concept）、一个属性（attribute）、一个事件（event）或者一个实体（entity）；而弧表示节点之间的关系，弧的标签指明了关系的类型。","relation": [{"head": "节点", "head_type": "概念", "relation": "包含", "tail": "概念（concept）", "tail_type": "概念"}, {"head": "节点", "head_type": "概念", "relation": "包含", "tail": "属性（attribute）", "tail_type": "概念"}, {"head": "节点", "head_type": "概念", "relation": "包含", "tail": "事件（event）", "tail_type": "概念"}, {"head": "节点", "head_type": "概念", "relation": "包含", "tail": "实体（entity）", "tail_type": "概念"}, {"head": "弧", "head_type": "概念", "relation": "包含", "tail": "节点之间的关系", "tail_type": "概念"}, {"head": "弧的标签", "head_type": "概念", "relation": "包含", "tail": "关系的类型", "tail_type": "概念"}]}
{"text": "为了给这些边赋予语义，研究人员提出了术语语言（Terminological_Language），并最终提出了描述逻辑（Description_Logic），描述逻辑是一阶谓词逻辑的一个子集，推理复杂度是可判定的。","relation": [{"head": "描述逻辑", "head_type": "概念", "relation": "属于", "tail": "谓词逻辑", "tail_type": "概念"}]}
{"text": "W3C采用了以描述逻辑为逻辑基础的本体语言OWL作为定义Web术语的标准语言。","relation": [{"head": "本体语言OWL", "head_type": "概念", "relation": "属于", "tail": "定义Web术语的标准语言", "tail_type": "概念"}]}
{"text": "目前基于向量的知识表示开始流行，这类表示将知识图谱三元组中的主谓宾表示成数值向量，通过向量的知识表示，可以采用统计或者神经网络的方法进行推理，对知识图谱中的实体之间的关系进行预测。","relation": [{"head": "向量的知识表示的推理", "head_type": "概念", "relation": "依靠", "tail": "统计或者神经网络的方法", "tail_type": "概念"}]}
{"text": "2.1什么是知识表示20世纪90年代，MIT_AI实验室的R.Davis定义了知识表示的五大用途或特点：●客观事物的机器标示（A_KR_is_a_Surrogate），即知识表示首先需要定义客观实体的机器指代或指称。","relation": [{"head": "知识表示的五大用途或特点", "head_type": "概念", "relation": "包含", "tail": "客观事物的机器标示", "tail_type": "概念"}]}
{"text": "●一组本体约定和概念模型（A_KR_is_a_Set_of_Ontological_Commitments），即知识表示还需要定义用于描述客观事物的概念和类别体系。","relation": [{"head": "知识表示的五大用途或特点", "head_type": "概念", "relation": "包含", "tail": "一组本体约定和概念模型", "tail_type": "概念"}]}
{"text": "●支持推理的表示基础（A_KR_is_a_Theory_of_Intelligent_Reasoning），即知识表示还需要提供机器推理的模型与方法。","relation": [{"head": "知识表示的五大用途或特点", "head_type": "概念", "relation": "包含", "tail": "支持推理的表示基础", "tail_type": "概念"}]}
{"text": "●用于高效计算的数据结构（A_KR_is_a_medium_for_Efficient_Computation），即知识表示也是一种用于高效计算的数据结构。","relation": [{"head": "知识表示的五大用途或特点", "head_type": "概念", "relation": "包含", "tail": "用于高效计算的数据结构", "tail_type": "概念"}]}
{"text": "●人可理解的机器语言（A_KR_is_a_Medium_of_Human_Expression），即知识表示还必须接近于人的认知，是人可理解的机器语言。","relation": [{"head": "知识表示的五大用途或特点", "head_type": "概念", "relation": "包含", "tail": "人可理解的机器语言", "tail_type": "概念"}]}
{"text": "典型的语义网络如WordNet属于词典类的知识库，主要定义名词、动词、形容词和副词之间的语义关系。","relation": [{"head": "WordNet", "head_type": "产品", "relation": "属于", "tail": "词典类的知识库", "tail_type": "概念"}, {"head": "WordNet", "head_type": "产品", "relation": "实现", "tail": "名词、动词、形容词和副词之间的语义关系", "tail_type": "概念"}]}
{"text": "传统的专家系统通常包含知识库和推理引擎（InferenceEngine）两个核心模块。","relation": [{"head": "传统的专家系统", "head_type": "概念", "relation": "包含", "tail": "知识库核心模块", "tail_type": "概念"}, {"head": "传统的专家系统", "head_type": "概念", "relation": "包含", "tail": "推理引擎核心模块", "tail_type": "概念"}]}
{"text": "描述逻辑主要用于刻画概念（Concepts）、属性（Roles）、个体（Individual）、关系（Relationships）、元语（Axioms，即逻辑描述Logic_Statement）等知识表达要素。","relation": [{"head": "知识表达要素", "head_type": "概念", "relation": "包含", "tail": "概念（Concepts）", "tail_type": "概念"}, {"head": "知识表达要素", "head_type": "概念", "relation": "包含", "tail": "属性（Roles）", "tail_type": "概念"}, {"head": "知识表达要素", "head_type": "概念", "relation": "包含", "tail": "个体（Individual）", "tail_type": "概念"}, {"head": "知识表达要素", "head_type": "概念", "relation": "包含", "tail": "关系（Relationships）", "tail_type": "概念"}, {"head": "知识表达要素", "head_type": "概念", "relation": "包含", "tail": "元语（Axioms，即逻辑描述Logic_Statement）", "tail_type": "概念"}, {"head": "描述逻辑", "head_type": "概念", "relation": "实现", "tail": "刻画知识表达要素", "tail_type": "概念"}]}
{"text": "与传统专家系统的知识表示语言不同，描述逻辑家族更关心知识表示能力和推理计算复杂性之间的关系，并深入研究了各种表达构件的组合带来的查询、分类、一致性检测等推理计算的计算复杂度问题。","relation": [{"head": "描述逻辑家族", "head_type": "概念", "relation": "研究", "tail": "知识表示能力和推理计算复杂性之间的关系", "tail_type": "概念"}, {"head": "描述逻辑家族", "head_type": "概念", "relation": "研究", "tail": "各种表达构件的组合带来的查询、分类、一致性检测等推理计算的计算复杂度问题", "tail_type": "概念"}]}
{"text": "语义网的基础数据模型RDF受到了元数据模型、框架系统和面向对象语言等多方面的影响，其最初是为人们在Web上发布结构化数据提供一个标准的数据描述框架。","relation": [{"head": "语义网的基础数据模型RDF", "head_type": "概念", "relation": "属于", "tail": "为人们在Web上发布结构化数据提供一个标准的数据描述框架", "tail_type": "概念"}]}
{"text": "无论是早期专家系统时代的知识表示方法，还是语义网时代的知识表示模型，都属于以符号逻辑为基础的知识表示方法。", "relation": [{"head": "早期专家系统时代的知识表示方法", "head_type": "概念", "relation": "属于", "tail": "以符号逻辑为基础的知识表示方法", "tail_type": "概念"}, {"head": "语义网时代的知识表示模型", "head_type": "概念", "relation": "属于", "tail": "以符号逻辑为基础的知识表示方法", "tail_type": "概念"}]}
{"text": "符号知识表示的特点是易于刻画显式、离散的知识，因而具有内生的可解释性。", "relation": [{"head": "符号知识表示的特点", "head_type": "概念", "relation": "包含", "tail": "内生的可解释性", "tail_type": "概念"}, {"head": "符号知识表示的特点", "head_type": "概念", "relation": "包含", "tail": "易于刻画显式、离散的知识", "tail_type": "概念"}]}
{"text": "这种基于连续向量的知识表示可以实现通过数值运算来发现新事实和新关系，并能更有效发现更多的隐式知识和潜在假设，这些隐式知识通常是人的主观不易于观察和总结出来的。", "relation": [{"head": "基于连续向量的知识表示", "head_type": "概念", "relation": "研究", "tail": "新事实和新关系", "tail_type": "概念"}]}
{"text": "一方面，现代知识图谱受到规模化扩展的影响，通常采用以三元组为基础的较为简单实用的知识表示方法，并弱化了对强逻辑表示的要求；另一方面，由于知识图谱是很多搜索、问答和大数据分析系统的重要数据基础，基于向量的知识图谱表示使得这些数据更易于和深度学习模型集成，使得基于向量的知识图谱表示越来越受到重视。", "relation": [{"head": "现代知识图谱", "head_type": "概念", "relation": "依靠", "tail": "以三元组为基础的知识表示方法", "tail_type": "概念"}, {"head": "知识图谱", "head_type": "概念", "relation": "属于", "tail": "搜索、问答和大数据分析系统的重要数据基础", "tail_type": "概念"}]}
{"text": "人类智能往往依赖有意或无意运用已知的知识。", "relation": [{"head": "人类智能", "head_type": "概念", "relation": "依靠", "tail": "已知的知识", "tail_type": "概念"}]}
{"text": "2.2.1一阶谓词逻辑一阶谓词逻辑（或简称一阶逻辑）（First_Order_Logic）是公理系统的标准形式逻辑。", "relation": [{"head": "一阶谓词逻辑", "head_type": "概念", "relation": "被定义为", "tail": "公理系统的标准形式逻辑", "tail_type": "概念"}]}
{"text": "一个子句是文字的析取。", "relation": [{"head": "一个子句", "head_type": "概念", "relation": "属于", "tail": "文字的析取", "tail_type": "概念"}]}
{"text": "霍恩子句是带有最多一个肯定（positive）文字的子句，肯定文字指的是没有否定符号的文字。", "relation": [{"head": "霍恩子句", "head_type": "概念", "relation": "被定义为", "tail": "带有最多一个肯定文字的子句", "tail_type": "概念"}]}
{"text": "霍恩逻辑（Horn_Logic）是一阶逻辑的子集。", "relation": [{"head": "霍恩逻辑", "head_type": "概念", "relation": "被定义为", "tail": "一阶逻辑的子集", "tail_type": "概念"}]}
{"text": "基于霍恩逻辑的知识库是一个霍恩规则的集合。", "relation": [{"head": "基于霍恩逻辑的知识库", "head_type": "概念", "relation": "被定义为", "tail": "一个霍恩规则的集合", "tail_type": "概念"}]}
{"text": "2.霍恩逻辑的缺点●有限的表达能力。", "relation": [{"head": "霍恩逻辑的缺点", "head_type": "概念", "relation": "包含", "tail": "有限的表达能力", "tail_type": "概念"}]}
{"text": "语义网络又称联想网络，它在形式上是一个带标识的有向图。", "relation": [{"head": "语义网络", "head_type": "概念", "relation": "中文名", "tail": "联想网络", "tail_type": "概念"}, {"head": "联想网络", "head_type": "概念", "relation": "属于", "tail": "一个带标识的有向图", "tail_type": "概念"}]}
{"text": "语义网络的单元是三元组：（节点1，联想弧，节点2）。", "relation": [{"head": "三元组", "head_type": "概念", "relation": "被定义为", "tail": "（节点1，联想弧，节点2）", "tail_type": "概念"}]}
{"text": "语义网络是一种结构化的知识表示方法，对数据子图特别有效。", "relation": [{"head": "语义网络", "head_type": "概念", "relation": "属于", "tail": "一种结构化的知识表示方法", "tail_type": "概念"}]}
{"text": "框架是一种描述对象（事物、事件或概念等）属性的数据结构。", "relation": [{"head": "框架", "head_type": "概念", "relation": "属于", "tail": "一种描述对象（事物、事件或概念等）属性的数据结构", "tail_type": "概念"}]}
{"text": "在框架理论中，类是知识表示的基本单位。", "relation": [{"head": "类", "head_type": "概念", "relation": "被定义为", "tail": "知识表示的基本单位", "tail_type": "概念"}]}
{"text": "除此之外，框架还允许给属性设默认值，以及设立触发器以维护框架。", "relation": [{"head": "框架", "head_type": "概念", "relation": "实现", "tail": "给属性设默认值", "tail_type": "概念"}]}
{"text": "表2-1带变量框架实例表2-2变量赋值框架实例1.框架的优点1）结构性：能把事物的属性以及事物间的各种语义联想显式地表示出来。", "relation": [{"head": "框架的优点", "head_type": "概念", "relation": "包含", "tail": "结构性", "tail_type": "概念"}]}
{"text": "2）框架对于知识的描述比较全面，支持默认值以及触发器。", "relation": [{"head": "框架的优点", "head_type": "概念", "relation": "包含", "tail": "支持默认值", "tail_type": "概念"}, {"head": "框架的优点", "head_type": "概念", "relation": "包含", "tail": "支持触发器", "tail_type": "概念"}]}
{"text": "2.2.5描述逻辑描述逻辑是一阶逻辑的一个可判定子集。", "relation": [{"head": "描述逻辑", "head_type": "概念", "relation": "被定义为", "tail": "一阶逻辑的一个可判定子集", "tail_type": "概念"}]}
{"text": "描述逻辑可以被看成是利用一阶逻辑对语义网络和框架进行形式化后的产物。", "relation": [{"head": "描述逻辑", "head_type": "概念", "relation": "属于", "tail": "利用一阶逻辑对语义网络和框架进行形式化后的产物", "tail_type": "概念"}]}
{"text": "一元谓词称为类，二元谓词称为关系。", "relation": [{"head": "一元谓词", "head_type": "概念", "relation": "被定义为", "tail": "类", "tail_type": "概念"}, {"head": "二元谓词", "head_type": "概念", "relation": "被定义为", "tail": "关系", "tail_type": "概念"}]}
{"text": "描述逻辑的重要特征是同时具有很强的表达能力和可判定性。", "relation": [{"head": "描述逻辑的重要特征", "head_type": "概念", "relation": "包含", "tail": "具有很强的表达能力", "tail_type": "概念"}, {"head": "描述逻辑的重要特征", "head_type": "概念", "relation": "包含", "tail": "具有很强的可判定性", "tail_type": "概念"}]}
{"text": "2.3.1RDF和RDFSRDF是W3C的RDF工作组制定的关于知识图谱的国际标准。", "relation": [{"head": "RDF", "head_type": "概念", "relation": "属于", "tail": "W3C的RDF工作组制定的关于知识图谱的国际标准", "tail_type": "概念"}]}
{"text": "RDF是W3C一系列语义网标准的核心，如图2-4所示。", "relation": [{"head": "RDF", "head_type": "概念", "relation": "属于", "tail": "W3C一系列语义网标准的核心", "tail_type": "概念"}]}
{"text": "●表示组（Representation）包括URI/IRI、XML和RDF。", "relation": [{"head": "表示组", "head_type": "概念", "relation": "包含", "tail": "URI/IRI", "tail_type": "概念"}, {"head": "表示组", "head_type": "概念", "relation": "包含", "tail": "XML", "tail_type": "概念"}, {"head": "表示组", "head_type": "概念", "relation": "包含", "tail": "RDF", "tail_type": "概念"}]}
{"text": "●推理组（Reasoning）包括RDF-S、本体OWL、规则RIF和统一逻辑。", "relation": [{"head": "推理组", "head_type": "概念", "relation": "包含", "tail": "RDF-S", "tail_type": "概念"}, {"head": "推理组", "head_type": "概念", "relation": "包含", "tail": "本体OWL", "tail_type": "概念"}, {"head": "推理组", "head_type": "概念", "relation": "包含", "tail": "规则RIF", "tail_type": "概念"}, {"head": "推理组", "head_type": "概念", "relation": "包含", "tail": "统一逻辑", "tail_type": "概念"}]}
{"text": "目前，跟知识图谱最相关的有：图2-4W3C的语义网标准栈及其分组2006年，人们开始用RDF发布和链接数据，从而生成知识图谱，比较知名的有DBpedia、Yago和Freebase。", "relation": [{"head": "用RDF发布和链接数据，从而生成的知识图谱", "head_type": "概念", "relation": "包含", "tail": "DBpedia", "tail_type": "产品"}, {"head": "用RDF发布和链接数据，从而生成的知识图谱", "head_type": "概念", "relation": "包含", "tail": "Yago", "tail_type": "产品"}, {"head": "用RDF发布和链接数据，从而生成的知识图谱", "head_type": "概念", "relation": "包含", "tail": "Freebase", "tail_type": "产品"}]}
{"text": "RDF中的主语是一个个体（Individual），个体是类的实例。", "relation": [{"head": "RDF中的主语", "head_type": "概念", "relation": "被定义为", "tail": "一个个体（Individual）", "tail_type": "概念"}]}
{"text": "RDF中的谓语是一个属性。", "relation": [{"head": "RDF中的谓语", "head_type": "概念", "relation": "被定义为", "tail": "一个属性", "tail_type": "概念"}]}
{"text": "换言之，RDF中的宾语可以是一个个体，例如（IBM-Talk,speaker,Jeff）也可以是一个数据类型的实例，例如（IBM-Talk,talkDate,“05-10-2012”^xsd:date）。", "relation": [{"head": "RDF中的宾语", "head_type": "概念", "relation": "被定义为", "tail": "一个个体", "tail_type": "概念"}, {"head": "RDF中的宾语", "head_type": "概念", "relation": "被定义为", "tail": "一个数据类型的实例", "tail_type": "概念"}]}
{"text": "在RDF中，三元组中的主谓宾都有一个全局标识URI，包括以上例子中的Jeff、IBM_Talk和KG，如图2-7所示。", "relation": [{"head": "三元组中的主谓宾", "head_type": "概念", "relation": "包含", "tail": "全局标识URI", "tail_type": "概念"}]}
{"text": "空白节点的前缀为“_”。", "relation": [{"head": "空白节点的前缀", "head_type": "概念", "relation": "被定义为", "tail": "“_”", "tail_type": "概念"}]}
{"text": "采用开放世界假设意味着RDF图谱可以被分布式储存，如图2-11所示。", "relation": [{"head": "开放世界假设", "head_type": "概念", "relation": "实现", "tail": "RDF图谱可以被分布式储存", "tail_type": "概念"}]}
{"text": "RDFSchema（RDF模式，简称RDFS）提供了对类和属性的简单描述，从而给RDF数据提供词汇建模的语言。", "relation": [{"head": "RDFS", "head_type": "概念", "relation": "实现", "tail": "对类和属性的简单描述", "tail_type": "概念"}]}
{"text": "RDFS提供了最基本的对类和属性的描述元语：●rdf:type：用于指定个体的类；●rdfs:subClassOf：用于指定类的父类；●rdfs:subPropertyOf：用于指定属性的父属性；●rdfs:domain：用于指定属性的定义域；●rdfs:range：用于指定属性的值域。", "relation": [{"head": "rdfs:type", "head_type": "概念", "relation": "被定义为", "tail": "指定个体的类", "tail_type": "概念"}, {"head": "rdfs:subClassOf", "head_type": "概念", "relation": "被定义为", "tail": "指定类的父类", "tail_type": "概念"}, {"head": "rdfs:subPropertyOf", "head_type": "概念", "relation": "被定义为", "tail": "指定属性的父属性", "tail_type": "概念"}, {"head": "rdfs:domain", "head_type": "概念", "relation": "被定义为", "tail": "指定属性的定义域", "tail_type": "概念"}, {"head": "rdfs:range", "head_type": "概念", "relation": "被定义为", "tail": "指定属性的值域", "tail_type": "概念"}]}
{"text": "RDF_Schema通过这样的方式描述不同词汇集的元数据之间的关系，从而为网络上统一格式的元数据交换打下基础。", "relation": [{"head": "RDF_Schema", "head_type": "概念", "relation": "研究", "tail": "不同词汇集的元数据之间的关系", "tail_type": "概念"}]}
{"text": "1.OWL的语言特征如图2-15所示，OWL1.0有OWL_Lite、OWL_DL、OWL_Full三个子语言，三个子语言的特征和使用限制举例如表2-4所示。", "relation": [{"head": "OWL1.0", "head_type": "概念", "relation": "包含", "tail": "OWL_Lite子语言", "tail_type": "产品"}, {"head": "OWL1.0", "head_type": "概念", "relation": "包含", "tail": "OWL_DL子语言", "tail_type": "产品"}, {"head": "OWL1.0", "head_type": "概念", "relation": "包含", "tail": "OWL_Full子语言", "tail_type": "产品"}]}
{"text": "OWL2的三大子语言是OWL_2_RL、OWL_2_QL和OWL_2_EL。", "relation": [{"head": "OWL2的子语言", "head_type": "概念", "relation": "包含", "tail": "OWL_2_RL", "tail_type": "产品"}, {"head": "OWL2的子语言", "head_type": "概念", "relation": "包含", "tail": "OWL_2_QL", "tail_type": "产品"}, {"head": "OWL2的子语言", "head_type": "概念", "relation": "包含", "tail": "OWL_2_EL", "tail_type": "产品"}]}
{"text": "OWL_2_QL是OWL2子语言中最为简单的，QL代表Query_Language，所以OWL_2_QL是专为基于本体的查询设计的。", "relation": [{"head": "OWL_2_QL", "head_type": "概念", "relation": "属于", "tail": "基于本体的查询设计", "tail_type": "概念"}]}
{"text": "它是基于描述逻辑DL-Lite定义的。", "relation": [{"head": "OWL_2_QL", "head_type": "概念", "relation": "源于", "tail": "基于描述逻辑DL-Lite", "tail_type": "概念"}]}
{"text": "表2-6OWL_2_QL词汇总结另外一个能够提供多项式推理的OWL是OWL_2_EL。", "relation": [{"head": "OWL_2_EL", "head_type": "产品", "relation": "属于", "tail": "能够提供多项式推理的OWL", "tail_type": "概念"}]}
{"text": "与OWL_2_QL不同，OWL_2_EL专为概念术语描述、本体的分类推理而设计，广泛应用在生物医疗领域，如临床医疗术语本体SNOMED_CT。", "relation": [{"head": "临床医疗术语本体SNOMED_CT", "head_type": "产品", "relation": "源于", "tail": "OWL_2_EL", "tail_type": "产品"}]}
{"text": "OWL_2_EL的分类复杂度是Ptime-Complete，它是基于描述逻辑语言EL++定义的。", "relation": [{"head": "OWL_2_EL", "head_type": "产品", "relation": "源于", "tail": "描述逻辑语言EL++", "tail_type": "产品"}]}
{"text": "OWL_2_RL扩展了RDFS的表达能力，在RDFS的基础上引入属性的特殊特性（函数性、互反性和对称性），允许声明等价性，允许属性的局部约束。", "relation": [{"head": "OWL_2_RL", "head_type": "产品", "relation": "实现", "tail": "RDFS的表达能力的扩展", "tail_type": "概念"}, {"head": "OWL_2_RL", "head_type": "产品", "relation": "实现", "tail": "属性的特殊特性（函数性、互反性和对称性）", "tail_type": "概念"}]}
{"text": "OWL_2_RL的推理是一种前向链推理，即将推理规则应用到OWL_2_RL本体，得到新的知识，即OWL_2_RL推理是针对实例数据的推理。", "relation": [{"head": "OWL_2_RL推理", "head_type": "概念", "relation": "属于", "tail": "前向链推理", "tail_type": "概念"}, {"head": "OWL_2_RL推理", "head_type": "概念", "relation": "属于", "tail": "针对实例数据的推理", "tail_type": "概念"}]}
{"text": "2.3.3知识图谱查询语言的表示RDF支持类似数据库的查询语言，叫作SPARQL[1]，它提供了查询RDF数据的标准语法、处理SPARQL查询的规则以及结果返回形式。", "relation": [{"head": "类似数据库的查询语言", "head_type": "概念", "relation": "被定义为", "tail": "SPARQL", "tail_type": "产品"}]}
{"text": "被谷歌知识图谱以及Schema.Org采用的语义Markup语言主要包括JSON-LD、RDFa和HTML5MicroData。", "relation": [{"head": "被谷歌知识图谱以及Schema.Org", "head_type": "概念", "relation": "依靠", "tail": "Markup语言", "tail_type": "产品"}, {"head": "Markup语言", "head_type": "产品", "relation": "包含", "tail": "JSON-LD", "tail_type": "产品"}, {"head": "Markup语言", "head_type": "产品", "relation": "包含", "tail": "RDFa", "tail_type": "产品"}, {"head": "Markup语言", "head_type": "产品", "relation": "包含", "tail": "HTML5MicroData", "tail_type": "产品"}]}
{"text": "1.JSON-LDJSON-LD（JavaScript_Object_Notation_for_Linked_Data）是一种基于JSON表示和传输链接数据的方法。", "relation": [{"head": "JSON-LD", "head_type": "产品", "relation": "属于", "tail": "一种基于JSON表示和传输链接数据的方法", "tail_type": "概念"}]}
{"text": "Stores），而是以简2.RDFaRDFa（Resource_Description_Framework_in_attributes）是一种早期网页语义标记语言。", "relation": [{"head": "RDFa", "head_type": "产品", "relation": "属于", "tail": "一种早期网页语义标记语言", "tail_type": "概念"}]}
{"text": "RDFa也是W3C推荐标准。", "relation": [{"head": "RDFa", "head_type": "产品", "relation": "被定义为", "tail": "W3C推荐标准", "tail_type": "概念"}]}
{"text": "3.HTML5_MicrodataMicrodata（微数据）是在网页标记语言中嵌入机器可读的属性数据。", "relation": [{"head": "HTML5_MicrodataMicrodata", "head_type": "产品", "relation": "属于", "tail": "在网页标记语言中嵌入机器可读的属性数据", "tail_type": "概念"}]}
{"text": "微数据是给那些已经在页面上可见的数据施加额外的语义，当HTML的词汇不够用时，使用微数据可以取得较好的效果。", "relation": [{"head": "微数据", "head_type": "概念", "relation": "实现", "tail": "给那些已经在页面上可见的数据施加额外的语义", "tail_type": "概念"}]}
{"text": "2.4.1FreebaseFreebase的知识表示框架主要包含如下几个要素：对象-Object、事实-Facts、类型-ID，称为MIDTypes和属性-Properties。", "relation": [{"head": "FreebaseFreebase的知识表示框架", "head_type": "概念", "relation": "包含", "tail": "对象-Object", "tail_type": "概念"}, {"head": "FreebaseFreebase的知识表示框架", "head_type": "概念", "relation": "包含", "tail": "事实-Facts", "tail_type": "概念"}, {"head": "FreebaseFreebase的知识表示框架", "head_type": "概念", "relation": "包含", "tail": "类型-ID（MIDTypes）", "tail_type": "概念"}, {"head": "FreebaseFreebase的知识表示框架", "head_type": "概念", "relation": "包含", "tail": "属性-Properties", "tail_type": "概念"}]}
{"text": "“Object”代表实体。", "relation": [{"head": "“Object”", "head_type": "概念", "relation": "被定义为", "tail": "实体", "tail_type": "概念"}]}
{"text": "每一个“Object”有唯一的（Machine_ID）。", "relation": [{"head": "每一个“Object”", "head_type": "概念", "relation": "包含", "tail": "唯一的（Machine_ID）", "tail_type": "概念"}]}
{"text": "一个“Object”可以有一个或多个“Types”。", "relation": [{"head": "一个“Object”", "head_type": "概念", "relation": "包含", "tail": "一个或多个“Types”", "tail_type": "概念"}]}
{"text": "图2-16Freebase的知识表示结构示例2.4.2WikidataWikidata的知识表示框架主要包含如下要素：页面-Pages、实体-Entities、条目-Items、属性-Properties、陈述-Statements、修饰-Qualifiers、引用-Reference等。", "relation": [{"head": "Wikidata的知识表示框架", "head_type": "概念", "relation": "包含", "tail": "页面-Pages", "tail_type": "概念"}, {"head": "Wikidata的知识表示框架", "head_type": "概念", "relation": "包含", "tail": "实体-Entities", "tail_type": "概念"}, {"head": "Wikidata的知识表示框架", "head_type": "概念", "relation": "包含", "tail": "条目-Items", "tail_type": "概念"}, {"head": "Wikidata的知识表示框架", "head_type": "概念", "relation": "包含", "tail": "属性-Properties", "tail_type": "概念"}, {"head": "Wikidata的知识表示框架", "head_type": "概念", "relation": "包含", "tail": "陈述-Statements", "tail_type": "概念"}, {"head": "Wikidata的知识表示框架", "head_type": "概念", "relation": "包含", "tail": "修饰-Qualifiers", "tail_type": "概念"}, {"head": "Wikidata的知识表示框架", "head_type": "概念", "relation": "包含", "tail": "引用-Reference", "tail_type": "概念"}]}
{"text": "Wikidata起源于Wikipedia，因此与Wikipedia一样，以页面“Page”为基本的组织单元。", "relation": [{"head": "Wikidata", "head_type": "产品", "relation": "源于", "tail": "Wikipedia", "tail_type": "产品"}]}
{"text": "每一个Entity都有一个独立的维基页面。", "relation": [{"head": "每一个Entity", "head_type": "概念", "relation": "包含", "tail": "一个独立的维基页面", "tail_type": "概念"}]}
{"text": "Entities主要有两类：Items和Properties。", "relation": [{"head": "Entities", "head_type": "概念", "relation": "包含", "tail": "Items", "tail_type": "概念"}, {"head": "Entities", "head_type": "概念", "relation": "包含", "tail": "Properties", "tail_type": "概念"}]}
{"text": "Properties和Statements分别等价于RDF中的Property和Statement。", "relation": [{"head": "Properties", "head_type": "概念", "relation": "等价", "tail": "RDF中的Property", "tail_type": "概念"}, {"head": "Statements", "head_type": "概念", "relation": "等价", "tail": "RDF中的Statement", "tail_type": "概念"}]}
{"text": "通常一个Item的页面还包含多个别名-aliases和多个指向Wikipedia的外部链接-Sitelinks。", "relation": [{"head": "一个Item的页面", "head_type": "概念", "relation": "包含", "tail": "多个别名-aliases", "tail_type": "概念"}, {"head": "一个Item的页面", "head_type": "概念", "relation": "包含", "tail": "多个指向Wikipedia的外部链接-Sitelinks", "tail_type": "概念"}]}
{"text": "每个Entities有多个Statements。", "relation": [{"head": "每个Entities", "head_type": "概念", "relation": "包含", "tail": "多个Statements", "tail_type": "概念"}]}
{"text": "一个Statement包含一个Property、一个或多个Values、一个或多个Qualifiers、一个或多个References、一个标识重要性程度的Rank。", "relation": [{"head": "一个Statement", "head_type": "概念", "relation": "包含", "tail": "一个Property", "tail_type": "概念"}, {"head": "一个Statement", "head_type": "概念", "relation": "包含", "tail": "一个或多个Values", "tail_type": "概念"}, {"head": "一个Statement", "head_type": "概念", "relation": "包含", "tail": "一个或多个Qualifiers", "tail_type": "概念"}, {"head": "一个Statement", "head_type": "概念", "relation": "包含", "tail": "一个或多个References", "tail_type": "概念"}, {"head": "一个Statement", "head_type": "概念", "relation": "包含", "tail": "一个标识重要性程度的Rank", "tail_type": "概念"}]}
{"text": "Wikidata支持多种数值类型，包括其自有的Item类型、RDF_Literal、URL、媒体类型Commons_Media，以及Time、Globe_coordinates和Quantity三种复杂类型。", "relation": [{"head": "Wikidata", "head_type": "产品", "relation": "实现", "tail": "多种数值类型", "tail_type": "概念"}, {"head": "多种数值类型", "head_type": "概念", "relation": "包含", "tail": "自有的Item类型", "tail_type": "概念"}, {"head": "多种数值类型", "head_type": "概念", "relation": "包含", "tail": "RDF_Literal", "tail_type": "概念"}, {"head": "多种数值类型", "head_type": "概念", "relation": "包含", "tail": "URL", "tail_type": "概念"}, {"head": "多种数值类型", "head_type": "概念", "relation": "包含", "tail": "媒体类型Commons_Media", "tail_type": "概念"}, {"head": "多种数值类型", "head_type": "概念", "relation": "包含", "tail": "Time", "tail_type": "概念"}, {"head": "多种数值类型", "head_type": "概念", "relation": "包含", "tail": "Globe_coordinates", "tail_type": "概念"}, {"head": "多种数值类型", "head_type": "概念", "relation": "包含", "tail": "Quantity三种复杂类型", "tail_type": "概念"}]}
{"text": "Wikidata允许给每个Statement增加三种权重：normal（缺省）、preferred和deprecated。", "relation": [{"head": "Wikidata", "head_type": "产品", "relation": "实现", "tail": "给每个Statement增加三种权重", "tail_type": "概念"}, {"head": "三种权重", "head_type": "概念", "relation": "包含", "tail": "normal（缺省）", "tail_type": "概念"}, {"head": "三种权重", "head_type": "概念", "relation": "包含", "tail": "preferred", "tail_type": "概念"}, {"head": "三种权重", "head_type": "概念", "relation": "包含", "tail": "deprecated", "tail_type": "概念"}]}
{"text": "Wikidata定义了三种Snacks作为Statement的具体描述结构：PropertyValueSnack、PropertyNoValueSnack、PropertySomeValueSnack。","relation": [{"head": "三种Snacks", "head_type": "概念", "relation": "被定义为", "tail": "Wikidata的Statement的具体描述结构", "tail_type": "概念"}, {"head": "Statement的具体描述结构", "head_type": "概念", "relation": "包含", "tail": "PropertyValueSnack", "tail_type": "概念"}, {"head": "Statement的具体描述结构", "head_type": "概念", "relation": "包含", "tail": "PropertyNoValueSnack", "tail_type": "概念"}, {"head": "Statement的具体描述结构", "head_type": "概念", "relation": "包含", "tail": "PropertySomeValueSnack", "tail_type": "概念"}]}
{"text": "of_England_had_no_I_Wikidata的URI机制遵循了Linked_Open_Data的URI原则，采用统一的URI机制：Item，如Q49，或者一个http://www.wikidata.org/entity/<id>。", "relation": [{"head": "Wikidata的URI机制", "head_type": "概念", "relation": "依靠", "tail": "Linked_Open_Data的URI原则", "tail_type": "概念"}]}
{"text": "2.4.3ConceptNet5ConceptNet5的知识表示框架主要包含如下要素：概念-Concepts、词-Words、短语-Phrases、断言-Assertions、关系-Relations、边-Edges。", "relation": [{"head": "ConceptNet5的知识表示框架", "head_type": "概念", "relation": "包含", "tail": "概念-Concepts", "tail_type": "概念"}, {"head": "ConceptNet5的知识表示框架", "head_type": "概念", "relation": "包含", "tail": "词-Words", "tail_type": "概念"}, {"head": "ConceptNet5的知识表示框架", "head_type": "概念", "relation": "包含", "tail": "短语-Phrases", "tail_type": "概念"}, {"head": "ConceptNet5的知识表示框架", "head_type": "概念", "relation": "包含", "tail": "断言-Assertions", "tail_type": "概念"}, {"head": "ConceptNet5的知识表示框架", "head_type": "概念", "relation": "包含", "tail": "关系-Relations", "tail_type": "概念"}, {"head": "ConceptNet5的知识表示框架", "head_type": "概念", "relation": "包含", "tail": "边-Edges", "tail_type": "概念"}]}
{"text": "一个Concepts包含多条边，而一条边可能有多个产生来源。","relation": [{"head": "Concepts", "head_type": "概念", "relation": "包含", "tail": "多条边", "tail_type": "概念"}, {"head": "一条边", "head_type": "概念", "relation": "包含", "tail": "一个或多个产生来源", "tail_type": "概念"}]}
{"text": "ConceptNet5中的关系包含21个预定义的、多语言通用的关系，如IsA、UsedFor等，以及从自然语言文本中抽取的更加接近自然语言描述的非形式化的关系，如of,caused_by等。", "relation": [{"head": "ConceptNet5中的关系", "head_type": "概念", "relation": "包含", "tail": "21个预定义的、多语言通用的关系", "tail_type": "概念"}, {"head": "ConceptNet5中的关系", "head_type": "概念", "relation": "包含", "tail": "从自然语言文本中抽取的非形式化的关系", "tail_type": "概念"}]}
{"text": "2.5.1知识图谱表示的挑战在前面提到的一些知识图谱的表示方法中，其基础大多是以三元组的方法对知识进行组织。", "relation": [{"head": "知识图谱的表示方法", "head_type": "概念", "relation": "源于", "tail": "三元组的方法", "tail_type": "概念"}]}
{"text": "1.独热编码传统的独热编码（One-Hot_Encoding）方法是将一个词表示成一个很长的向量，该向量的维度是整个词表的大小。", "relation": [{"head": "向量的维度", "head_type": "概念", "relation": "被定义为", "tail": "整个词表的大小", "tail_type": "概念"}]}
{"text": "2.词袋模型词袋模型（Bag-of-Words,BoW）是一种对文本中词的表示方法。", "relation": [{"head": "词袋模型", "head_type": "概念", "relation": "属于", "tail": "一种对文本中词的表示方法", "tail_type": "概念"}]}
{"text": "图2-19独热编码示例1图2-20独热编码示例23.词向量上面对词的表示方法并没有考虑语义层面的信息，为了更多地表示词与词之间的语义相似程度，提出词的分布式表示，也就是基于上下文的稠密向量表示法，通常称为词向量或词嵌入（Word_Embedding）。", "relation": [{"head": "分布式表示", "head_type": "概念", "relation": "属于", "tail": "基于上下文的稠密向量表示法", "tail_type": "概念"}]}
{"text": "产生词向量的手段主要有三种：●Count-based。基于预测的方法基于任务的方法", "relation": [{"head": "产生词向量的手段", "head_type": "概念", "relation": "包含", "tail": "基于计数的方法", "tail_type": "概念"}, {"head": "产生词向量的手段", "head_type": "概念", "relation": "包含", "tail": "基于预测的方法", "tail_type": "概念"}, {"head": "产生词向量的手段", "head_type": "概念", "relation": "包含", "tail": "基于任务的方法", "tail_type": "概念"}]}
{"text": "基于计数的方法，简单说就是记录文本中词的出现次数。", "relation": [{"head": "基于计数的方法", "head_type": "概念", "relation": "依靠", "tail": "记录文本中词的出现次数", "tail_type": "概念"}]}
{"text": "基于预测的方法，既可以通过上下文预测中心词，也可以通过中心词预测上下文。","relation": [{"head": "基于预测的方法", "head_type": "概念", "relation": "实现", "tail": "通过上下文预测中心词", "tail_type": "概念"}, {"head": "基于预测的方法", "head_type": "概念", "relation": "实现", "tail": "通过中心词预测上下文", "tail_type": "概念"}]}
{"text": "CBoW也就是连续词袋模型（Continuous_Bag-of-Words），和之前提到的BoW相似之处在于该模型也不用考虑词序的信息。","relation": [{"head": "CBoW", "head_type": "产品", "relation": "中文名", "tail": "连续词袋模型", "tail_type": "概念"}]}
{"text": "其主要思想是，用上下文预测中心词，从而训练出的词向量包含了一定的上下文信息。", "relation": [{"head": "训练出的词向量", "head_type": "概念", "relation": "包含", "tail": "一定的上下文信息", "tail_type": "概念"}]}
{"text": "Skip-gram的思想与CBoW恰恰相反，其考虑用中心词来预测上下文词。","relation": [{"head": "Skip-gram", "head_type": "产品", "relation": "实现", "tail": "用中心词来预测上下文词", "tail_type": "概念"}]}
{"text": "TransE[12]便是受到了词向量中平移不变性的启发，在TransE中，把实体和关系都表示为向量，对于某一个具体的关系（head,relation,tail），把关系的向量表示解释成头实体的向量到尾实体的向量的转移向量（Translation_vector）。", "relation": [{"head": "TransE[12]", "head_type": "产品", "relation": "源于", "tail": "词向量中平移不变性", "tail_type": "概念"}, {"head": "关系的向量表示", "head_type": "概念", "relation": "被定义为", "tail": "头实体的向量到尾实体的向量的转移向量", "tail_type": "概念"}]}
{"text": "该方向的模型主要是RESCAL[13]以及它的延伸模型。", "relation": [{"head": "该方向的模型", "head_type": "概念", "relation": "包含", "tail": "RESCAL[13]以及它的延伸模型", "tail_type": "产品"}]}
{"text": "在基于路径的TransE，也就是PTransE[17]中，考虑了相加、相乘和RNN三种用关系表达关系路径的方法：p=r1+r2+⋯+rlp=r1∙r2∙⋯∙rlci=f（W[ci−1;ri]）.在基于RNN的方法中，令c1=r1并且一直遍历路径中的关系，直到最终p=cn。", "relation": [{"head": "PTransE", "head_type": "产品", "relation": "被定义为", "tail": "基于路径的TransE", "tail_type": "概念"}]}
{"text": "文本描述（Textual_Descriptions）指的是在一些知识图谱中，对实体有一些简要的文本描述，如图2-24所示，这些描述本身具有一定的语义信息，对提高嵌入的质量有一定的提升。", "relation": [{"head": "文本描述", "head_type": "概念", "relation": "被定义为", "tail": "在一些知识图谱中，对实体有一些简要的文本描述", "tail_type": "概念"}, {"head": "这些描述", "head_type": "概念", "relation": "包含", "tail": "一定的语义信息", "tail_type": "概念"}]}
{"text": "除了某些知识库本身具有的文本描述，也可以使用外部的文本信息和语料库。", "relation": [{"head": "知识库", "head_type": "概念", "relation": "包含", "tail": "文本描述", "tail_type": "概念"}]}
{"text": "Guo[19]提出了一种以规则为指导的知识图谱嵌入方法，其中提出的软规则（Soft_rule）指的是使用AMIE+规则学习方法在知识图谱中挖掘的带有置信度的规则，该方法的整体框架是一个迭代的过程，其中包含两个部分，称为软标签预测阶段（Soft_Label_Prediction）和嵌入修正阶段（Embedding_Rectification）。", "relation": [{"head": "该方法的整体框架", "head_type": "概念", "relation": "属于", "tail": "一个迭代的过程", "tail_type": "概念"}, {"head": "该方法的整体框架", "head_type": "概念", "relation": "包含", "tail": "两个部分", "tail_type": "概念"}, {"head": "两个部分", "head_type": "概念", "relation": "包含", "tail": "软标签预测阶段（Soft_Label_Prediction）", "tail_type": "概念"}, {"head": "两个部分", "head_type": "概念", "relation": "包含", "tail": "嵌入修正阶段（Embedding_Rectification）", "tail_type": "概念"}]}
{"text": "1.链接预测链接预测（Link_Prediction）指通过一个已知的实体和关系预测另一个实体，或者通过两个实体预测关系。", "relation": [{"head": "链接预测", "head_type": "概念", "relation": "被定义为", "tail": "通过一个已知的实体和关系预测另一个实体", "tail_type": "概念"}, {"head": "链接预测", "head_type": "概念", "relation": "实现", "tail": "通过两个实体预测关系", "tail_type": "概念"}]}
{"text": "简单来说，也就是（h,r,?）,（?,r,t）,（h,?,t）三种知识图谱的补全任务，被称为链接预测。", "relation": [{"head": "（h,r,?）,（?,r,t）,（h,?,t）三种知识图谱的补全任务", "head_type": "概念", "relation": "被定义为", "tail": "链接预测", "tail_type": "概念"}]}
{"text": "一般来说，会用链接预测的正确答案的排序评估某种嵌入模型在链接预测上的能力，比较常见的参数有平均等级（Mean_Rank）、平均倒数等级（Mean_Reciprocal_Rank）和命中前n（Hist@n）。", "relation": [{"head": "比较常见的参数", "head_type": "概念", "relation": "包含", "tail": "平均等级（Mean_Rank）", "tail_type": "概念"}, {"head": "比较常见的参数", "head_type": "概念", "relation": "包含", "tail": "平均倒数等级（Mean_Reciprocal_Rank）", "tail_type": "概念"}, {"head": "比较常见的参数", "head_type": "概念", "relation": "包含", "tail": "命中前n（Hist@n）", "tail_type": "概念"}]}
{"text": "2.三元组分类三元组分类（Triple_Classification）指的是给定一个完整的三元组，判断三元组的真假。", "relation": [{"head": "三元组分类", "head_type": "概念", "relation": "被定义为", "tail": "给定一个完整的三元组，判断三元组的真假", "tail_type": "概念"}]}
{"text": "3.实体对齐实体对齐（Entity_Resolution）也称为实体解析，任务是验证两个实体是否指代或者引用的是同一个事物或对象。", "relation": [{"head": "实体对齐", "head_type": "概念", "relation": "被定义为", "tail": "验证两个实体是否指代或者引用的是同一个事物或对象", "tail_type": "概念"}]}
{"text": "在知识图谱嵌入的发展下，推荐系统也尝试借助知识图谱的信息提高推荐系统的能力。", "relation": [{"head": "推荐系统", "head_type": "概念", "relation": "依靠", "tail": "知识图谱的信息", "tail_type": "概念"}]}
{"text": "Protégé软件是斯坦福大学医学院生物信息研究中心基于Java语言开发的本体编辑和本体开发工具，也是基于知识的编辑器，属于开放源代码软件。", "relation": [{"head": "Protégé软件", "head_type": "产品", "relation": "属于", "tail": "斯坦福大学医学院生物信息研究中心基于Java语言开发的本体编辑和本体开发工具", "tail_type": "概念"}, {"head": "Protégé软件", "head_type": "产品", "relation": "属于", "tail": "基于知识的编辑器", "tail_type": "概念"}, {"head": "Protégé软件", "head_type": "产品", "relation": "属于", "tail": "开放源代码软件", "tail_type": "概念"}]}
{"text": "●Protégé可以通过两种方式进行扩展：插件和基于Java的API。", "relation": [{"head": "Protégé", "head_type": "产品", "relation": "包含", "tail": "两种扩展方式", "tail_type": "概念"}, {"head": "扩展方式", "head_type": "概念", "relation": "包含", "tail": "插件", "tail_type": "概念"}, {"head": "扩展方式", "head_type": "概念", "relation": "包含", "tail": "基于Java的API", "tail_type": "概念"}]}
{"text": "Protégé的常见用途包括：类建模、实例编辑、模型处理和模型交换。", "relation": [{"head": "Protégé的常见用途", "head_type": "概念", "relation": "包含", "tail": "模型交换", "tail_type": "概念"}, {"head": "Protégé的常见用途", "head_type": "概念", "relation": "包含", "tail": "类建模", "tail_type": "概念"}, {"head": "Protégé的常见用途", "head_type": "概念", "relation": "包含", "tail": "实例编辑", "tail_type": "概念"}, {"head": "Protégé的常见用途", "head_type": "概念", "relation": "包含", "tail": "模型处理", "tail_type": "概念"}]}
{"text": "为了更好地进行三元组数据的存储，语义万维网领域发展出专门存储RDF数据的三元组库；数据库领域发展出用于管理属性图的图数据库。", "relation": [{"head": "语义万维网领域", "head_type": "概念", "relation": "研究", "tail": "专门存储RDF数据的三元组库", "tail_type": "概念"}, {"head": "数据库领域", "head_type": "概念", "relation": "研究", "tail": "用于管理属性图的图数据库", "tail_type": "概念"}]}
{"text": "本章首先介绍图数据模型和图查询语言等基本知识；以演示操作的方式讲解各种主流知识图谱数据库，包括基于关系数据库的存储方案、面向RDF的三元组数据库和原生图数据库；以图数据库Neo4j为例介绍图模型数据的底层存储细节，同时梳理图数据索引和查询处理等关键技术；最后，以Apache_Jena为例，针对知识图谱数据库开源工具进行实践。", "relation": [{"head": "各种主流知识图谱数据库", "head_type": "概念", "relation": "包含", "tail": "基于关系数据库的存储方案", "tail_type": "概念"}, {"head": "各种主流知识图谱数据库", "head_type": "概念", "relation": "包含", "tail": "面向RDF的三元组数据库", "tail_type": "概念"}, {"head": "各种主流知识图谱数据库", "head_type": "概念", "relation": "包含", "tail": "原生图数据库", "tail_type": "概念"}]}
{"text": "3.1知识图谱数据库基本知识本节首先介绍目前表示知识图谱的两种主要图数据模型：RDF图和属性图。", "relation": [{"head": "目前表示知识图谱的两种主要图数据模型", "head_type": "概念", "relation": "包含", "tail": "RDF图", "tail_type": "概念"}, {"head": "目前表示知识图谱的两种主要图数据模型", "head_type": "概念", "relation": "包含", "tail": "属性图", "tail_type": "概念"}]}
{"text": "3.1.1知识图谱数据模型从数据模型角度来看，知识图谱本质上是一种图数据。", "relation": [{"head": "知识图谱", "head_type": "概念", "relation": "被定义为", "tail": "一种图数据", "tail_type": "概念"}]}
{"text": "往往一个数据模型的生命力要看其数学基础的强弱，关系模型长盛不衰的一个重要原因是其数学基础为关系代数。", "relation": [{"head": "一个数据模型的生命力", "head_type": "概念", "relation": "依靠", "tail": "其数学基础", "tail_type": "概念"}, {"head": "关系模型", "head_type": "概念", "relation": "被定义为", "tail": "关系代数", "tail_type": "概念"}]}
{"text": "知识图谱数据模型的数学基础源于有着近300年历史的数学分支——图论。", "relation": [{"head": "知识图谱数据模型的数学基础", "head_type": "概念", "relation": "源于", "tail": "图论", "tail_type": "概念"}]}
{"text": "在图论中，图是二元组G=（V,E），其中V是节点集合，E是边集合。", "relation": [{"head": "图", "head_type": "概念", "relation": "被定义为", "tail": "二元组G=（V,E）", "tail_type": "概念"}, {"head": "二元组G=（V,E）", "head_type": "概念", "relation": "包含", "tail": "V", "tail_type": "概念"}, {"head": "二元组G=（V,E）", "head_type": "概念", "relation": "包含", "tail": "E", "tail_type": "概念"}]}
{"text": "知识图谱数据模型基于图论中图的定义，用节点集合表示实体，用边集合表示实体间的联系，这种一般和通用的数据表示恰好能够自然地刻画现实世界中事物的广泛联系。", "relation": [{"head": "知识图谱数据模型", "head_type": "概念", "relation": "依靠", "tail": "图论中图的定义", "tail_type": "概念"}, {"head": "节点集合", "head_type": "概念", "relation": "实现", "tail": "实体", "tail_type": "概念"}, {"head": "边集合", "head_type": "概念", "relation": "实现", "tail": "实体间的联系", "tail_type": "概念"}, {"head": "数据表示", "head_type": "概念", "relation": "实现", "tail": "现实世界中事物的广泛联系", "tail_type": "概念"}]}
{"text": "1.RDF图RDF是W3C制定的在语义万维网上表示和交换机器可理解信息的标准数据模型[1]。", "relation": [{"head": "RDF图RDF", "head_type": "概念", "relation": "被定义为", "tail": "W3C制定的在语义万维网上表示和交换机器可理解信息的标准数据模型", "tail_type": "概念"}]}
{"text": "在RDF三元组集合中，每个Web资源具有一个HTTP_URI作为其唯一的id；一个RDF图定义为三元组(s,p,o)的有限集合；每个三元组代表一个陈述句，其中s是主语，p是谓语，o是宾语；(s,p,o)表示资源s与资源o之间具有联系p，或表示资源s具有属性p且其取值为o。", "relation": [{"head": "RDF图", "head_type": "概念", "relation": "被定义为", "tail": "三元组(s,p,o)的有限集合", "tail_type": "概念"}, {"head": "三元组(s,p,o)", "head_type": "概念", "relation": "等价", "tail": "一个陈述句", "tail_type": "概念"}, {"head": "陈述句", "head_type": "概念", "relation": "包含", "tail": "s主语", "tail_type": "概念"}, {"head": "陈述句", "head_type": "概念", "relation": "包含", "tail": "p谓语", "tail_type": "概念"}, {"head": "陈述句", "head_type": "概念", "relation": "包含", "tail": "o宾语", "tail_type": "概念"}]}
{"text": "实际上，RDF三元组集合即为图中的有向边集合。", "relation": [{"head": "RDF三元组集合", "head_type": "概念", "relation": "属于", "tail": "图中的有向边集合", "tail_type": "概念"}]}
{"text": "节点属性可用三元组表示，这类三元组的宾语称为字面量，即图中的矩形。", "relation": [{"head": "节点属性", "head_type": "概念", "relation": "依靠", "tail": "三元组", "tail_type": "概念"}, {"head": "三元组的宾语", "head_type": "概念", "relation": "被定义为", "tail": "字面量", "tail_type": "概念"}]}
{"text": "目前，RDF图上的查询语言是SPARQL；属性图上的查询语言常用的是Cypher和Gremlin。", "relation": [{"head": "RDF图查询语言", "head_type": "概念", "relation": "依靠", "tail": "SPARQL", "tail_type": "产品"}, {"head": "属性图查询语言常用的", "head_type": "概念", "relation": "是", "tail": "Cypher", "tail_type": "产品"}, {"head": "属性图查询语言常用的", "head_type": "概念", "relation": "是", "tail": "Gremlin", "tail_type": "产品"}]}
{"text": "1.SPARQLSPARQL是W3C制定的RDF图数据的标准查询语言[4]。", "relation": [{"head": "SPARQL", "head_type": "产品", "relation": "属于", "tail": "W3C制定的RDF图数据的标准查询语言[4]", "tail_type": "概念"}]}
{"text": "SPARQL从语法上借鉴了SQL，同样属于声明式查询语言。", "relation": [{"head": "SPARQL", "head_type": "产品", "relation": "源于", "tail": "SQL", "tail_type": "产品"}, {"head": "SPARQL", "head_type": "产品", "relation": "属于", "tail": "声明式查询语言", "tail_type": "概念"}]}
{"text": "最新的SPARQL1.1版本为有效查询RDF图专门设计了三元组模式、子图模式、属性路径等多种查询机制。", "relation": [{"head": "最新的SPARQL1.1版本", "head_type": "产品", "relation": "实现", "tail": "三元组模式查询机制", "tail_type": "概念"}, {"head": "最新的SPARQL1.1版本", "head_type": "产品", "relation": "实现", "tail": "子图模式查询机制", "tail_type": "概念"}, {"head": "最新的SPARQL1.1版本", "head_type": "产品", "relation": "实现", "tail": "属性路径查询机制", "tail_type": "概念"}]}
{"text": "几乎全部的RDF三元组数据库都实现了SPARQL语言。", "relation": [{"head": "RDF三元组数据库", "head_type": "概念", "relation": "实现", "tail": "SPARQL语言", "tail_type": "产品"}]}
{"text": "三元组模式查询是最基本的SPARQL查询。", "relation": [{"head": "三元组模式查询", "head_type": "概念", "relation": "属于", "tail": "最基本的SPARQL查询", "tail_type": "概念"}]}
{"text": "这里既有?p和?pr分别作为两个三元组模式的宾语和主语连接起来的链式模式，也有?p作为两个三元组模式的主语连接起来的星形结构，该查询是一个更加一般的BGP查询。", "relation": [{"head": "两个三元组模式的宾语和主语连接起来的链式模式", "head_type": "概念", "relation": "属于", "tail": "BGP查询", "tail_type": "概念"}, {"head": "?p作为两个三元组模式的主语连接起来的星形结构", "head_type": "概念", "relation": "属于", "tail": "BGP查询", "tail_type": "概念"}]}
{"text": "实际上，BGP查询相当于一个带有变量的查询图，查询过程是在数据图中寻找与查询图映射Isomorphism）或子图同态匹配的所有子图，等价于图论中的子图同构（Subgraph_Homomorphism）问题[5]，所以也将BGP查询称为子图匹配查询。", "relation": [{"head": "BGP查询", "head_type": "概念", "relation": "等价", "tail": "一个带有变量的查询图", "tail_type": "概念"}, {"head": "BGP查询", "head_type": "概念", "relation": "等价", "tail": "子图匹配查询", "tail_type": "概念"}]}
{"text": "1.1引入的属性路径（Property_SPARQL)实际上是一整套知识服务标准体系。", "relation": [{"head": "属性路径", "head_type": "概念", "relation": "英文名", "tail": "Property_SPARQL", "tail_type": "概念"}, {"head": "属性路径", "head_type": "概念", "relation": "属于", "tail": "一整套知识服务标准体系", "tail_type": "概念"}]}
{"text": "SPARQL1.1语言的语法和语义的完整定义请参见W3C的推荐标准“SPARQL1.1查询语言”[4]，该标准连同其他10个推荐标准共同组成了SPARQL知识平台，包括查询[4]、更新[6]、服务描述[7]、联邦查询[8]、查询结果格式[9]、蕴涵推理[10]和接口协议[11]等。", "relation": [{"head": "SPARQL1.1语言的语法和语义的完整定义", "head_type": "概念", "relation": "依靠", "tail": "W3C的推荐标准“SPARQL1.1查询语言”", "tail_type": "概念"}, {"head": "SPARQL知识平台", "head_type": "概念", "relation": "包含", "tail": "查询", "tail_type": "概念"}, {"head": "SPARQL知识平台", "head_type": "概念", "relation": "包含", "tail": "更新", "tail_type": "概念"}, {"head": "SPARQL知识平台", "head_type": "概念", "relation": "包含", "tail": "服务描述", "tail_type": "概念"}, {"head": "SPARQL知识平台", "head_type": "概念", "relation": "包含", "tail": "联邦查询", "tail_type": "概念"}, {"head": "SPARQL知识平台", "head_type": "概念", "relation": "包含", "tail": "查询结果格式", "tail_type": "概念"}, {"head": "SPARQL知识平台", "head_type": "概念", "relation": "包含", "tail": "蕴涵推理", "tail_type": "概念"}, {"head": "SPARQL知识平台", "head_type": "概念", "relation": "包含", "tail": "接口协议", "tail_type": "概念"}]}
{"text": "开放的SPARQL学习教程有WikiBooks_SPARQL教程[12]、Wikidata_SPARQL教程[13]和Apache_Jena_SPARQL教程[14]等。", "relation": [{"head": "开放的SPARQL学习教程", "head_type": "概念", "relation": "包含", "tail": "WikiBooks_SPARQL教程", "tail_type": "概念"}, {"head": "开放的SPARQL学习教程", "head_type": "概念", "relation": "包含", "tail": "Wikidata_SPARQL教程", "tail_type": "概念"}, {"head": "开放的SPARQL学习教程", "head_type": "概念", "relation": "包含", "tail": "Apache_Jena_SPARQL教程", "tail_type": "概念"}]}
{"text": "2.CypherCypher最初是图数据库Neo4j中实现的属性图数据查询语言[15]。", "relation": [{"head": "Cypher", "head_type": "产品", "relation": "属于", "tail": "图数据库Neo4j中实现的属性图数据查询语言", "tail_type": "概念"}]}
{"text": "2015年，Neo4j公司发起开源项目openCypher[16]，旨在对Cypher进行标准化工作，为其他实现者提供语法和语义的参考标准。", "relation": [{"head": "Neo4j公司", "head_type": "产品", "relation": "研究", "tail": "开源项目openCypher", "tail_type": "产品"}]}
{"text": "虽然Cypher的发展目前仍由Neo4j主导，但包括SAP_HANA_Graph[17]、Redis_Graph[18]、AgensGraph[19]和Memgraph[20]等在内的图数据库产品已经实现了Cypher。", "relation": [{"head": "图数据库产品", "head_type": "概念", "relation": "实现了", "tail": "Cypher", "tail_type": "产品"}]}
{"text": "3.GremlinGremlin是Apache_TinkerPop图计算框架[21]提供的属性图查询语言[22]。", "relation": [{"head": "Gremlin", "head_type": "产品", "relation": "属于", "tail": "Apache_TinkerPop图计算框架提供的属性图查询语言", "tail_type": "概念"}]}
{"text": "ApacheTinkerPop被设计为访问图数据库的通用API接口，其作用类似于关系数据库上的JDBC接口。", "relation": [{"head": "ApacheTinkerPop", "head_type": "产品", "relation": "属于", "tail": "访问图数据库的通用API接口", "tail_type": "概念"}]}
{"text": "Gremlin的定位是图遍历语言，其执行机制好比是一个人置身于图中沿着有向边，从一个节点到另一个节点进行导航式的游走。", "relation": [{"head": "Gremlin", "head_type": "产品", "relation": "属于", "tail": "图遍历语言", "tail_type": "概念"}]}
{"text": "这种执行方式决定了用户使用Gremlin需要指明具体的导航步骤，这和自己驾驶汽车到一个目的地需要知道行车路线是一个道理，所以将Gremlin归为过程式语言，即需要明确“怎么做”。", "relation": [{"head": "Gremlin", "head_type": "产品", "relation": "属于", "tail": "过程式语言", "tail_type": "概念"}]}
{"text": "这类语言的优点是可以时刻知道自己在图中所处的位置，以及是如何到达该位置的；缺点是用户需要“认识路”！与受到SQL影响的声明式语言SPARQL和Cypher不同，Gremlin更像一种函数式的编程语言接口。", "relation": [{"head": "Gremlin", "head_type": "产品", "relation": "等价", "tail": "一种函数式的编程语言接口", "tail_type": "概念"}]}
{"text": "（1）列出图中所有节点的属性输出：说明：V表示节点集合。", "relation": [{"head": "V", "head_type": "概念", "relation": "被定义为", "tail": "节点集合", "tail_type": "概念"}]}
{"text": "（2）列出图中所有的边输出：说明：E表示边集合。", "relation": [{"head": "E", "head_type": "概念", "relation": "被定义为", "tail": "边集合", "tail_type": "概念"}]}
{"text": "（3）查询从节点1出发的标签为“认识”的边输出：说明：v(1)选取id为1的节点；outE表示节点的出边集合，outE(’认识’)是标签为“认识”的出边集合。", "relation": [ {"head": "节点的出边集合", "head_type": "概念", "relation": "被定义为", "tail": "outE", "tail_type": "概念"}]}
{"text": "3.2常见知识图谱存储方法本节介绍三类知识图谱数据库：基于关系数据库的存储方案、面向RDF的三元组数据库和原生图数据库，多数系统给出了演示操作步骤。", "relation": [{"head": "常见知识图谱存储方法", "head_type": "概念", "relation": "包含", "tail": "基于关系数据库的存储方案", "tail_type": "概念"}, {"head": "常见知识图谱存储方法", "head_type": "概念", "relation": "包含", "tail": "面向RDF的三元组数据库", "tail_type": "概念"}, {"head": "常见知识图谱存储方法", "head_type": "概念", "relation": "包含", "tail": "原生图数据库", "tail_type": "概念"}]}
{"text": "在历史上，关系数据库曾经取代了层次数据库和网状数据库；成功吸收容纳了面向对象数据库和XML数据库，成为现今数据管理的主流数据库产品。", "relation": [{"head": "关系数据库", "head_type": "概念", "relation": "源于", "tail": "面向对象数据库", "tail_type": "概念"}, {"head": "关系数据库", "head_type": "概念", "relation": "源于", "tail": "XML数据库", "tail_type": "概念"}]}
{"text": "商业数据库包括Oracle、DB2和SQL_Server等，开源数据库包括PostgreSQL和MySQL等。", "relation": [{"head": "商业数据库", "head_type": "概念", "relation": "包含", "tail": "Oracle", "tail_type": "产品"}, {"head": "商业数据库", "head_type": "概念", "relation": "包含", "tail": "DB2", "tail_type": "产品"}, {"head": "商业数据库", "head_type": "概念", "relation": "包含", "tail": "SQL_Server", "tail_type": "产品"}, {"head": "开源数据库", "head_type": "概念", "relation": "包含", "tail": "PostgreSQL", "tail_type": "产品"}, {"head": "开源数据库", "head_type": "概念", "relation": "包含", "tail": "MySQL", "tail_type": "产品"}]}
{"text": "基于关系数据库的存储方案是目前知识图谱采用的一种主要存储方法。", "relation": [{"head": "基于关系数据库的存储方案", "head_type": "概念", "relation": "属于", "tail": "目前知识图谱采用的一种主要存储方法", "tail_type": "概念"}]}
{"text": "本小节将按照时间发展顺序简要介绍各种基于关系表的知识图谱存储结构，包括三元组表、水平表、属性表、垂直划分、六重索引和DB2RDF。", "relation": [{"head": "基于关系表的知识图谱存储结构", "head_type": "概念", "relation": "包含", "tail": "三元组表", "tail_type": "概念"}, {"head": "基于关系表的知识图谱存储结构", "head_type": "概念", "relation": "包含", "tail": "水平表", "tail_type": "概念"}, {"head": "基于关系表的知识图谱存储结构", "head_type": "概念", "relation": "包含", "tail": "属性表", "tail_type": "概念"}, {"head": "基于关系表的知识图谱存储结构", "head_type": "概念", "relation": "包含", "tail": "垂直划分", "tail_type": "概念"}, {"head": "基于关系表的知识图谱存储结构", "head_type": "概念", "relation": "包含", "tail": "六重索引", "tail_type": "概念"}, {"head": "基于关系表的知识图谱存储结构", "head_type": "概念", "relation": "包含", "tail": "DB2RDF", "tail_type": "概念"}]}
{"text": "图3-4摘自DBpedia数据集的RDF知识图谱1.三元组表三元组表是将知识图谱存储到关系数据库的最简单、最直接的办法，就是在关系数据库中建立一张具有3列的表，该表的模式为：三元组表(主语，谓语，宾语)将知识图谱中的每条三元组存储为三元组表中的一行记录。", "relation": [{"head": "三元组表", "head_type": "概念", "relation": "被定义为", "tail": "将知识图谱存储到关系数据库的最简单、最直接的办法", "tail_type": "概念"}]}
{"text": "采用三元组表存储方案的代表是RDF数据库系统3store[24]。", "relation": [{"head": "RDF数据库系统3store", "head_type": "概念", "relation": "属于", "tail": "采用三元组表存储方案的代表", "tail_type": "概念"}]}
{"text": "实际上，水平表就相当于知识图谱的邻接表。", "relation": [{"head": "水平表", "head_type": "概念", "relation": "等价", "tail": "知识图谱的邻接表", "tail_type": "概念"}]}
{"text": "不难看出，水平表的列数是知识图谱中不同谓语的数量，行数是知识图谱中不同主语的数量。", "relation": [{"head": "水平表的列数", "head_type": "概念", "relation": "被定义为", "tail": "知识图谱中不同谓语的数量", "tail_type": "概念"}, {"head": "水平表的行数", "head_type": "概念", "relation": "被定义为", "tail": "知识图谱中不同主语的数量", "tail_type": "概念"}]}
{"text": "采用水平表存储方案的代表是早期的RDF数据库系统DLDB[25]。", "relation": [{"head": "早期的RDF数据库系统DLDB", "head_type": "概念", "relation": "属于", "tail": "采用水平表存储方案的代表", "tail_type": "概念"}]}
{"text": "实际上，水平表方案是属性表存储方案的一种极端情况，即水平表是将所有主语划归为一类，因此属性表中的空值问题与水平表相比会大为缓解。", "relation": [{"head": "水平表方案", "head_type": "概念", "relation": "属于", "tail": "属性表存储方案的一种极端情况", "tail_type": "概念"}]}
{"text": "采用垂直划分存储方案的代表数据库是SW-Store[28]。", "relation": [{"head": "SW-Store", "head_type": "产品", "relation": "依靠", "tail": "垂直划分存储方案", "tail_type": "概念"}]}
{"text": "5.六重索引六重索引（SextupleIndexing）存储方案是对三元组表的扩展，是一种典型的“空间换时间”策略，其将三元组全部6种排列对应地建立为6张表，即spo(主语，谓语，宾语)、pos(谓语，宾语，主语)、osp(宾语，主语，谓语)、sop(主语，宾语，谓语)、pso(谓语，主语，宾语)和ops(宾语，谓语，主语)", "relation": [{"head": "六重索引存储方案", "head_type": "概念", "relation": "源于", "tail": "三元组表的扩展", "tail_type": "概念"}, {"head": "六重索引存储方案", "head_type": "概念", "relation": "属于", "tail": "典型的“空间换时间”策略", "tail_type": "概念"}, {"head": "spo", "head_type": "概念", "relation": "被定义为", "tail": "主语，谓语，宾语", "tail_type": "概念"}, {"head": "pos", "head_type": "概念", "relation": "被定义为", "tail": "谓语，宾语，主语", "tail_type": "概念"}, {"head": "osp", "head_type": "概念", "relation": "被定义为", "tail": "宾语，主语，谓语", "tail_type": "概念"}, {"head": "sop", "head_type": "概念", "relation": "被定义为", "tail": "主语，宾语，谓语", "tail_type": "概念"}, {"head": "pso", "head_type": "概念", "relation": "被定义为", "tail": "谓语，主语，宾语", "tail_type": "概念"}, {"head": "ops", "head_type": "概念", "relation": "被定义为", "tail": "宾语，谓语，主语", "tail_type": "概念"}]}
{"text": "不难看出，其中spo表就是原来的三元组表。", "relation": [{"head": "spo表", "head_type": "概念", "relation": "等价", "tail": "原来的三元组表", "tail_type": "概念"}]}
{"text": "使用六重索引方法的典型系统有RDF-3X[28]和Hexastore[29]。", "relation": [{"head": "使用六重索引方法的典型系统", "head_type": "概念", "relation": "包含", "tail": "RDF-3X", "tail_type": "产品"}, {"head": "使用六重索引方法的典型系统", "head_type": "概念", "relation": "包含", "tail": "Hexastore", "tail_type": "产品"}]}
{"text": "具体来说，六重索引方案的优点有：知识图谱查询中的每种三元组模式查询都可以直接使用相应的索引表进行快速的前缀范围查找，表3-3给出了全部8种三元组模式查询能够使用的索引表；可以通过不同索引表之间的连接操作直接加速知识图谱上的连接查询，如图3-12所示的链式SPARQL查询“查找生于1850年的人创立的公司的营业领域”，可以通过spo和pso表的连接快速执行三元组模式“?person_founder_?company”与“?company_industry?ind”的连接操作，避免了单表的自连接。", "relation": [{"head": "六重索引方案", "head_type": "概念", "relation": "包含", "tail": "知识图谱查询中的每种三元组模式查询", "tail_type": "概念"}]}
{"text": "DB2RDFDB2RDF是由IBM研究中心于2013年提出的一种面向实体的RDF知识图谱存储方案[30]，该方案是以往RDF关系存储方案的一种权衡折中，既具备了三元组表、属性表和垂直划分方案的部分优点，又克服了这些方案的部分缺点。", "relation": [{"head": "DB2RDFDB2RDF", "head_type": "产品", "relation": "属于", "tail": "一种面向实体的RDF知识图谱存储方案", "tail_type": "概念"}, {"head": "DB2RDFDB2RDF", "head_type": "产品", "relation": "属于", "tail": "一种权衡折中的方案", "tail_type": "概念"}]}
{"text": "三元组表的优势在于“行维度”上的灵活性，即存储模式不会随行的增加而变化；DB2RDF方案将这种灵活性扩展到“列维度”上，即将表的列作为谓语和宾语的存储位置，而不将列与谓语进行绑定。", "relation": [{"head": "三元组表", "head_type": "概念", "relation": "实现", "tail": "行维度的灵活性", "tail_type": "概念"}]}
{"text": "dph（direct_primary_hash）是存储方案的主表，该表中一行存储一个主语（主语列）及其全部谓语（predi列）和宾语（vali列）,0≤i≤k,k为图着色结果值或某个给定值。", "relation": [{"head": "dph表", "head_type": "概念", "relation": "包含", "tail": "主语", "tail_type": "概念"}, {"head": "dph表", "head_type": "概念", "relation": "包含", "tail": "谓语", "tail_type": "概念"}, {"head": "dph表", "head_type": "概念", "relation": "包含", "tail": "宾语", "tail_type": "概念"}]}
{"text": "spill列是溢出标志，即对于一行能存储下的实体，该行spill列为0，对于溢出的实体，该实体所有行的spill列为1。", "relation": [{"head": "spill列", "head_type": "概念", "relation": "被定义为", "tail": "溢出标志", "tail_type": "概念"}]}
{"text": "实际上，dph表实现了列的共享：一方面，不同实体的相同谓语总是会被分配到相同的列上；另一方面，同一列中可以存储多个不同的谓语。", "relation": [{"head": "dph表", "head_type": "概念", "relation": "实现", "tail": "列的共享", "tail_type": "概念"}]}
{"text": "正是由于DB2RDF方案具备“列共享”机制，才使得在关系表中最大列数目上限的情况下可以存储远超出该上限的谓语数目，也能够有效地解决水平表方案中存在的谓语稀疏性空值问题。", "relation": [{"head": "DB2RDF方案", "head_type": "概念", "relation": "实现", "tail": "列共享机制", "tail_type": "概念"}]}
{"text": "在真实的知识图谱中，不同主语往往具有不同的谓语集合，例如，谓语born只有人才具有，谓语employees只有公司才具有，这也是能够实现列共享的原因所在。", "relation": [{"head": "真实的知识图谱", "head_type": "概念", "relation": "包含", "tail": "不同的谓语集合", "tail_type": "概念"}]}
{"text": "为此，DB2RDF方案提供了rph（reverse_primary_hash）表和rs（reverse_secondary_hash）表，如图3-13所示。", "relation": [{"head": "DB2RDF方案", "head_type": "概念", "relation": "包含", "tail": "rph表", "tail_type": "概念"}, {"head": "DB2RDF方案", "head_type": "概念", "relation": "包含", "tail": "rs表", "tail_type": "概念"}]}
{"text": "谓语到列映射的一种方法是使用一组散列函数，将谓语映射到一组列编号，并将谓语及其宾语存储到这组列中的第一个空列上；在一个主语对应的一行中，如果存储某谓语（及其宾语）时，散列函数计算得出的这组列中的所有列都被之前存储的该主语的谓语占用了，则产生溢出，到下一行存储该谓语。", "relation": [{"head": "谓语到列映射", "head_type": "概念", "relation": "属于", "tail": "使用一组散列函数的方法", "tail_type": "概念"}]}
{"text": "将一个主语上出现的不同谓语称为共现谓语（Co-occurrence_Predicates），目标是让共现谓语着上不同颜色（映射到不同列中），非共现谓语可以着上相同颜色（映射到同一列中）。", "relation": [{"head": "共现谓语", "head_type": "概念", "relation": "英文名", "tail": "Co-occurrence_Predicates", "tail_type": "概念"}]}
{"text": "为此，构建图着色算法的冲突图（Interference_Graph）：图中节点为知识图谱中的所有谓语；每对共现谓语节点之间由一条边相连。", "relation": [{"head": "冲突图", "head_type": "概念", "relation": "源于", "tail": "图着色算法", "tail_type": "概念"}]}
{"text": "图3-15冲突图如果在大规模真实知识图谱（如DBpedia）中，图着色所需颜色数量超过了关系数据表的列数上限m，则根据某种策略（如最频繁使用的前k个谓语）选取一个谓语子集，使得该谓语子集到列的映射满足图着色要求；对于不在该子集中的谓语，再使用前面提到的散列函数组策略进行映射。", "relation": [{"head": "DBpedia", "head_type": "产品", "relation": "属于", "tail": "大规模真实知识图谱", "tail_type": "概念"}]}
{"text": "3.2.2面向RDF的三元组数据库由于RDF是W3C推荐的表示语义网上关联数据（Linked_Data）的标准格式，RDF也是表示和发布Web上知识图谱的最主要数据格式之一。", "relation": [{"head": "RDF", "head_type": "概念", "relation": "被定义为", "tail": "W3C推荐的表示语义网上关联数据的标准格式", "tail_type": "概念"}, {"head": "RDF", "head_type": "概念", "relation": "属于", "tail": "表示和发布Web上知识图谱的最主要数据格式", "tail_type": "概念"}]}
{"text": "面向RDF的三元组数据库是专门为存储大规模RDF数据而开发的知识图谱数据库，其支持RDF的标准查询语言SPARQL。", "relation": [{"head": "面向RDF的三元组数据库", "head_type": "概念", "relation": "属于", "tail": "专门为存储大规模RDF数据而开发的知识图谱数据库", "tail_type": "概念"}]}
{"text": "主要的开源RDF三元组数据库包括：Apache旗下的Jena、Eclipse旗下的RDF4J以及源自学术界的RDF-3X和gStore；主要的商业RDF三元组数据库包括：Virtuoso、AllegroGraph、GraphDB和BlazeGraph。", "relation": [{"head": "主要的开源RDF三元组数据库", "head_type": "概念", "relation": "包含", "tail": "Apache旗下的Jena", "tail_type": "产品"}, {"head": "主要的开源RDF三元组数据库", "head_type": "概念", "relation": "包含", "tail": "Eclipse旗下的RDF4J", "tail_type": "产品"}, {"head": "主要的开源RDF三元组数据库", "head_type": "概念", "relation": "包含", "tail": "源自学术界的RDF-3X", "tail_type": "产品"}, {"head": "主要的开源RDF三元组数据库", "head_type": "概念", "relation": "包含", "tail": "gStore", "tail_type": "产品"}, {"head": "主要的商业RDF三元组数据库", "head_type": "概念", "relation": "包含", "tail": "Virtuoso", "tail_type": "产品"}, {"head": "主要的商业RDF三元组数据库", "head_type": "概念", "relation": "包含", "tail": "AllegroGraph", "tail_type": "产品"}, {"head": "主要的商业RDF三元组数据库", "head_type": "概念", "relation": "包含", "tail": "GraphDB", "tail_type": "产品"}, {"head": "主要的商业RDF三元组数据库", "head_type": "概念", "relation": "包含", "tail": "BlazeGraph", "tail_type": "产品"}]}
{"text": "1.开源RDF三元组数据库RDF4JRDF4J目前是Eclipse基金会旗下的开源孵化项目，其前身是荷兰软件公司Aduna开发的Sesame框架。", "relation": [{"head": "RDF4J", "head_type": "产品", "relation": "属于", "tail": "Eclipse基金会旗下的开源孵化项目", "tail_type": "概念"}, {"head": "RDF4J", "head_type": "产品", "relation": "源于", "tail": "荷兰软件公司Aduna开发的Sesame框架", "tail_type": "产品"}]}
{"text": "Sesame框架的历史可以追溯到1999年，当时作为Aduna公司的一个语义Web项目进行开发，后来发展成为语义Web领域一个非常有名的管理和处理RDF的开源Java框架，功能包括RDF数据的解析、存储、推理和查询等。", "relation": [{"head": "Sesame框架", "head_type": "产品", "relation": "属于", "tail": "一个非常有名的管理和处理RDF的开源Java框架", "tail_type": "概念"}, {"head": "Sesame框架功能", "head_type": "概念", "relation": "实现", "tail": "RDF数据的解析", "tail_type": "概念"}, {"head": "Sesame框架功能", "head_type": "概念", "relation": "实现", "tail": "RDF数据的存储", "tail_type": "概念"}, {"head": "Sesame框架功能", "head_type": "概念", "relation": "实现", "tail": "RDF数据的推理", "tail_type": "概念"}, {"head": "Sesame框架功能", "head_type": "概念", "relation": "实现", "tail": "RDF数据的查询", "tail_type": "概念"}]}
{"text": "2016年5月，Sesame框架改名为RDF4J，并迁移为Eclipse开源项目继续开发。", "relation": [{"head": "RDF4J", "head_type": "产品", "relation": "源于", "tail": "Sesame框架", "tail_type": "产品"}]}
{"text": "RDF4J框架的重要特点是其模块化的软件架构设计。", "relation": [{"head": "RDF4J框架", "head_type": "产品", "relation": "包含", "tail": "具有模块化的软件架构设计", "tail_type": "概念"}]}
{"text": "（2）Rio代表“RDF_I/O”，即RDF输入/输出，包括各种RDF文件格式的解析器（Parser）和编写器（Writer），解析器负责将RDF文件解析为RDF模型中的三元组语句，编写器负责将三元组语句写为RDF文件。", "relation": [{"head": "Rio", "head_type": "概念", "relation": "等价", "tail": "RDF_I/O", "tail_type": "概念"}, {"head": "Rio", "head_type": "概念", "relation": "包含", "tail": "各种RDF文件格式的解析器（Parser）", "tail_type": "概念"}, {"head": "Rio", "head_type": "概念", "relation": "包含", "tail": "各种RDF文件格式的编写器（Writer）", "tail_type": "概念"}]}
{"text": "（3）Sail_API代表“存储和推理层API”（Storage_And_Inference_Layer_API），是实现RDF存储和推理的底层系统（System）API（即SPI），其作用是将RDF存储和推理功能从底层实现细节中抽象出来，使得底层存储和推理实现模块可以透明地被替换；Sail_API是SAIL底层存储开发者需要实现的API，普通用户无须关心；RDF4J自带了两种SailAPI实现，即基于内存的MemoryStore和基于磁盘的NativeStore。", "relation": [{"head": "Sail_API", "head_type": "概念", "relation": "等价", "tail": "存储和推理层API", "tail_type": "概念"}, {"head": "Sail_API", "head_type": "概念", "relation": "包含", "tail": "实现RDF存储和推理的底层系统API", "tail_type": "概念"}, {"head": "Sail_API", "head_type": "概念", "relation": "属于", "tail": "SAIL底层存储开发者需要实现的API", "tail_type": "概念"}]}
{"text": "（4）存储库API（Repository_API）是用户使用的RDF管理和处理高层API，提供RDF的存储、查询和推理等服务，面向终端用户，简单易用；存储库API的一种实现是基于本地SAIL实现的SailRepository，另一种是基于远程HTTP服务器实现的HttpRepository。", "relation": [{"head": "存储库API", "head_type": "概念", "relation": "属于", "tail": "用户使用的RDF管理和处理高层API", "tail_type": "概念"}, {"head": "存储库API", "head_type": "概念", "relation": "包含", "tail": "RDF的存储服务", "tail_type": "概念"}, {"head": "存储库API", "head_type": "概念", "relation": "包含", "tail": "RDF的查询服务", "tail_type": "概念"}, {"head": "存储库API", "head_type": "概念", "relation": "包含", "tail": "RDF的推理服务", "tail_type": "概念"}, {"head": "存储库API", "head_type": "概念", "relation": "属于", "tail": "基于本地SAIL实现的SailRepository", "tail_type": "概念"}, {"head": "存储库API", "head_type": "概念", "relation": "属于", "tail": "基于远程HTTP服务器实现的HttpRepository", "tail_type": "概念"}]}
{"text": "图3-17使用RDF4J工作台执行SPARQL查询2.开源RDF三元组数据库RDF-3XRDF-3X是由德国马克斯·普朗克计算机科学研究所研发的RDF三元组数据库系统，其最初成果发表于2008年的数据库国际会议VLDB[28]，后经功能扩展和完善，最新版本是GH-RDF3X，源代码可以从GitHub上下载。", "relation": [{"head": "RDF-3X", "head_type": "产品", "relation": "属于", "tail": "开源RDF三元组数据库", "tail_type": "概念"}]}
{"text": "图3-18使用spo索引进行三元组模式查找RDF-3X的查询处理器首先对SPARQL查询进行转化，生成若干查询执行计划；对于仅包含一个三元组模式的查询，可以通过一次相应索引查找操作完成；对于由多个三元组模式组成的查询，需要对多个连接的顺序进行优化。", "relation": [{"head": "RDF-3X的查询处理器", "head_type": "概念", "relation": "依靠", "tail": "spo索引", "tail_type": "概念"}]}
{"text": "RDF-3X采用的是一种自底向上的动态规划优化算法，其优化过程充分考虑了SPARQL查询的特点，并且最大限度地保持了有利于用全索引方案进行归并连接的连接顺序。", "relation": [{"head": "RDF-3X", "head_type": "产品", "relation": "依靠", "tail": "动态规划优化算法", "tail_type": "概念"}]}
{"text": "同时，RDF-3X还开发了基于代价模型的选择度评估（SelectivityEstimates）机制，采用选择度直方图和频繁连接路径相结合的方法进行查询执行计划的选择度评估。", "relation": [{"head": "RDF-3X", "head_type": "产品", "relation": "实现", "tail": "基于代价模型的选择度评估机制", "tail_type": "概念"}]}
{"text": "RDF-3X是命令行程序，使用RDF-3X装载RDF文件music_1000_triples.nt的命令如图3-19所示，其中的rdf3xload是命令名称，testds是数据库名称；进行SPARQL查询的命令如图3-20所示，rdf3query是命令名称，sparql.rq是SPARQL查询文件名称。", "relation": [{"head": "RDF-3X", "head_type": "产品", "relation": "属于", "tail": "命令行程序", "tail_type": "概念"}]}
{"text": "由于Franz公司有着深厚的人工智能背景，早期一直开发Common_Lisp和Prolog语言的实现工具，这使得AllegroGraph对语义推理功能具有较为完善的支持。", "relation": [{"head": "Franz公司", "head_type": "产品", "relation": "研究", "tail": "Common_Lisp和Prolog语言的实现工具", "tail_type": "概念"}, {"head": "AllegroGraph", "head_type": "产品", "relation": "包含", "tail": "较为完善的语义推理功能", "tail_type": "概念"}]}
{"text": "AllegroGraph除了三元组数据库的基本功能外，还支持动态物化的RDFS++推理机、OWL2_RL推理机、Prolog规则推理系统、时空推理机制、社会网络分析库、可视化RDF图浏览器等。", "relation": [{"head": "AllegroGraph", "head_type": "产品", "relation": "实现", "tail": "动态物化的RDFS++推理机", "tail_type": "概念"}, {"head": "AllegroGraph", "head_type": "产品", "relation": "实现", "tail": "OWL2_RL推理机", "tail_type": "概念"}, {"head": "AllegroGraph", "head_type": "产品", "relation": "实现", "tail": "Prolog规则推理系统", "tail_type": "概念"}, {"head": "AllegroGraph", "head_type": "产品", "relation": "实现", "tail": "时空推理机制", "tail_type": "概念"}, {"head": "AllegroGraph", "head_type": "产品", "relation": "实现", "tail": "社会网络分析库", "tail_type": "概念"}, {"head": "AllegroGraph", "head_type": "产品", "relation": "实现", "tail": "可视化RDF图浏览器", "tail_type": "概念"}]}
{"text": "6.商业RDF三元组数据库GraphDBGraphDB是RDF三元组数据库，其前身OWLIM一直是支持W3C语义Web标准的主流产品。", "relation": [{"head": "GraphDB", "head_type": "产品", "relation": "属于", "tail": "商业RDF三元组数据库", "tail_type": "概念"}, {"head": "OWLIM", "head_type": "产品", "relation": "源于", "tail": "GraphDB", "tail_type": "产品"}]}
{"text": "（1）Workbench是GraphDB的Web管理工具；（2）Engine是查询处理和推理引擎，由查询优化器（Query_Optimiser）、推理机（Reasoner）、存储层（Storage）和插件管理器（Plugin_Manager）组成；●查询优化器能够在多种查询执行计划中挑选出较高效的一种，查询经过解析后会交由查询优化器进行优化；●推理机执行基于RDF规则的前向链推理，由显式三元组推导出全部导出三元组，导出三元组会随显式三元组的更新而同步更新；●存储层使用pos和pso两种三元组索引、psco和pocs两种带有上下文信息的四元组索引以及字面值（Literal）索引存储RDF数据；实体池（Entity_Pool）是GraphDB存储层的核心部件，起到将RDF实体（URI、空节点和字面值）映射到内部整数ID的字典编码器的作用，同时还实现了对事务管理的支持机制。", "relation": [{"head": "Engine", "head_type": "产品", "relation": "属于", "tail": "查询处理和推理引擎", "tail_type": "概念"}, {"head": "Engine", "head_type": "产品", "relation": "包含", "tail": "查询优化器", "tail_type": "概念"}, {"head": "Engine", "head_type": "产品", "relation": "包含", "tail": "推理机", "tail_type": "概念"}, {"head": "Engine", "head_type": "产品", "relation": "包含", "tail": "存储层", "tail_type": "概念"}, {"head": "Engine", "head_type": "产品", "relation": "包含", "tail": "插件管理", "tail_type": "概念"}, {"head": "推理机", "head_type": "概念", "relation": "实现", "tail": "基于RDF规则的前向链推理", "tail_type": "概念"}, {"head": "存储层", "head_type": "概念", "relation": "实现", "tail": "pos和pso两种三元组索引", "tail_type": "概念"}, {"head": "存储层", "head_type": "概念", "relation": "实现", "tail": "psco和pocs两种带有上下文信息的四元组索引", "tail_type": "概念"}, {"head": "实体池", "head_type": "概念", "relation": "属于", "tail": "GraphDB存储层的核心部件", "tail_type": "概念"}, {"head": "GraphDB存储层的核心部件", "head_type": "概念", "relation": "实现", "tail": "对事务管理的支持机制", "tail_type": "概念"}]}
{"text": "（3）Connectors是GraphDB连接外部工具的桥梁，包括用于建立快速关键字查找功能的Lucene和用于建立搜索引擎的Solr和Elasticsearch。", "relation": [{"head": "Connectors", "head_type": "产品", "relation": "属于", "tail": "GraphDB连接外部工具的桥梁", "tail_type": "概念"}, {"head": "Connectors", "head_type": "产品", "relation": "实现", "tail": "用于建立快速关键字查找功能的Lucene", "tail_type": "产品"}, {"head": "Connectors", "head_type": "产品", "relation": "实现", "tail": "用于建立搜索引擎的Solr和Elasticsearch", "tail_type": "产品"}]}
{"text": "商业RDF三元组数据库StardogStardog是由美国Stardog_Union公司开发的RDF三元组数据库，其首个公开发布版本是2012年2月发布的Stardog0.9。", "relation": [{"head": "Stardog", "head_type": "产品", "relation": "属于", "tail": "商业RDF三元组数据库", "tail_type": "概念"}]}
{"text": "虽然Stardog发布较晚，但其对OWL2推理机制具有良好的支持，同时具备全文搜索、GraphQL查询、路径查询、融合机器学习任务等功能，能够支持多种不同编程语言和Web访问接口，使得Stardog成为一个知识图谱数据存储和查询平台。", "relation": [{"head": "Stardog", "head_type": "产品", "relation": "实现", "tail": "全文搜索功能", "tail_type": "概念"}, {"head": "Stardog", "head_type": "产品", "relation": "实现", "tail": "GraphQL查询功能", "tail_type": "概念"}, {"head": "Stardog", "head_type": "产品", "relation": "实现", "tail": "路径查询功能", "tail_type": "概念"}, {"head": "Stardog", "head_type": "产品", "relation": "实现", "tail": "融合机器学习任务功能", "tail_type": "概念"}]}
{"text": "图3-29使用Stardog_Studio执行SPARQL查询3.2.3原生图数据库1.最流行的图数据库Neo4jNeo4j的1.0版本发布于2010年。", "relation": [{"head": "Neo4j", "head_type": "产品", "relation": "属于", "tail": "最流行的图数据库", "tail_type": "概念"}]}
{"text": "Neo4j基于属性图模型，其存储管理层为属性图结构中的节点、节点属性、边、边属性等设计了专门的存储方案。", "relation": [{"head": "Neo4j", "head_type": "产品", "relation": "源于", "tail": "属性图模型", "tail_type": "概念"}]}
{"text": "同时，Neo4j还具备OLTP数据库必需的ACID事务处理功能。", "relation": [{"head": "Neo4j", "head_type": "产品", "relation": "实现", "tail": "OLTP数据库必需的ACID事务处理功能", "tail_type": "概念"}]}
{"text": "Neo4j浏览器是功能完善的Neo4j可视化交互式客户端工具，可以用于执行Cypher语言。", "relation": [{"head": "Neo4j浏览器", "head_type": "产品", "relation": "属于", "tail": "功能完善的Neo4j可视化交互式客户端工具", "tail_type": "概念"}]}
{"text": "同时，JanusGraph也是OLTP图数据库，其支持多用户并发访问和实时图遍历查询。", "relation": [{"head": "JanusGraph", "head_type": "产品", "relation": "属于", "tail": "OLTP图数据库", "tail_type": "概念"}, {"head": "OLTP图数据库", "head_type": "概念", "relation": "实现", "tail": "多用户并发访问和实时图遍历查询", "tail_type": "概念"}]}
{"text": "另一方面，JanusGraph还具备基于Hadoop_MapReduce的图分析引擎，其可以将Gremlin导航查询自动转化为MapReduce任务。", "relation": [{"head": "JanusGraph", "head_type": "概念", "relation": "实现", "tail": "基于Hadoop_MapReduce的图分析引擎", "tail_type": "概念"}]}
{"text": "从数据管理角度来看，OrientDB是一个功能上相对全面的数据库管理系统，除对图数据基本的存储和查询外，还支持完整的事务处理ACID特性、基于多主机复制模式（Multi-Master_Replication）的分布式部署、对于多种操作系统的支持（由于使用Java开发）和数据库安全性支持等。", "relation": [{"head": "OrientDB", "head_type": "产品", "relation": "属于", "tail": "数据库管理系统", "tail_type": "概念"}, {"head": "OrientDB", "head_type": "产品", "relation": "实现", "tail": "事务处理ACID特性", "tail_type": "概念"}, {"head": "数据库管理系统", "head_type": "概念", "relation": "实现", "tail": "基于多主机复制模式的分布式部署", "tail_type": "概念"}]}
{"text": "需要注意的是，每个边记录实际上维护着两个双向链表，一个是起始节点上的边，一个是终止节点上的边，可以将边记录想象为被起始节点和终止节点共同拥有，双向链表的优势在于不仅可在查找节点上的边时进行双向扫描，而且支持在两个节点间高效率地添加和删除边。", "relation": [{"head": "双向链表", "head_type": "概念", "relation": "实现", "tail": "在两个节点间高效率地添加和删除边", "tail_type": "概念"}]}
{"text": "2.图结构索引图结构索引是为图数据中的点边结构信息建立索引的方法。", "relation": [{"head": "图结构索引", "head_type": "概念", "relation": "被定义为", "tail": "为图数据中的点边结构信息建立索引", "tail_type": "概念"}]}
{"text": "大体上，图结构索引分为“基于路径的”和“基于子图的”两种。", "relation": [{"head": "图结构索引", "head_type": "概念", "relation": "包含", "tail": "“基于路径的”", "tail_type": "概念"}, {"head": "图结构索引", "head_type": "概念", "relation": "包含", "tail": "“基于子图的“", "tail_type": "概念"}]}
{"text": "一种典型的基于路径的图索引叫作GraphGrep[36]。", "relation": [{"head": "GraphGrep", "head_type": "概念", "relation": "属于", "tail": "基于路径的图索引", "tail_type": "概念"}]}
{"text": "一种叫作gIndex[37]的索引方法，首先利用数据挖掘方法，在图数据中发现出现次数超过一定阈值的频繁子图，再将去掉冗余之后的频繁子图作为关键字建立子图索引。", "relation": [{"head": "gIndex", "head_type": "产品", "relation": "属于", "tail": "一种索引方法", "tail_type": "概念"}]}
{"text": "三元组数据库Apache_Jena1开源工具简介。Apache_Jena是Apache顶级项目，其前身为惠普实验室开发的Jena工具包。", "relation": [{"head": "Apache_Jena", "head_type": "产品", "relation": "属于", "tail": "三元组数据库", "tail_type": "概念"}, {"head": "Apache_Jena", "head_type": "产品", "relation": "源于", "tail": "Jena", "tail_type": "产品"}]}
{"text": "Jena具备一套原生存储引擎，可对RDF三元组进行基于磁盘或内存的存储管理；同时具有一套基于规则的推理引擎，用于执行RDFS和OWL本体推理任务。", "relation": [{"head": "Jena", "head_type": "产品", "relation": "依靠", "tail": "一套原生存储引擎", "tail_type": "概念"}, {"head": "Jena", "head_type": "产品", "relation": "实现", "tail": "RDF三元组进行基于磁盘或内存的存储管理", "tail_type": "概念"}, {"head": "Jena", "head_type": "产品", "relation": "包含", "tail": "一套基于规则的推理引擎", "tail_type": "概念"}, {"head": "Jena", "head_type": "概念", "relation": "实现", "tail": "RDFS和OWL本体推理任务", "tail_type": "概念"}]}
{"text": "Jena对外界应用程序的API包括实现基本三元组管理功能的RDFAPI、实现RDFS和OWL本体推理功能的本体API和实现查询处理功能的SPARQL_API。", "relation": [{"head": "Jena的API", "head_type": "产品", "relation": "实现", "tail": "三元组管理功能", "tail_type": "概念"}, {"head": "Jena的API", "head_type": "产品", "relation": "实现", "tail": "本体推理功能", "tail_type": "概念"}, {"head": "Jena的API", "head_type": "产品", "relation": "实现", "tail": "查询处理功能", "tail_type": "概念"}]}
{"text": "Jena还提供了支持各种RDF三元组格式的解析器和编写器，支持的三元组格式包括：RDF/XML、Turtle、N-Triple和RDFa。", "relation": [{"head": "Jena", "head_type": "产品", "relation": "实现", "tail": "RDF三元组格式的解析器和编写器", "tail_type": "概念"}]}
{"text": "图3-42Apache_Jena框架实质上，Jena是一个Java框架类库。", "relation": [{"head": "Jena", "head_type": "产品", "relation": "属于", "tail": "一个Java框架类库", "tail_type": "概念"}]}
{"text": "Jena为了用户使用方便，提供了一个名为Fuseki的独立RDF数据库Web应用程序。", "relation": [{"head": "Jena", "head_type": "产品", "relation": "实现", "tail": "独立RDF数据库Web应用程序", "tail_type": "概念"}]}
{"text": "Fuseki是基于Jena的SPARQL服务器，可以作为独立的服务由命令行启动，也可以作为操作系统服务或Java_Web应用程序。", "relation": [{"head": "Fuseki", "head_type": "产品", "relation": "依靠", "tail": "基于Jena的SPARQL服务器", "tail_type": "产品"}]}
{"text": "Fuseki底层存储基于TDB，具有SPARQL查询处理的Web用户界面，同时提供服务器监控和管理功能界面。", "relation": [{"head": "Fuseki底层存储", "head_type": "概念", "relation": "依靠", "tail": "TDB", "tail_type": "概念"}, {"head": "Fuseki", "head_type": "产品", "relation": "实现", "tail": "SPARQL查询处理的Web用户界面", "tail_type": "概念"}, {"head": "Fuseki", "head_type": "产品", "relation": "实现", "tail": "服务器监控界面", "tail_type": "概念"}, {"head": "Fuseki", "head_type": "产品", "relation": "实现", "tail": "管理功能界面", "tail_type": "概念"}]}
{"text": "3.其他类似工具RDF4J是Eclipse基金会旗下的开源孵化项目，其前身是荷兰软件公司Aduna开发的Sesame框架，其功能包括：RDF数据的解析、存储、推理和查询等。", "relation": [{"head": "RDF4J", "head_type": "产品", "relation": "属于", "tail": "Eclipse基金会的项目", "tail_type": "概念"}, {"head": "RDF4J", "head_type": "产品", "relation": "实现", "tail": "RDF数据的解析功能", "tail_type": "概念"}, {"head": "RDF4J", "head_type": "产品", "relation": "实现", "tail": "RDF数据的存储功能", "tail_type": "概念"}, {"head": "RDF4J", "head_type": "产品", "relation": "实现", "tail": "RDF数据的推理功能", "tail_type": "概念"}, {"head": "RDF4J", "head_type": "产品", "relation": "实现", "tail": "RDF数据的查询功能", "tail_type": "概念"}]}
{"text": "RDF4J提供内存和磁盘两种RDF存储机制，支持SPARQL1.1查询和更新语言。", "relation": [{"head": "RDF4J", "head_type": "产品", "relation": "实现", "tail": "内存RDF存储机制", "tail_type": "概念"}, {"head": "RDF4J", "head_type": "产品", "relation": "实现", "tail": "磁盘RDF存储机制", "tail_type": "概念"}]}
{"text": "gStore是由北京大学开发的基于图的RDF三元组数据库。", "relation": [{"head": "gStore", "head_type": "产品", "relation": "属于", "tail": "RDF三元组数据库", "tail_type": "概念"}]}
{"text": "AllegroGraph是Franz公司开发的RDF三元组数据库。", "relation": [{"head": "AllegroGraph", "head_type": "产品", "relation": "属于", "tail": "RDF三元组数据库", "tail_type": "概念"}]}
{"text": "GraphDB是由Ontotext软件公司开发的RDF三元组数据库。", "relation": [{"head": "GraphDB", "head_type": "产品", "relation": "属于", "tail": "RDF三元组数据库", "tail_type": "概念"}]}
{"text": "3.4.2面向RDF的三元组数据库gStore1.开源工具简介gStore是由北京大学计算机科学技术研究所数据管理实验室自2011年开始研发的面向RDF知识图谱的开源图数据库系统，遵循Apache开源协议。", "relation": [{"head": "gStore", "head_type": "产品", "relation": "属于", "tail": "图数据库系统", "tail_type": "概念"}]}
{"text": "不同于传统基于关系数据库的RDF数据管理方法，gStore原生基于图数据模型，在存储RDF数据时维持并根据其图结构构建了基于二进制位图索引的新型索引结构——VS树。", "relation": [{"head": "gStore", "head_type": "产品", "relation": "依靠", "tail": "图数据模型", "tail_type": "概念"}]}
{"text": "与传统互联网中的文档检索不同，语义搜索需要处理粒度更细的结构化语义数据，因此也面临着前所未有的挑战[4]。", "relation": [{"head": "语义搜索", "head_type": "概念", "relation": "依靠", "tail": "处理粒度更细的结构化语义数据", "tail_type": "概念"}]}
{"text": "以SPARQL查询为代表的结构化查询语言的出现，为支持知识图谱的语义搜索提供了基础。", "relation": [{"head": "SPARQL查询", "head_type": "概念", "relation": "实现", "tail": "提供基础给代表的结构化查询语言的出现", "tail_type": "概念"}]}
{"text": "其中，最广泛的信息检索主要是面向文档为单位的检索（Document_Retrieval）。", "relation": [{"head": "最广泛的信息检索", "head_type": "概念", "relation": "等价", "tail": "面向文档为单位的检索", "tail_type": "概念"}]}
{"text": "语义关注的是能用于搜索的资源的含义。", "relation": [{"head": "语义", "head_type": "概念", "relation": "研究", "tail": "能用于搜索的资源的含义", "tail_type": "概念"}]}
{"text": "其中，语言学模型主要侧重对词语级别的关系建模、分类以及构建同义词库，而概念模型主要侧重对论域中的语法元素的关系建模，以及从语法元素到论域的映射。", "relation": [{"head": "语言学模型", "head_type": "概念", "relation": "研究", "tail": "对词语级别的关系建模、分类以及构建同义词库", "tail_type": "概念"}, {"head": "概念模型", "head_type": "", "relation": "研究", "tail": "对论域中的语法元素的关系建模", "tail_type": "概念"}, {"head": "概念模型", "head_type": "概念", "relation": "研究", "tail": "从语法元素到论域的映射", "tail_type": "概念"}]}
{"text": "通过在检索过程中结合使用这些表达能力更强的类型数据，纯粹面向文档的检索系统已经包含了一定程度的语义使用，已经变成了轻量级的语义搜索系统。", "relation": [{"head": "纯粹面向文档的检索系统", "head_type": "概念", "relation": "等价", "tail": "轻量级的语义搜索系统", "tail_type": "概念"}]}
{"text": "目前，大量的语义网络搜索系统已经被构建，其目的是利用互联网上大量的RDF数据及表达Web上可用的OWL本体。", "relation": [{"head": "语义网络搜索系统", "head_type": "概念", "relation": "研究", "tail": "利用互联网上大量的RDF数据及表达Web上可用的OWL本体", "tail_type": "概念"}]}
{"text": "目前，最先进的语义搜索系统结合了一系列技术，包括结构化查询语言的构建、基于统计的信息检索排序方法、有效索引和查询处理的数据库方法以及复杂推理等技术。", "relation": [{"head": "语义搜索系统", "head_type": "概念", "relation": "依靠", "tail": "结构化查询语言的构建", "tail_type": "概念"}, {"head": "语义搜索系统", "head_type": "概念", "relation": "依靠", "tail": "基于统计的信息检索排序方法", "tail_type": "概念"}, {"head": "语义搜索系统", "head_type": "概念", "relation": "依靠", "tail": "有效索引和查询处理的数据库方法", "tail_type": "概念"}, {"head": "语义搜索系统", "head_type": "概念", "relation": "依靠", "tail": "复杂推理", "tail_type": "概念"}]}
{"text": "多个RDF三元组组成的集合构成了RDF数据集。", "relation": [{"head": "RDF三元组", "head_type": "概念", "relation": "属于", "tail": "RDF数据集", "tail_type": "概念"}]}
{"text": "目前，RDF已经成为知识图谱的主要描述格式，越来越多的知识图谱数据以RDF三元组的形式发布出来。", "relation": [{"head": "RDF", "head_type": "概念", "relation": "等价", "tail": "知识图谱的主要描述格式", "tail_type": "概念"}]}
{"text": "精确查询并获取知识图谱中三元组中的有关信息是语义搜索的核心。", "relation": [{"head": "精确查询", "head_type": "概念", "relation": "等价", "tail": "语义搜索的核心", "tail_type": "概念"}]}
{"text": "SPARQL查询语言是面向RDF图的结构化查询语言，目前已被W3C推荐为RDF数据的标准查询语言[2]，其地位和查询形式都类似于关系数据库的SQL语言。", "relation": [{"head": "SPARQL查询语言", "head_type": "概念", "relation": "等价", "tail": "面向RDF图的结构化查询语言", "tail_type": "概念"}, {"head": "SPARQL查询语言", "head_type": "概念", "relation": "等价", "tail": "RDF数据的标准查询语言", "tail_type": "概念"}]}
{"text": "SPARQL查询的核心处理单元是类似RDF三元组形式的三元组模式（TriplePattern），不同之处在于SPARQL的三元组模式中，主语、谓语或宾语可以是变量（以“?”开头标识）。", "relation": [{"head": "SPARQL查询的核心处理单元", "head_type": "概念", "relation": "等价", "tail": "类似RDF三元组形式的三元组模式（TriplePattern）", "tail_type": "概念"}, {"head": "SPARQL的三元组模式中的主语、谓语或宾语", "head_type": "概念", "relation": "等价", "tail": "变量", "tail_type": "概念"}, {"head": "三元组模式", "head_type": "概念", "relation": "英文名", "tail": "TriplePattern", "tail_type": "概念"}]}
{"text": "其中，SELECT是唯一可以返回知识图谱中图模式匹配具体结果给用户的形式，也是最常用的查询语句；ASK查询语句主要用于测试知识图谱中是否存在满足给定查询约束条件的数据，结果以Yes或No的形式返回，除此之外没有额外的信息返回；CONSTRUCT查询语句主要用于将图模式匹配结果生成新的RDF图；DESCRIBE查询语句用于查询与指定IRI相关的数据，注意和SELECT有区别。", "relation": [{"head": "SELECT", "head_type": "概念", "relation": "等价", "tail": "唯一可以返回知识图谱中图模式匹配具体结果给用户的形式", "tail_type": "概念"}, {"head": "SELECT", "head_type": "概念", "relation": "等价", "tail": "最常用的查询语句", "tail_type": "概念"}, {"head": "ASK查询语句", "head_type": "概念", "relation": "研究", "tail": "测试知识图谱中是否存在满足给定查询约束条件的数据", "tail_type": "概念"}, {"head": "CONSTRUCT查询语句", "head_type": "概念", "relation": "实现", "tail": "将图模式匹配结果生成新的RDF图", "tail_type": "概念"}, {"head": "DESCRIBE查询语句", "head_type": "概念", "relation": "实现", "tail": "查询与指定IRI相关的数据", "tail_type": "概念"}]}
{"text": "原生存储（Native_Stores）即直接以RDF图形式的存储方式。", "relation": [{"head": "原生存储", "head_type": "概念", "relation": "等价", "tail": "直接以RDF图形式的存储方式", "tail_type": "概念"}]}
{"text": "数据Web的查询及答案在通常情况下都涉及多个数据源，如图7-8所示。", "relation": [{"head": "数据Web的查询及答案", "head_type": "概念", "relation": "依靠", "tail": "多个数据源", "tail_type": "概念"}]}
{"text": "Hermes系统[13]就是一个典型的多数据源语义数据搜索框架，如图7-9所示，包括数据源融合，用户意图理解以及搜索和优化。", "relation": [{"head": "Hermes系统", "head_type": "产品", "relation": "等价", "tail": "一个典型的多数据源语义数据搜索框架", "tail_type": "概念"}, {"head": "Hermes系统", "head_type": "产品", "relation": "包含", "tail": "数据源融合、用户意图理解以及搜索和优化", "tail_type": "概念"}]}
{"text": "此类常见的交互范式主要包括：关键词查询、自然语言查询、分面查询、表单查询、可视化查询以及混合方式查询等[15]。", "relation": [{"head": "交互范式", "head_type": "概念", "relation": "包含", "tail": "关键词查询", "tail_type": "概念"}, {"head": "交互范式", "head_type": "概念", "relation": "包含", "tail": "自然语言查询", "tail_type": "概念"}, {"head": "交互范式", "head_type": "概念", "relation": "包含", "tail": "分面查询", "tail_type": "概念"}, {"head": "交互范式", "head_type": "概念", "relation": "包含", "tail": "表单查询", "tail_type": "概念"}, {"head": "交互范式", "head_type": "概念", "relation": "包含", "tail": "可视化查询", "tail_type": "概念"}, {"head": "交互范式", "head_type": "概念", "relation": "包含", "tail": "混合方式查询等", "tail_type": "概念"}]}
{"text": "知识图谱上的关键词查询主要可以分为两类[17]：基于关键词直接在知识图谱上搜索答案；基于关键词生成结构化的查询，进而提交给查询引擎得到结果。", "relation": [{"head": "关键词查询", "head_type": "概念", "relation": "包含", "tail": "基于关键词直接在知识图谱上搜索答案", "tail_type": "概念"}, {"head": "关键词查询", "head_type": "概念", "relation": "包含", "tail": "基于关键词生成结构化的查询", "tail_type": "概念"}]}
{"text": "基于关键词直接在知识图谱上搜索答案主要可以解决简单的语义搜索，即查询答案仅仅出现在单条知识图谱三元组中，对于复杂的语义查询往往无法适用。", "relation": [{"head": "基于关键词直接在知识图谱上搜索答案", "head_type": "概念", "relation": "实现", "tail": "解决简单的语义搜索", "tail_type": "概念"}]}
{"text": "进行映射的主要原因是用户输入的关键词和知识图谱上的实体关系往往存在语义鸿沟，例如，关键词“妻子”在知识图谱可能对应的是“配偶”。", "relation": [{"head": "映射", "head_type": "概念", "relation": "源于", "tail": "用户输入的关键词和知识图谱上的实体关系往往存在语义鸿沟", "tail_type": "概念"}]}
{"text": "典型的定义将分面描述为属性或一组分类体系（category），或将分面定义为某个主题的维度或侧面。", "relation": [{"head": "分面", "head_type": "概念", "relation": "被定义为", "tail": "属性或一组分类体系（category）", "tail_type": "概念"}, {"head": "分面", "head_type": "概念", "relation": "被定义为", "tail": "某个主题的维度或侧面", "tail_type": "概念"}]}
{"text": "此外，每一个当前浏览的知识图谱实体可能有大量分面，还需要对分面进行排序和分面隐藏。", "relation": [{"head": "分面", "head_type": "概念", "relation": "依靠", "tail": "排序和分面隐藏", "tail_type": "概念"}]}
{"text": "知识图谱表示学习旨在通过机器学习技术，将知识图谱中的实体和关系投射到连续低维的向量空间中，同时保持原有知识图谱的基本结构和性质[20]。", "relation": [{"head": "知识图谱表示学习", "head_type": "概念", "relation": "研究", "tail": "通过机器学习技术，将知识图谱中的实体和关系投射到连续低维的向量空间中，同时保持原有知识图谱的基本结构和性质[20]", "tail_type": "概念"}]}
{"text": "在知识图谱表示学习技术出现之前，通常以图数据库的形式组织和存储知识图谱。", "relation": [{"head": "知识图谱组织", "head_type": "概念", "relation": "依靠", "tail": "图数据库的形式", "tail_type": "概念"}, {"head": "以储知识图谱", "head_type": "概念", "relation": "依靠", "tail": "图数据库的形式存", "tail_type": "概念"}]}
{"text": "知识图谱的向量空间可以帮助模型省略消歧的过程，方法是将每一个候选实体集合中的实体平均实值向量作为查询图生成时的实体表示，进而并不需要某一个具体的实体向量。", "relation": [{"head": "知识图谱的向量空间", "head_type": "概念", "relation": "实现", "tail": "模型省略消歧的过程", "tail_type": "概念"}]}
{"text": "该搜索引擎可以按照名称搜索实体、实体属性、多跳搜索以及搜索符合多对属性要求的实体。", "relation": [{"head": "搜索引擎搜索实体", "head_type": "概念", "relation": "依靠", "tail": "名称搜索", "tail_type": "概念"}, {"head": "搜索引擎搜索实体", "head_type": "概念", "relation": "依靠", "tail": "实体属性搜索", "tail_type": "概念"}, {"head": "搜索引擎搜索实体", "head_type": "概念", "relation": "依靠", "tail": "多跳搜索", "tail_type": "概念"}, {"head": "搜索引擎搜索实体", "head_type": "概念", "relation": "依靠", "tail": "搜索符合多对属性要求的实体", "tail_type": "概念"}]}
{"text": "表示学习技术可以让语义检索绕过对查询本身的修改拓展，直接得到近似结果，在提高效率和精度的同时又带来结果的可解释问题。", "relation": [{"head": "表示学习技术", "head_type": "概念", "relation": "实现", "tail": "语义检索绕过对查询本身的修改拓展,直接得到近似结果", "tail_type": "概念"}, {"head": "表示学习技术", "head_type": "概念", "relation": "实现", "tail": "提高效率和精度", "tail_type": "概念"}]}
{"text": "该数据集由三元组组成，每个三元组描述一个人物实体的某个属性。", "relation": [{"head": "数据集", "head_type": "概念", "relation": "包含", "tail": "三元组", "tail_type": "概念"}, {"head": "三元组", "head_type": "概念", "relation": "研究", "tail": "人物实体的某个属性", "tail_type": "概念"}]}
{"text": "Elasticsearch使用RESTful_API可以方便地交互，通过Elasticsearch的mapping文件可以创建index和type，并指定每个字段在Elasticsearch中存储的类型。", "relation": [{"head": "Elasticsearch", "head_type": "产品", "relation": "依靠", "tail": "RESTful_API", "tail_type": "产品"}, {"head": "Elasticsearch的mapping文件", "head_type": "概念", "relation": "实现", "tail": "创建index和type", "tail_type": "概念"}, {"head": "mapping文件", "head_type": "概念", "relation": "实现", "tail": "指定每个字段在Elasticsearch中存储的类型", "tail_type": "概念"}]}
{"text": "注意：Elasticsearch的查询除了常见的get请求方式，即将参数和参数值作为链接的一部分提交，也支持如上所示将查询参数写入一个JSON结构体，用该请求体查询的方式。", "relation": [{"head": "Elasticsearch的查询", "head_type": "概念", "relation": "实现", "tail": "支持将查询参数写入一个JSON结构体", "tail_type": "概念"}]}
{"text": "第6章知识图谱推理漆桂林东南大学，肖国辉博尔扎诺自由大学，陈华钧浙江大学知识图谱推理在一个知识图谱的发展演变过程中起着重要的作用，知识图谱推理能用来对知识图谱进行补全和质量检测等。", "relation": [{"head": "知识图谱推理", "head_type": "概念", "relation": "实现", "tail": "对知识图谱进行补全和质量检测", "tail_type": "概念"}]}
{"text": "推理的方法大致可以分为逻辑推理和非逻辑推理，其中逻辑推理的过程包含了严格的约束和推理过程，而非逻辑推理的过程相对模糊。", "relation": [{"head": "推理", "head_type": "概念", "relation": "包含", "tail": "逻辑推理", "tail_type": "概念"}, {"head": "推理", "head_type": "概念", "relation": "包含", "tail": "非逻辑推理", "tail_type": "概念"}, {"head": "逻辑推理", "head_type": "概念", "relation": "包含", "tail": "推理过程", "tail_type": "概念"}, {"head": "逻辑推理", "head_type": "概念", "relation": "包含", "tail": "严格的约束", "tail_type": "概念"}]}
{"text": "逻辑推理按照推理方式的不同包含两大类：演绎推理（Deductive_Reasoning）和归纳推理（Inductive_Reasoning）。", "relation": [{"head": "逻辑推理", "head_type": "概念", "relation": "包含", "tail": "归纳推理", "tail_type": "概念"}, {"head": "逻辑推理", "head_type": "概念", "relation": "包含", "tail": "演绎推理", "tail_type": "概念"}, {"head": "演绎推理", "head_type": "概念", "relation": "英文名", "tail": "Deductive_Reasoning", "tail_type": "概念"}, {"head": "归纳推理", "head_type": "概念", "relation": "英文名", "tail": "Inductive_Reasoning", "tail_type": "概念"}]}
{"text": "演绎推理[1]是一种自上而下（top-down_logic）的逻辑推理，是指在给定的一个或多个前提的情况下，推断出一个必然成立的结论的过程。", "relation": [{"head": "演绎推理", "head_type": "概念", "relation": "被定义为", "tail": "一种自上而下的逻辑推理", "tail_type": "概念"}, {"head": "演绎推理", "head_type": "概念", "relation": "被定义为", "tail": "在给定的一个或多个前提的情况下，推断出一个必然成立的结论的过程", "tail_type": "概念"}, {"head": "自上而下", "head_type": "概念", "relation": "英文名", "tail": "top-down_logic", "tail_type": "概念"}]}
{"text": "典型的演绎推理有肯定前件假言推理、否定后件假言推理（Modus_Tollens）以及三段论（Law_of_Syllogism）。", "relation": [{"head": "典型的演绎推理", "head_type": "概念", "relation": "包含", "tail": "肯定前件假言推理", "tail_type": "概念"}, {"head": "典型的演绎推理", "head_type": "概念", "relation": "包含", "tail": "否定后件假言推理", "tail_type": "概念"}, {"head": "典型的演绎推理", "head_type": "概念", "relation": "包含", "tail": "三段论", "tail_type": "概念"}, {"head": "否定后件假言推理", "head_type": "概念", "relation": "英文名", "tail": "Modus_Tollens", "tail_type": "概念"}, {"head": "三段论", "head_type": "概念", "relation": "英文名", "tail": "Law_of_Syllogism", "tail_type": "概念"}]}
{"text": "其中，肯定前件假言推理是指性质命题肯定了假言命题的前件，从而推理出肯定的假言后件。", "relation": [{"head": "肯定前件假言推理", "head_type": "概念", "relation": "被定义为", "tail": "性质命题肯定了假言命题的前件从而推理出肯定的假言后件", "tail_type": "概念"}]}
{"text": "而否定后件假言推理是指性质命题否定了假言命题的后件，从而推理出否定的假言前件。", "relation": [{"head": "否定后件假言推理", "head_type": "概念", "relation": "被定义为", "tail": "性质命题否定了假言命题的后件从而推理出否定的假言前件", "tail_type": "概念"}]}
{"text": "从以上的例子可以看出，演绎推理是一种形式化的逻辑推理。", "relation": [{"head": "演绎推理", "head_type": "概念", "relation": "被定义为", "tail": "一种形式化的逻辑推理", "tail_type": "概念"}]}
{"text": "归纳推理[2]是一种自下而上的推理，是指基于已有的部分观察得出一般结论的过程。", "relation": [{"head": "归纳推理", "head_type": "概念", "relation": "被定义为", "tail": "一种自下而上的推理", "tail_type": "概念"}, {"head": "归纳推理", "head_type": "", "relation": "被定义为", "tail": "基于已有的部分观察得出一般结论的过程", "tail_type": "概念"}]}
{"text": "典型的归纳推理有归纳泛化（Inductive_Generalization）、统计推理（Statistical_Syllogism）。","relation": [{"head": "典型的归纳推理", "head_type": "概念", "relation": "包含", "tail": "归纳泛化（Inductive_Generalization）", "tail_type": "概念"},{"head": "典型的归纳推理", "head_type": "概念", "relation": "包含", "tail": "统计推理（Statistical_Syllogism）", "tail_type": "概念"}, {"head": "归纳泛化", "head_type": "概念", "relation": "英文名", "tail": "Inductive_Generalization", "tail_type": "概念"}, {"head": "统计推理", "head_type": "概念", "relation": "英文名", "tail": "Statistical_Syllogism", "tail_type": "概念"}]}
{"text": "归纳泛化是指基于对个体的观察而得出可能适用于整体的结论，即在整体的一些样本中得到的结论可以泛化到整体上。", "relation": [{"head": "归纳泛化", "head_type": "概念", "relation": "被定义为", "tail": "基于对个体的观察而得出可能适用于整体的结论", "tail_type": "概念"}]}
{"text": "而统计推理是将整体的统计结论应用于个体。", "relation": [{"head": "统计推理", "head_type": "概念", "relation": "被定义为", "tail": "将整体的统计结论应用于个体", "tail_type": "概念"}]}
{"text": "归纳推理是一种非形式化的推理，是由具体到一般的推理过程。", "relation": [{"head": "归纳推理", "head_type": "概念", "relation": "被定义为", "tail": "非形式化的推理", "tail_type": "概念"}, {"head": "归纳推理", "head_type": "概念", "relation": "被定义为", "tail": "具体到一般的推理过程", "tail_type": "概念"}]}
{"text": "溯因推理[3]也是一种逻辑推理，是在给定一个或多个已有观察事实O（Observation），并根据已有的知识T（Theory）推断出对已有观察最简单且最有可能的解释的过程。", "relation": [{"head": "溯因推理", "head_type": "概念", "relation": "属于", "tail": "逻辑推理", "tail_type": "概念"},{"head": "溯因推理", "head_type": "概念", "relation": "被定义为", "tail": "在给定一个或多个已有观察事实O（Observation），并根据已有的知识T（Theory）推断出对已有观察最简单且最有可能的解释的过程。", "tail_type": "概念"}]}
{"text": "溯因推理是归纳推理的一种，因为整个推理过程的前提和结论并没有必然的关系。", "relation": [{"head": "溯因推理", "head_type": "概念", "relation": "属于", "tail": "归纳推理", "tail_type": "概念"}]}
{"text": "由于现实世界的知识千千万万，想要涵盖所有的知识是很难的，所以知识图谱的不完整性很明显，在对知识图谱进行补全的过程中，链接预测是一种典型的推理任务[8]。", "relation": [{"head": "链接预测", "head_type": "概念", "relation": "属于", "tail": "典型的推理任务", "tail_type": "概念"}]}
{"text": "本体的一般定义为概念化的显示规约，它给不同的领域提供共享的词汇。", "relation": [{"head": "本体", "head_type": "概念", "relation": "被定义为定义为", "tail": "概念化的显示规约", "tail_type": "概念"}]}
{"text": "OWL按表达能力从低到高划分成OWL_Lite、OWL_DL和OWL_Full。", "relation": [{"head": "OWL", "head_type": "概念", "relation": "包含", "tail": "OWL_Lite", "tail_type": "概念"}, {"head": "OWL", "head_type": "概念", "relation": "包含", "tail": "OWL_DL", "tail_type": "概念"}, {"head": "OWL", "head_type": "概念", "relation": "包含", "tail": "OWL_Full", "tail_type": "概念"}]}
{"text": "OWL_Lite和OWL_DL在语义上等价于某些描述逻辑（Description_Logics,DLs）[14,15]，而OWL_Full没有对应的描述逻辑。", "relation": [{"head": "OWL_Lite", "head_type": "概念", "relation": "等价", "tail": "某些描述逻辑", "tail_type": "概念"}, {"head": "OWL_DL", "head_type": "概念", "relation": "等价", "tail": "某些描述逻辑", "tail_type": "概念"}, {"head": "描述逻辑", "head_type": "概念", "relation": "英文名", "tail": "Description_Logics,DLs", "tail_type": "概念"}]}
{"text": "目前，OWL是知识图谱语言中最规范、最严谨、表达能力最强的语言，而且OWL基于RDF语法，使表示出来的文档具有语义理解的结构基础，OWL的另外一个作用是促进了统一词汇表的使用，定义了丰富的语义词汇。", "relation": [{"head": "OWL", "head_type": "概念", "relation": "等价", "tail": "知识图谱语言中最规范、最严谨、表达能力最强的语言", "tail_type": "概念"}, {"head": "OWL", "head_type": "概念", "relation": "依靠", "tail": "RDF语法", "tail_type": "概念"}, {"head": "OWL", "head_type": "概念", "relation": "实现", "tail": "统一词汇表的使用", "tail_type": "概念"}, {"head": "OWL", "head_type": "概念", "relation": "实现", "tail": "丰富的语义词汇", "tail_type": "概念"}]}
{"text": "FaCT++是曼彻斯特大学开发的描述逻辑推理机，使用C++实现，且能与Protégé集成。", "relation": [{"head": "FaCT++", "head_type": "产品", "relation": "属于", "tail": "描述逻辑推理机", "tail_type": "概念"}, {"head": "FaCT++", "head_type": "产品", "relation": "依靠", "tail": "C++实现", "tail_type": "概念"}]}
{"text": "Prolog在早期的人工智能研究中应用广泛，多用于实现专家系统。", "relation": [{"head": "Prolog", "head_type": "产品", "relation": "实现", "tail": "专家系统", "tail_type": "概念"}]}
{"text": "在通常情况下，Prolog程序是通过SLD消解和回溯来执行的[25]。", "relation": [{"head": "Prolog程序", "head_type": "产品", "relation": "依靠", "tail": "SLD消解和回溯", "tail_type": "概念"}]}
{"text": "运行结果依赖对规则内部的原子顺序和规则之间的顺序，因此不是完全的声明式的（declarative）。", "relation": [{"head": "运行结果", "head_type": "概念", "relation": "依靠", "tail": "规则内部的原子顺序和规则之间的顺序", "tail_type": "概念"}]}
{"text": "从语法上来说，Datalog程序基本上是Prolog的一个子集。", "relation": [{"head": "Datalog程序", "head_type": "产品", "relation": "属于", "tail": "Prolog的一个子集", "tail_type": "概念"}]}
{"text": "它们的主要区别是在语义层面，Datalog基于完全声明式的模型论的语义，并保证可终止性。", "relation": [{"head": "Datalog", "head_type": "产品", "relation": "依靠", "tail": "完全声明式的模型论的语义", "tail_type": "概念"}, {"head": "Datalog", "head_type": "产品", "relation": "实现", "tail": "可终止性", "tail_type": "概念"}]}
{"text": "OWL_RL的设计目标之一就是找出可以用规则推理来实现的一个OWL的片段。", "relation": [{"head": "OWL_RL", "head_type": "概念", "relation": "研究", "tail": "找出可以用规则推理来实现的一个OWL的片段", "tail_type": "概念"}]}
{"text": "变量用大写字母X、Y、Z表示，有时也会用问号（?）开头，例如?x、?y。", "relation": [{"head": "变量", "head_type": "概念", "relation": "依靠", "tail": "大写字母X、Y、Z表示", "tail_type": "概念"}]}
{"text": "Datalog事实（fact）是形如F(c1,c2,…,cn):-的没有体部且没有变量的规则。", "relation": [{"head": "Datalog事实（fact）", "head_type": "概念", "relation": "被定义为", "tail": "形如F(c1,c2,…,cn):-的没有体部且没有变量的规则", "tail_type": "概念"}]}
{"text": "一个知识图谱可以自然地被看作一个事实集。", "relation": [{"head": "知识图谱", "head_type": "概念", "relation": "属于", "tail": "一个事实集", "tail_type": "概念"}]}
{"text": "SWRL是2004年提出的一个完全基于Datalog的规则语言。", "relation": [{"head": "SWRL", "head_type": "概念", "relation": "等价", "tail": "2004年提出的一个完全基于Datalog的规则语言", "tail_type": "概念"}]}
{"text": "OWL_RL是W3C定义的OWL_2的一个子语言，其设计目标为可以直接转换成Datalog程序，从而使用现有的Datalog推理机推理。", "relation": [{"head": "OWL_RL", "head_type": "概念", "relation": "属于", "tail": "W3C定义的OWL_2的一个子语言", "tail_type": "概念"}, {"head": "设计目标", "head_type": "概念", "relation": "实现", "tail": "直接转换成Datalog程序", "tail_type": "概念"}]}
{"text": "RDFox的输入包括本体（TBox）、数据（ABox）和一个自定义规则集。", "relation": [{"head": "RDFox的输入", "head_type": "概念", "relation": "包含", "tail": "本体（TBox）]", "tail_type": "概念"}, {"head": "RDFox的输入", "head_type": "概念", "relation": "包含", "tail": "数据（ABox）", "tail_type": "概念"}, {"head": "RDFox的输入", "head_type": "概念", "relation": "包含", "tail": "一个自定义规则集", "tail_type": "概念"}, {"head": "本体", "head_type": "概念", "relation": "英文名", "tail": "TBox", "tail_type": "概念"}, {"head": "数据", "head_type": "概念", "relation": "英文名", "tail": "ABox", "tail_type": "概念"}]}
{"text": "第一种情况直接在知识图谱之上的查询称为本体介导的查询回答（Ontology-Mediated_Query_Answering,OMQ）[27]。", "relation": [{"head": "直接在知识图谱之上的查询", "head_type": "概念", "relation": "被定义为", "tail": "本体介导的查询回答", "tail_type": ""}, {"head": "本体介导的查询回答", "head_type": "概念", "relation": "英文名", "tail": "Ontology-Mediated_Query_Answering,OMQ", "tail_type": "概念"}]}
{"text": "1.OBDA框架包含外延（extensional）和内涵（intensional）两个部分。", "relation": [{"head": "OBDA框架", "head_type": "概念", "relation": "包含", "tail": "外延（extensional）和内涵（intensional）两个部分", "tail_type": "概念"}, {"head": "外延", "head_type": "概念", "relation": "英文名", "tail": "extensional", "tail_type": "概念"}, {"head": "内涵", "head_type": "概念", "relation": "英文名", "tail": "intensional", "tail_type": "概念"}]}
{"text": "外延层为符合某个数据库架构（schema）S的一个源数据库D，S通常包括数据库表的定义和完整性约束。", "relation": [{"head": "外延层", "head_type": "概念", "relation": "等价", "tail": "符合某个数据库架构（schema）S的一个源数据库D", "tail_type": "概念"}, {"head": "S", "head_type": "概念", "relation": "包含", "tail": "数据库表的定义", "tail_type": "概念"}, {"head": "S", "head_type": "概念", "relation": "包含", "tail": "完整性约束", "tail_type": "概念"}]}
{"text": "OBDA的主要推理任务为查询", "relation": [{"head": "OBDA的主要推理任务", "head_type": "概念", "relation": "研究", "tail": "查询", "tail_type": "概念"}]}
{"text": "OBDA有多种实现方式，最直接的方式是生成映射得到的知识图谱M(D)，然后保存到一个三元组存储库中，这种方式也称作ETL（Extract_Transform_Load)，优点是实现简单直接。", "relation": [{"head": "OBDA实现方式", "head_type": "概念", "relation": "等价", "tail": "生成映射得到的知识图谱M(D)", "tail_type": "概念"}]}
{"text": "Mastro最初是由意大利罗马大学开发的OBDA系统，现在由OBDA_Systems商业化运行。", "relation": [{"head": "Mastro", "head_type": "产品", "relation": "源于", "tail": "意大利罗马大学", "tail_type": "概念"}, {"head": "Mastro", "head_type": "产品", "relation": "属于", "tail": "OBDA系统", "tail_type": "概念"}]}
{"text": "Stardog原本是由Stardog_Union开发的商业化的Triple存储工具。", "relation": [{"head": "Stardog", "head_type": "产品", "relation": "属于", "tail": "商业化的Triple存储工具", "tail_type": "概念"}]}
{"text": "一个产生式系统由事实集合、产生式集合和推理引擎三部分组成。", "relation": [{"head": "产生式系统", "head_type": "概念", "relation": "包含", "tail": "事实集合", "tail_type": "概念"},{"head": "产生式系统", "head_type": "概念", "relation": "包含", "tail": "产生式集合", "tail_type": "概念"},{"head": "产生式系统", "head_type": "概念", "relation": "包含", "tail": "推理引擎", "tail_type": "概念"}]}
{"text": "事实集合是运行内存（Working_Memory,WM）为事实（WME）的集合，用于存储当前系统中的所有事实。", "relation": [{"head": "事实集合", "head_type": "概念", "relation": "等价", "tail": "运行内存（Working_Memory,WM）为事实（WME）的集合", "tail_type": "概念"}, {"head": "事实集合", "head_type": "概念", "relation": "实现", "tail": "存储当前系统中的所有事实", "tail_type": "概念"}]}
{"text": "推理引擎用于控制系统的执行。", "relation": [{"head": "推理引擎", "head_type": "概念", "relation": "实现", "tail": "控制系统的执行", "tail_type": "概念"}]}
{"text": "目前，最流行的算法是Rete算法，在1979年由Charles_Forgy提出[42]。", "relation": [{"head": "Rete算法", "head_type": "概念", "relation": "属于", "tail": "最流行的算法", "tail_type": "概念"}, {"head": "Charles_Forgy", "head_type": "概念", "relation": "研究", "tail": "Rete算法", "tail_type": "概念"}]}
{"text": "Jena是一个用于构建语义网应用的Java框架。", "relation": [{"head": "Jena", "head_type": "产品", "relation": "属于", "tail": "Java框架", "tail_type": "概念"}, {"head": "Jena", "head_type": "概念", "relation": "实现", "tail": "语义网应用", "tail_type": "概念"}]}
{"text": "按照推理要素的不同，基于归纳的知识图谱推理可以分为以下几类：基于图结构的推理、基于规则学习的推理和基于表示学习的推理。", "relation": [{"head": "基于图结构的推理", "head_type": "概念", "relation": "属于", "tail": "基于归纳的知识图谱推理", "tail_type": "概念"}, {"head": "基于规则学习的推理", "head_type": "概念", "relation": "属于", "tail": "基于归纳的知识图谱推理", "tail_type": "概念"}, {"head": "基于表示学习的推理", "head_type": "概念", "relation": "属于", "tail": "基于归纳的知识图谱推理", "tail_type": "概念"}]}
{"text": "这说明了路径是一种重要的进行关系推理的信息，也是一种重要的图结构。", "relation": [{"head": "路径", "head_type": "概念", "relation": "等价", "tail": "一种重要的进行关系推理的信息", "tail_type": "概念"}, {"head": "路径", "head_type": "概念", "relation": "属于", "tail": "重要的图结构", "tail_type": "概念"}]}
{"text": "结合了有效采样和随机有走的PRA能够快速有效地利用知识图谱的路径结构对知识图谱进行关系推理，是典型的基于图结构的知识图谱推理算法。", "relation": [{"head": "PRA", "head_type": "概念", "relation": "依靠", "tail": "有效采样和随机有走", "tail_type": "概念"}, {"head": "PRA", "head_type": "概念", "relation": "实现", "tail": "快速有效地利用知识图谱的路径结构对知识图谱进行关系推理", "tail_type": "概念"}, {"head": "PRA", "head_type": "概念", "relation": "属于", "tail": "典型的基于图结构的知识图谱推理算法", "tail_type": "概念"}]}
{"text": "尽管采用了随机游走策略来降低搜索空间，当PRA应用在关系丰富且连接稠密的知识图谱上时，依然会面临路径特征爆炸的问题。", "relation": [{"head": "PRA", "head_type": "概念", "relation": "研究", "tail": "路径特征爆炸的问题", "tail_type": "概念"}]}
{"text": "SFE同时还利用了关系的向量表示，通过训练好的关系的表示，将已有路径特征中的关系替换为向量空间中比较相似的关系。", "relation": [{"head": "SFE", "head_type": "概念", "relation": "依靠", "tail": "关系的向量表示", "tail_type": "概念"}]}
{"text": "SFE还增加了一个表示任意关系的关系ANYREL来增加路径特征的丰富性。", "relation": [{"head": "SFE", "head_type": "概念", "relation": "实现", "tail": "增加表示任意关系的关系ANYREL", "tail_type": "概念"}]}
{"text": "规则是基于规则推理的核心，所以规则获取是一个重要的任务。", "relation": [{"head": "规则", "head_type": "概念", "relation": "等价", "tail": "基于规则推理的核心", "tail_type": "概念"}, {"head": "规则获取", "head_type": "概念", "relation": "等价", "tail": "一个重要的任务", "tail_type": "概念"}]}
{"text": "所以，自动化的规则学习方法应运而生，旨在快速有效地从大规模知识图谱上学习置信度较高的规则，并服务于关系推理任务。", "relation": [{"head": "自动化的规则学习方法", "head_type": "概念", "relation": "实现", "tail": "快速有效地从大规模知识图谱上学习置信度较高的规则", "tail_type": "概念"}, {"head": "自动化的规则学习方法", "head_type": "概念", "relation": "实现", "tail": "关系推理任务", "tail_type": "概念"}]}
{"text": "其中，规则头由一个二元的原子（atom）构成，而规则主体由一个或多个一元原子或二元原子组成。", "relation": [{"head": "一个二元的原子（atom）", "head_type": "概念", "relation": "属于", "tail": "规则头", "tail_type": "概念"}, {"head": "一个或多个一元原子或二元原子", "head_type": "概念", "relation": "属于", "tail": "规则主体", "tail_type": "概念"}]}
{"text": "规则一般包含了两个部分，分别为规则头（head）和规则主体（body），其一般形式为rule:head←body.解读为有规则主体的信息可推出规则头的信息。", "relation": [{"head": "规则", "head_type": "概念", "relation": "包含", "tail": "规则头（head）", "tail_type": "概念"},{"head": "规则", "head_type": "概念", "relation": "包含", "tail": "规则主体（body）", "tail_type": "概念"}, {"head": "规则", "head_type": "概念", "relation": "被定义为", "tail": "rule:head←body", "tail_type": "概念"}, {"head": "规则头", "head_type": "概念", "relation": "英文名", "tail": "head", "tail_type": "概念"}, {"head": "规则主体", "head_type": "概念", "relation": "英文名", "tail": "body", "tail_type": "概念"}]}
{"text": "原子（atom）是指包含了变量的元组，例如isLocation(X)是一个一元原子表示实体变量X是一个位置实体；hasWife(X,Y)是一个二元原子，表示实体变量X的妻子是实体变量Y。", "relation": [{"head": "原子", "head_type": "概念", "relation": "被定义为", "tail": "包含了变量的元组", "tail_type": "概念"}, {"head": "原子", "head_type": "概念", "relation": "英文名", "tail": "atom", "tail_type": "概念"}]}
{"text": "这条规则里的规则主体就包含了以否定形式出现的原子。", "relation": [{"head": "规则主体", "head_type": "概念", "relation": "包含", "tail": "以否定形式出现的原子", "tail_type": "概念"}]}
{"text": "这几种不同规则的包含关系如下：路径规则∈霍恩规则∈一般规则.即路径规则是霍恩规则的一个子集，而霍恩规则又是一般规则的一个子集，从规则的表达能力来看，一般规则的表达能力最强，包含各种不同的规则类型，而霍恩规则次之，规则路径的表达能力最弱，只能表达特定类型的规则。", "relation": [{"head": "路径规则", "head_type": "概念", "relation": "属于", "tail": "霍恩规则", "tail_type": "概念"}, {"head": "霍恩规则", "head_type": "概念", "relation": "属于", "tail": "一般规则", "tail_type": "概念"}]}
{"text": "对于一个规则rule，在知识图谱中，其支持度（support）指的是满足规则主体和规则头的实例个数，规则的实例化指的是将规则中的变量替换成知识图谱中真实的实体后的结果。", "relation": [{"head": "支持度", "head_type": "概念", "relation": "等价", "tail": "满足规则主体和规则头的实例个数", "tail_type": "概念"}, {"head": "规则的实例化", "head_type": "概念", "relation": "等价", "tail": "将规则中的变量替换成知识图谱中真实的实体后的结果", "tail_type": "概念"}]}
{"text": "由于知识图谱往往具有明显的不完整性，而前文介绍的规则置信度计算方法间接假设了不存在知识图谱中的三元组是错误的，这显然是不合理的。", "relation": [{"head": "规则置信度计算方法", "head_type": "概念", "relation": "依靠", "tail": "假设不存在知识图谱中的三元组是错误的", "tail_type": "概念"}]}
{"text": "规则头覆盖度（Head_Coverage）的计算方法为即规则支持度和满足规则头的实例个数的比值，即在满足规则头的实例中，同时也满足规则主体的实例比例。", "relation": [{"head": "规则头覆盖度的计算方法", "head_type": "概念", "relation": "等价", "tail": "规则支持度和满足规则头的实例个数的比值", "tail_type": "概念"}]}
{"text": "规则的支持度、置信度以及头覆盖度从不同的角度反映了规则的质量，但三者之间没有必然的关联关系。", "relation": [{"head": "规则的支持度", "head_type": "概念", "relation": "实现", "tail": "规则的质量", "tail_type": "概念"}, {"head": "规则的置信度", "head_type": "概念", "relation": "实现", "tail": "规则的质量", "tail_type": "概念"}, {"head": "头覆盖度", "head_type": "概念", "relation": "实现", "tail": "规则的质量", "tail_type": "概念"}]}
{"text": "即在规则中增加一个原子，这个原子包含一个新的变量和一个已经在规则中出现的元素，可以是出现过的变量，也可以是出现过的实体。", "relation": [{"head": "已经在规则中出现的元素", "head_type": "概念", "relation": "包含", "tail": "出现过的变量", "tail_type": "概念"}, {"head": "已经在规则中出现的元素", "head_type": "概念", "relation": "包含", "tail": "出现过的实体", "tail_type": "概念"}]}
{"text": "无论采用哪种挖掘算子来增加规则中的原子，每一个原子都伴随着需要选择一个知识图谱中的关系。", "relation": [{"head": "每一个原子", "head_type": "概念", "relation": "依靠", "tail": "选择一个知识图谱中的关系", "tail_type": "概念"}]}
{"text": "表示学习让算法在学习向量表示的过程中自动捕捉、推理所需的特征，通过训练学习，将知识图谱中离散符号表示的信息编码在不同的向量空间表示中，使得知识图谱的推理能够通过预设的向量空间表示之间的计算自动实现，不需要显式的推理步骤。", "relation": [{"head": "知识图谱中离散符号表示的信息", "head_type": "概念", "relation": "实现", "tail": "将知识图谱中离散符号表示的信息编码在不同的向量空间表示中", "tail_type": "概念"}, {"head": "表示学习", "head_type": "概念", "relation": "被定义为", "tail": "在学习向量表示的过程中自动捕捉、推理所需的特征", "tail_type": "概念"}]}
{"text": "TransE的简单高效说明了知识图谱表示学习方法能够自动且很好地捕捉推理特征，无须人工设计，很适合在大规模复杂的知识图谱上推广，是一种有效的知识图谱推理手段。", "relation": [{"head": "知识图谱表示学习方法", "head_type": "概念", "relation": "实现", "tail": "自动且很好地捕捉推理特征", "tail_type": "概念"}, {"head": "知识图谱表示学习方法", "head_type": "概念", "relation": "属于", "tail": "知识图谱推理手段", "tail_type": "概念"}]}
{"text": "实践证明，TransE由于其有效合理的向量空间假设，是一种简单高效的知识图谱表示学习方法，并且能够完成多种关系的链接预测任务。", "relation": [{"head": "TransE", "head_type": "概念", "relation": "属于", "tail": "知识图谱表示学习方法", "tail_type": "概念"},{"head": "TransE", "head_type": "概念", "relation": "实现", "tail": "多种关系的链接预测任务", "tail_type": "概念"}]}
{"text": "这说明了DistMult天然地假设了所有的关系是对称关系，这显然是不合理的。", "relation": [{"head": "DistMult", "head_type": "产品", "relation": "依靠", "tail": "假设所有的关系是对称关系", "tail_type": "概念"}]}
{"text": "传统的数据流学习主要是从连续和快速更新的数据记录中提取知识结构。", "relation": [{"head": "传统的数据流学习", "head_type": "概念", "relation": "被定义为", "tail": "从连续和快速更新的数据记录中提取知识结构", "tail_type": "概念"}]}
{"text": "具体而言，强化学习中智能体的状态被定义为当前节点实体和目标节点实体的联合表示.智能体的动作则是在当前节点实体的出边（Outgoing_edge）中选择一个适当的边作为组成路径的关系。", "relation": [{"head": "智能体的状态", "head_type": "概念", "relation": "被定义为", "tail": "当前节点实体和目标节点实体的联合表示", "tail_type": "概念"}, {"head": "智能体的动作", "head_type": "概念", "relation": "被定义为", "tail": "当前节点实体的出边（Outgoing_edge）中选择一个适当的边作为组成路径的关系", "tail_type": "概念"}]}
{"text": "元学习的目的是解决“学习如何学习”（Learning_to_Learn），旨在通过少量样本迅速完成学习，其相对主要的应用是少样本学习（Few-Shot_Learning）。", "relation": [{"head": "元学习的目的", "head_type": "概念", "relation": "研究", "tail": "“解决学习如何学习”（Learning_to_Learn）", "tail_type": "概念"}, {"head": "元学习", "head_type": "概念", "relation": "实现", "tail": "少样本学习（Few-Shot_Learning）", "tail_type": "概念"}]}
{"text": "Drools（JBoss_Rules）具有一个易于访问企业策略、易于调整以及易于管理的开源业务规则引擎，符合业内标准，具有速度快、效率高的特点。", "relation": [{"head": "Drools（JBoss_Rules）", "head_type": "产品", "relation": "属于", "tail": "开源业务规则引擎", "tail_type": "概念"}]}
