{"text": "知识图谱包含描述抽象知识的本体层和描述具体事实的实例层。", "relation": [{"head": "知识图谱", "head_type": "概念", "relation": "包含", "tail": "本体层", "tail_type": "概念"}, {"head": "知识图谱", "head_type": "概念", "relation": "包含", "tail": "实例层", "tail_type": "概念"}, {"head": "本体层", "head_type": "概念", "relation": "被定义为", "tail": "描述抽象知识", "tail_type": "概念"}, {"head": "实例层", "head_type": "概念", "relation": "被定义为", "tail": "描述具体事实", "tail_type": "概念"}]}
{"text": "一方面，本体虽然能解决特定应用中的知识共享问题，但事实上不可能构建出一个覆盖万事万物的统一本体。", "relation": [{"head": "本体", "head_type": "概念", "relation": "实现", "tail": "特定应用中的知识共享", "tail_type": "概念"}]}
{"text": "知识融合是解决知识图谱异构问题的有效途径。知识融合建立异构本体或异构实例之间的联系，从而使异构的知识图谱能相互沟通，实现它们之间的互操作。", "relation": [{"head": "知识融合", "head_type": "概念", "relation": "实现", "tail": "建立异构本体或异构实例之间的联系", "tail_type": "概念"}, {"head": "知识融合", "head_type": "概念", "relation": "实现", "tail": "使异构的知识图谱能相互沟通", "tail_type": "概念"}]}
{"text": "知识融合的核心问题在于映射的生成。目前的各种本体匹配和实例匹配使用的技术基本可归结为基于自然语言处理进行术语比较、基于本体结构进行匹配，以及基于实例的机器学习等几类。", "relation": [{"head": "本体匹配和实例匹配技术", "head_type": "概念", "relation": "包含", "tail": "基于自然语言处理进行术语比较", "tail_type": "概念"}, {"head": "本体匹配和实例匹配技术", "head_type": "概念", "relation": "包含", "tail": "基于本体结构进行匹配", "tail_type": "概念"}, {"head": "本体匹配和实例匹配技术", "head_type": "概念", "relation": "包含", "tail": "基于实例的机器学习", "tail_type": "概念"}]}
{"text": "解决本体异构的通用方法是本体集成与本体映射[6-9]。本体集成直接将多个本体合并为一个大本体，本体映射则寻找本体间的映射规则，这两种方法最终都是为了消除本体异构，达到异构本体间的互操作。", "relation": [{"head": "本体异构的解决方法", "head_type": "概念", "relation": "包含", "tail": "本体集成", "tail_type": "概念"}, {"head": "本体异构的解决方法", "head_type": "概念", "relation": "包含", "tail": "本体映射", "tail_type": "概念"}, {"head": "本体集成", "head_type": "概念", "relation": "被定义为", "tail": "直接将多个本体合并为一个大本体", "tail_type": "概念"}, {"head": "本体映射", "head_type": "概念", "relation": "被定义为", "tail": "寻找本体间的映射规则", "tail_type": "概念"}, {"head": "本体集成", "head_type": "概念", "relation": "实现", "tail": "消除本体异构", "tail_type": "概念"}, {"head": "本体映射", "head_type": "概念", "relation": "实现", "tail": "消除本体异构", "tail_type": "概念"}]}
{"text": "基于单本体集成的集成方法是直接将多个异构本体集成为一个统一的本体，该本体提供统一的语义规范和共享词汇。", "relation": [{"head": "基于单本体集成", "head_type": "概念", "relation": "被定义为", "tail": "直接将多个异构本体集成为一个统一的本体", "tail_type": "概念"}]}
{"text": "局部本体侧重于特定的知识，而全局本体则保证不同系统间异构的部分能进行交互。基于全局本体-局部本体的集成方法既避免了局部本体存在过多的冗余，本体规模不会过于庞大，同时也达到了解决本体间异构的目的。", "relation": [{"head": "基于全局本体-局部本体的集成方法", "head_type": "概念", "relation": "实现", "tail": "避免局部本体存在过多的冗余", "tail_type": "概念"}, {"head": "基于全局本体-局部本体的集成方法", "head_type": "概念", "relation": "实现", "tail": "解决本体间异构", "tail_type": "概念"}]}
{"text": "明确本体映射的分类是建立异构本体间映射的基础。", "relation": [{"head": "建立异构本体间映射", "head_type": "概念", "relation": "依靠", "tail": "明确本体映射的分类", "tail_type": "概念"}]}
{"text": "本体间的不匹配是造成本体异构的根本原因，这种不匹配可分为语言层和模型层两个层次。", "relation": [{"head": "本体间的不匹配", "head_type": "概念", "relation": "实现", "tail": "本体异构", "tail_type": "概念"}, {"head": "本体间的不匹配", "head_type": "概念", "relation": "包含", "tail": "语言层", "tail_type": "概念"}, {"head": "本体间的不匹配", "head_type": "概念", "relation": "包含", "tail": "模型层", "tail_type": "概念"}]}
{"text": "XuBaowen等人提出了一种检查实例等价的框架[15]，这种方法同时使用了属性匹配和逻辑推理两种方法，并利用一种基于不相交集合并的算法来加速推理过程。", "relation": [{"head": "检查实例等价的框架", "head_type": "概念", "relation": "包含", "tail": "属性匹配", "tail_type": "概念"}, {"head": "检查实例等价的框架", "head_type": "概念", "relation": "包含", "tail": "逻辑推理", "tail_type": "概念"}, {"head": "检查实例等价的框架", "head_type": "概念", "relation": "包含", "tail": "不相交集合并的算法", "tail_type": "概念"}]}
{"text": "公理是本体中的一个重要成分，它是对其他本体成分的约束和限制。通常，一个公理由一些操作符和本体成分组合而成。", "relation": [{"head": "公理", "head_type": "概念", "relation": "被定义为", "tail": "对其他本体成分的约束和限制", "tail_type": "概念"}, {"head": "公理", "head_type": "概念", "relation": "包含", "tail": "操作符和本体成分", "tail_type": "概念"}]}
{"text": "从映射的对象来看，可将本体映射分为概念之间的映射和关系之间的映射两类，其中概念之间的映射是最基本的映射。", "relation": [{"head": "本体映射", "head_type": "概念", "relation": "包含", "tail": "概念之间的映射", "tail_type": "概念"},{"head": "本体映射", "head_type": "概念", "relation": "包含", "tail": "关系之间的映射", "tail_type": "概念"}]}
{"text": "WangPeng等人以概念间的映射和关系间的映射为基础，从功能上归纳出11种主要的本体映射，并称这些映射为异构本体间的桥[16]：表示概念间映射的桥包括等价（Equal）、同形异义（Different）、上义（Is-a）、下义（Include）、重叠（Overlap）、部分（Part-of）、对立（Opposed）和连接（Connect）共8种；表示关系间映射的桥等价（Equal）、包含（Subsume）和逆（Inverse）3种。这11种桥基本能描述异构本体间具有的映射功能。", "relation": [{"head": "表示概念间映射的桥", "head_type": "概念", "relation": "包含", "tail": "等价（Equal）", "tail_type": "概念"}, {"head": "表示概念间映射的桥", "head_type": "概念", "relation": "包含", "tail": "同形异义（Different）", "tail_type": "概念"}, {"head": "表示概念间映射的桥", "head_type": "概念", "relation": "包含", "tail": "上义（Is-a）", "tail_type": "概念"}, {"head": "表示概念间映射的桥", "head_type": "概念", "relation": "包含", "tail": "重叠（Overlap）", "tail_type": "概念"}, {"head": "表示概念间映射的桥", "head_type": "概念", "relation": "包含", "tail": "下义（Include）", "tail_type": "概念"}, {"head": "表示概念间映射的桥", "head_type": "概念", "relation": "包含", "tail": "部分（Part-of）", "tail_type": "概念"}, {"head": "表示概念间映射的桥", "head_type": "概念", "relation": "包含", "tail": "对立（Opposed）", "tail_type": "概念"}, {"head": "表示概念间映射的桥", "head_type": "概念", "relation": "包含", "tail": "连接（Connect）", "tail_type": "概念"}, {"head": "表示关系间映射的桥", "head_type": "概念", "relation": "包含", "tail": "等价（Equal）", "tail_type": "概念"}, {"head": "表示关系间映射的桥", "head_type": "概念", "relation": "包含", "tail": "包含（Subsume）", "tail_type": "概念"}, {"head": "表示关系间映射的桥", "head_type": "概念", "relation": "包含", "tail": "逆（Inverse）", "tail_type": "概念"}]}
{"text": "最基本的映射功能是等价映射，是为了建立不同本体的成分之间的等价关系。", "relation": [{"head": "等价映射", "head_type": "概念", "relation": "实现", "tail": "建立不同本体的成分之间的等价关系", "tail_type": "概念"}]}
{"text": "实际上，复杂映射和简单映射的界限很难界定。通常，将那些基本的、必要的、组成简单的和发现过程相对容易的映射称作简单映射；将那些不直观的、组成复杂并且发现过程相对困难的映射称为复杂映射。", "relation": [{"head": "简单映射", "head_type": "概念", "relation": "被定义为", "tail": "基本的、必要的、组成简单的和发现过程相对容易的映射", "tail_type": "概念"},{"head": "复杂映射", "head_type": "概念", "relation": "被定义为", "tail": "不直观的、组成复杂并且发现过程相对困难的映射", "tail_type": "概念"}]}
{"text": "等价映射声明了概念之间和关系之间的对应，异构本体的等价成分之间在互操作过程中可以直接相互替代。", "relation": [{"head": "等价映射", "head_type": "概念", "relation": "实现", "tail": "概念之间和关系之间的对应", "tail_type": "概念"}]}
{"text": "基于术语和结构的本体映射。从本体中术语和结构的相似性来寻找本体映射是比较直观和基础的方法。这里先介绍这种方法的思想，然后探讨一些典型和相关的工作。", "relation": [{"head": "本体中术语和结构的相似性", "head_type": "概念", "relation": "实现", "tail": "寻找本体映射", "tail_type": "概念"}]}
{"text": "基于字符串的方法。基于字符串的方法直接比较表示本体成分的术语的字符串结构。", "relation": [{"head": "基于字符串的方法", "head_type": "概念", "relation": "依靠", "tail": "直接比较表示本体成分的术语的字符串结构", "tail_type": "概念"}]}
{"text": "规范化操作主要包括：大小写规范化，即将字符串中的每个符号转换为大写字母或小写字母的形式；消除变音符，即将字符串中的变音符号替换为它的常见形式，如Montréal替换为Montreal；空白正规化，即将所有的空白字符（如空格、制表符和回车等）转换为单个的空格符号；", "relation": [{"head": "规范化操作", "head_type": "概念", "relation": "包含", "tail": "大小写规范化", "tail_type": "概念"},{"head": "大小写规范化", "head_type": "概念", "relation": "被定义为", "tail": "将字符串中的每个符号转换为大写字母或小写字母的形式", "tail_type": "概念"},{"head": "规范化操作", "head_type": "概念", "relation": "包含", "tail": "消除变音符", "tail_type": "概念"},{"head": "消除变音符", "head_type": "概念", "relation": "被定义为", "tail": "将字符串中的变音符号替换为它的常见形式", "tail_type": "概念"},{"head": "规范化操作", "head_type": "概念", "relation": "包含", "tail": "空白正规化", "tail_type": "概念"},{"head": "空白正规化", "head_type": "概念", "relation": "被定义为", "tail": "将所有的空白字符（如空格、制表符和回车等）转换为单个的空格符号", "tail_type": "概念"}]}
{"text": "在规范字符串的基础上，能进一步度量不同字符串间的相似程度。常用的字符串度量方法有：汉明距离、子串相似度、编辑距离和路径距离等。", "relation": [{"head": "字符串相似度度量方法", "head_type": "概念", "relation": "包含", "tail": "汉明距离", "tail_type": "度量方法"},{"head": "字符串相似度度量方法", "head_type": "概念", "relation": "包含", "tail": "子串相似度", "tail_type": "度量方法"},{"head": "字符串相似度度量方法", "head_type": "概念", "relation": "包含", "tail": "编辑距离", "tail_type": "概念"},{"head": "字符串相似度度量方法", "head_type": "概念", "relation": "包含", "tail": "路径距离", "tail_type": "概念"}]}
{"text": "字符串间的相似度还能通过编辑距离来度量。两字符串之间的编辑距离是指修改其中一个使之与另一个相同所需要的最小操作代价。", "relation": [{"head": "编辑距离", "head_type": "概念", "relation": "被定义为", "tail": "修改其中一个使之与另一个相同所需要的最小操作代价", "tail_type": "概念"}]}
{"text": "基于语言的方法依靠自然语言处理技术寻找概念或关系之间的联系。这类方法又可分为内部方法和外部方法，前者使用语言的内部属性，如形态和语法特点，后者则利用外部的资源，如词典等。", "relation": [{"head": "基于语言的方法", "head_type": "概念", "relation": "依靠", "tail": "自然语言处理技术寻找概念或关系之间的联系", "tail_type": "概念"},{"head": "基于语言的方法", "head_type": "概念", "relation": "包含", "tail": "内部方法", "tail_type": "概念"},{"head": "基于语言的方法", "head_type": "概念", "relation": "包含", "tail": "外部方法", "tail_type": "概念"}]}
{"text": "内部方法在寻找术语间的映射时利用词语形态和语法分析来保证术语的规范化。它寻找同一字符串的不同语言形态，如Apple和Apples等。", "relation": [{"head": "内部方法的规范化", "head_type": "概念", "relation": "依靠", "tail": "词语形态和语法分析", "tail_type": "概念"}]}
{"text": "外部方法利用词典等外部资源来寻找映射。", "relation": [{"head": "外部概念", "head_type": "概念", "relation": "依靠", "tail": "词典等外部资源来寻找映射", "tail_type": "资源"}]}
{"text": "使用WordNet能判断两个术语是否有同义或上下义关系。", "relation": [{"head": "WordNet", "head_type": "产品", "relation": "实现", "tail": "判断两个术语是否有同义或上下义关系", "tail_type": "概念"}]}
{"text": "PROMPT是Stanford大学开发的一套本体工具集[25]。", "relation": [{"head": "PROMPT ", "head_type": "产品", "relation": "属于", "tail": "本体工具集", "tail_type": "概念"}]}
{"text": "一个寻找本体间相似映射的工具AnchorPROMPT，它扩展了iPROMPT发现映射的性能，能发现更多PROMPTDiff，它比较本体的两个版本，识别它们之间结构上的不同。", "relation": [{"head": "AnchorPROMP", "head_type": "产品", "relation": "属于", "tail": "寻找本体间相似映射的工具", "tail_type": "概念"}]}
{"text": "为了发现本体间的映射，Noy_NF等人于1999年就开发了SMART算法[26,27]，该方法通过比较概念名的相似性，识别异构本体间的等价概念。", "relation": [{"head": "SMART ", "head_type": "概念", "relation": "依靠", "tail": "比较概念名的相似性", "tail_type": "概念"}, {"head": "SMART ", "head_type": "概念", "relation": "实现", "tail": "识别异构本体间的等价概念", "tail_type": "概念"}]}
{"text": "iPROMPT利用术语技术发现不同本体间的映射，并根据映射结果给出一系列本体合并建议，用于指导用户进行本体合并。", "relation": [{"head": "iPROMPT", "head_type": "产品", "relation": "依靠", "tail": "术语技术发现不同本体间的映射", "tail_type": "概念"}, {"head": "iPROMPT", "head_type": "产品", "relation": "实现", "tail": "根据映射结果给出一系列本体合并建议，用于指导用户进行本体合并", "tail_type": "概念"}]}
{"text": "iPROMPT中的操作包括合并概念、合并关系、合并实例、拷贝单个的概念和拷贝一系列的概念等。", "relation": [{"head": "iPROMPT中的操作", "head_type": "概念", "relation": "包含", "tail": "合并概念", "tail_type": "概念"},{"head": "iPROMPT中的操作", "head_type": "概念", "relation": "包含", "tail": "合并实例", "tail_type": "概念"},{"head": "iPROMPT中的操作", "head_type": "概念", "relation": "包含", "tail": "合并关系", "tail_type": "概念"},{"head": "iPROMPT中的操作", "head_type": "概念", "relation": "包含", "tail": "拷贝单个的概念", "tail_type": "概念"},{"head": "iPROMPT中的操作", "head_type": "概念", "relation": "包含", "tail": "拷贝一系列的概念", "tail_type": "概念"}]}
{"text": "MAFRA是处理语义Web上分布式本体间映射的一个框架[30-32]，该框架是为了处理、表示并应用异构本体间的映射。", "relation": [{"head": "MAFRA", "head_type": "产品", "relation": "属于", "tail": "处理语义Web上分布式本体间映射的一个框架", "tail_type": "概念"}, {"head": "MAFRA ", "head_type": "产品", "relation": "实现", "tail": "处理、表示并应用异构本体间的映射", "tail_type": "概念"}]}
{"text": "ONION是MitraP等人设计的一个解决本体互操作的系统[33-34]。", "relation": [{"head": "ONION", "head_type": "产品", "relation": "属于", "tail": "解决本体互操作的系统", "tail_type": "概念"}]}
{"text": "同义词集是语义相同或相近词的分组[38]。基于同名或同义词集的概念在多数情况下具有相同或是相近的含义，因此，这里将概念的名称作为相似度首要考虑的要素。", "relation": [{"head": "同义词集", "head_type": "概念", "relation": "被定义为", "tail": "语义相同或相近词的分组", "tail_type": "概念"}]}
{"text": "概念的特征包含概念的属性、概念附带的关系以及属性和关系取值的限制，是从概念的内部组成上比较它们之间的相似度。", "relation": [{"head": "概念的特征", "head_type": "概念", "relation": "包含", "tail": "概念的属性", "tail_type": "概念"},{"head": "概念的特征", "head_type": "概念", "relation": "包含", "tail": "概念附带的关系", "tail_type": "概念"},{"head": "概念的特征", "head_type": "概念", "relation": "包含", "tail": "属性和关系取值的限制", "tail_type": "概念"},{"head": "概念的特征", "head_type": "概念", "relation": "被定义为", "tail": "从概念的内部组成上比较它们之间的相似度。", "tail_type": "概念"}]}
