{"text": "知识图谱推理在一个知识图谱的发展演变过程中起着重要的作用，知识图谱推理能用来对知识图谱进行补全和质量检测等。", "relation": [{"head": "知识图谱推理", "head_type": "概念", "relation": "实现", "tail": "对知识图谱进行补全和质量检测", "tail_type": "概念"}]}
{"text": "推理的方法大致可以分为逻辑推理和非逻辑推理，其中逻辑推理的过程包含了严格的约束和推理过程，而非逻辑推理的过程相对模糊。", "relation": [{"head": "推理", "head_type": "概念", "relation": "包含", "tail": "逻辑推理", "tail_type": "概念"}, {"head": "推理", "head_type": "概念", "relation": "包含", "tail": "非逻辑推理", "tail_type": "概念"}, {"head": "逻辑推理", "head_type": "概念", "relation": "包含", "tail": "严格的约束和推理过程", "tail_type": "概念"}]}
{"text": "逻辑推理按照推理方式的不同包含两大类：演绎推理（Deductive_Reasoning）和归纳推理（Inductive_Reasoning）。", "relation": [{"head": "逻辑推理", "head_type": "概念", "relation": "包含", "tail": "归纳推理", "tail_type": "概念"}, {"head": "逻辑推理", "head_type": "概念", "relation": "包含", "tail": "演绎推理", "tail_type": "概念"}, {"head": "演绎推理", "head_type": "概念", "relation": "英文名", "tail": "Deductive_Reasoning", "tail_type": "概念"}, {"head": "归纳推理", "head_type": "概念", "relation": "英文名", "tail": "Inductive_Reasoning", "tail_type": "概念"}]}
{"text": "演绎推理[1]是一种自上而下（top-down_logic）的逻辑推理，是指在给定的一个或多个前提的情况下，推断出一个必然成立的结论的过程。", "relation": [{"head": "演绎推理", "head_type": "概念", "relation": "属于", "tail": "自上而下的逻辑推理", "tail_type": "概念"}, {"head": "演绎推理", "head_type": "概念", "relation": "被定义为", "tail": "在给定的一个或多个前提的情况下，推断出一个必然成立的结论的过程", "tail_type": "概念"}, {"head": "自上而下", "head_type": "概念", "relation": "英文名", "tail": "top-down_logic", "tail_type": "概念"}]}
{"text": "典型的演绎推理有肯定前件假言推理、否定后件假言推理（Modus_Tollens）以及三段论（Law_of_Syllogism）。", "relation": [{"head": "演绎推理", "head_type": "概念", "relation": "包含", "tail": "肯定前件假言推理", "tail_type": "概念"}, {"head": "演绎推理", "head_type": "概念", "relation": "包含", "tail": "否定后件假言推理", "tail_type": "概念"}, {"head": "演绎推理", "head_type": "概念", "relation": "包含", "tail": "三段论", "tail_type": "概念"}, {"head": "否定后件假言推理", "head_type": "概念", "relation": "英文名", "tail": "Modus_Tollens", "tail_type": "概念"}, {"head": "三段论", "head_type": "概念", "relation": "英文名", "tail": "Law_of_Syllogism", "tail_type": "概念"}]}
{"text": "其中，肯定前件假言推理是指性质命题肯定了假言命题的前件，从而推理出肯定的假言后件。", "relation": [{"head": "肯定前件假言推理", "head_type": "概念", "relation": "被定义为", "tail": "性质命题肯定了假言命题的前件从而推理出肯定的假言后件", "tail_type": "概念"}]}
{"text": "而否定后件假言推理是指性质命题否定了假言命题的后件，从而推理出否定的假言前件。", "relation": [{"head": "否定后件假言推理", "head_type": "概念", "relation": "被定义为", "tail": "性质命题否定了假言命题的后件从而推理出否定的假言前件", "tail_type": "概念"}]}
{"text": "从以上的例子可以看出，演绎推理是一种形式化的逻辑推理。", "relation": [{"head": "演绎推理", "head_type": "概念", "relation": "属于", "tail": "形式化的逻辑推理", "tail_type": "概念"}]}
{"text": "归纳推理[2]是一种自下而上的推理，是指基于已有的部分观察得出一般结论的过程。", "relation": [{"head": "归纳推理", "head_type": "概念", "relation": "属于", "tail": "自下而上的推理", "tail_type": "概念"}, {"head": "归纳推理", "head_type": "", "relation": "被定义为", "tail": "基于已有的部分观察得出一般结论的过程", "tail_type": "概念"}]}
{"text": "典型的归纳推理有归纳泛化（Inductive_Generalization）、统计推理（Statistical_Syllogism）。","relation": [{"head": "典型的归纳推理", "head_type": "概念", "relation": "包含", "tail": "归纳泛化（Inductive_Generalization）", "tail_type": "概念"},{"head": "典型的归纳推理", "head_type": "概念", "relation": "包含", "tail": "统计推理（Statistical_Syllogism）", "tail_type": "概念"}, {"head": "归纳泛化", "head_type": "概念", "relation": "英文名", "tail": "Inductive_Generalization", "tail_type": "概念"}, {"head": "统计推理", "head_type": "概念", "relation": "英文名", "tail": "Statistical_Syllogism", "tail_type": "概念"}]}
{"text": "归纳泛化是指基于对个体的观察而得出可能适用于整体的结论，即在整体的一些样本中得到的结论可以泛化到整体上。", "relation": [{"head": "归纳泛化", "head_type": "概念", "relation": "被定义为", "tail": "基于对个体的观察而得出可能适用于整体的结论", "tail_type": "概念"}]}
{"text": "而统计推理是将整体的统计结论应用于个体。", "relation": [{"head": "统计推理", "head_type": "概念", "relation": "被定义为", "tail": "将整体的统计结论应用于个体", "tail_type": "概念"}]}
{"text": "归纳推理是一种非形式化的推理，是由具体到一般的推理过程。", "relation": [{"head": "归纳推理", "head_type": "概念", "relation": "属于", "tail": "非形式化的推理", "tail_type": "概念"}, {"head": "归纳推理", "head_type": "概念", "relation": "被定义为", "tail": "具体到一般的推理过程", "tail_type": "概念"}]}
{"text": "溯因推理[3]也是一种逻辑推理，是在给定一个或多个已有观察事实O（Observation），并根据已有的知识T（Theory）推断出对已有观察最简单且最有可能的解释的过程。", "relation": [{"head": "溯因推理", "head_type": "概念", "relation": "属于", "tail": "逻辑推理", "tail_type": "概念"},{"head": "溯因推理", "head_type": "概念", "relation": "被定义为", "tail": "在给定一个或多个已有观察事实O并根据已有的知识T推断出对已有观察最简单且最有可能的解释的过程。", "tail_type": "概念"}]}
{"text": "溯因推理是归纳推理的一种，因为整个推理过程的前提和结论并没有必然的关系。", "relation": [{"head": "溯因推理", "head_type": "概念", "relation": "属于", "tail": "归纳推理", "tail_type": "概念"}]}
{"text": "由于现实世界的知识千千万万，想要涵盖所有的知识是很难的，所以知识图谱的不完整性很明显，在对知识图谱进行补全的过程中，链接预测是一种典型的推理任务[8]。", "relation": [{"head": "链接预测", "head_type": "概念", "relation": "属于", "tail": "推理任务", "tail_type": "概念"}]}
{"text": "本体的一般定义为概念化的显示规约，它给不同的领域提供共享的词汇。", "relation": [{"head": "本体", "head_type": "概念", "relation": "被定义为", "tail": "概念化的显示规约", "tail_type": "概念"}]}
{"text": "OWL按表达能力从低到高划分成OWL_Lite、OWL_DL和OWL_Full。", "relation": [{"head": "OWL", "head_type": "概念", "relation": "包含", "tail": "OWL_Lite", "tail_type": "概念"}, {"head": "OWL", "head_type": "概念", "relation": "包含", "tail": "OWL_DL", "tail_type": "概念"}, {"head": "OWL", "head_type": "概念", "relation": "包含", "tail": "OWL_Full", "tail_type": "概念"}]}
{"text": "OWL_Lite和OWL_DL在语义上等价于某些描述逻辑（Description_Logics,DLs）[14,15]，而OWL_Full没有对应的描述逻辑。", "relation": [{"head": "OWL_Lite", "head_type": "概念", "relation": "等价", "tail": "描述逻辑", "tail_type": "概念"}, {"head": "OWL_DL", "head_type": "概念", "relation": "等价", "tail": "描述逻辑", "tail_type": "概念"}, {"head": "描述逻辑", "head_type": "概念", "relation": "英文名", "tail": "Description_Logics,DLs", "tail_type": "概念"}]}
{"text": "目前，OWL是知识图谱语言中最规范、最严谨、表达能力最强的语言，而且OWL基于RDF语法，使表示出来的文档具有语义理解的结构基础，OWL的另外一个作用是促进了统一词汇表的使用，定义了丰富的语义词汇。", "relation": [{"head": "OWL", "head_type": "概念", "relation": "依靠", "tail": "RDF", "tail_type": "概念"}, {"head": "OWL", "head_type": "概念", "relation": "实现", "tail": "统一词汇表的使用", "tail_type": "概念"}]}
{"text": "FaCT++是曼彻斯特大学开发的描述逻辑推理机，使用C++实现，且能与Protégé集成。", "relation": [{"head": "FaCT++", "head_type": "产品", "relation": "属于", "tail": "描述逻辑推理机", "tail_type": "概念"}, {"head": "FaCT++", "head_type": "产品", "relation": "依靠", "tail": "C++", "tail_type": "概念"}]}
{"text": "在通常情况下，Prolog程序是通过SLD消解和回溯来执行的[25]。", "relation": [{"head": "Prolog程序", "head_type": "产品", "relation": "依靠", "tail": "SLD消解和回溯", "tail_type": "概念"}]}
{"text": "从语法上来说，Datalog程序基本上是Prolog的一个子集。", "relation": [{"head": "Datalog", "head_type": "产品", "relation": "属于", "tail": "Prolog", "tail_type": "概念"}]}
{"text": "它们的主要区别是在语义层面，Datalog基于完全声明式的模型论的语义，并保证可终止性。", "relation": [{"head": "Datalog", "head_type": "产品", "relation": "依靠", "tail": "完全声明式的模型论的语义", "tail_type": "概念"}]}
{"text": "OWL_RL的设计目标之一就是找出可以用规则推理来实现的一个OWL的片段。", "relation": [{"head": "OWL_RL", "head_type": "概念", "relation": "研究", "tail": "用规则推理来实现的一个OWL的片段", "tail_type": "概念"}]}
{"text": "Datalog事实（fact）是形如F(c1,c2,…,cn):-的没有体部且没有变量的规则。", "relation": [{"head": "Datalog事实（fact）", "head_type": "概念", "relation": "被定义为", "tail": "没有体部且没有变量的规则", "tail_type": "概念"}]}
{"text": "一个知识图谱可以自然地被看作一个事实集。", "relation": [{"head": "知识图谱", "head_type": "概念", "relation": "等价", "tail": "事实集", "tail_type": "概念"}]}
{"text": "SWRL是2004年提出的一个完全基于Datalog的规则语言。", "relation": [{"head": "SWRL", "head_type": "概念", "relation": "属于", "tail": "基于Datalog的规则语言", "tail_type": "概念"}]}
{"text": "OWL_RL是W3C定义的OWL_2的一个子语言，其设计目标为可以直接转换成Datalog程序，从而使用现有的Datalog推理机推理。", "relation": [{"head": "OWL_RL", "head_type": "概念", "relation": "属于", "tail": "OWL_2", "tail_type": "概念"}]}
{"text": "RDFox的输入包括本体（TBox）、数据（ABox）和一个自定义规则集。", "relation": [{"head": "RDFox的输入", "head_type": "概念", "relation": "包含", "tail": "本体（TBox）]", "tail_type": "概念"}, {"head": "RDFox的输入", "head_type": "概念", "relation": "包含", "tail": "数据（ABox）", "tail_type": "概念"}, {"head": "RDFox的输入", "head_type": "概念", "relation": "包含", "tail": "一个自定义规则集", "tail_type": "概念"}, {"head": "本体", "head_type": "概念", "relation": "英文名", "tail": "TBox", "tail_type": "概念"}, {"head": "数据", "head_type": "概念", "relation": "英文名", "tail": "ABox", "tail_type": "概念"}]}
{"text": "第一种情况直接在知识图谱之上的查询称为本体介导的查询回答（Ontology-Mediated_Query_Answering,OMQ）[27]。", "relation": [{"head": "本体介导的查询回答", "head_type": "概念", "relation": "被定义为", "tail": "直接在知识图谱之上的查询", "tail_type": "概念"}, {"head": "本体介导的查询回答", "head_type": "概念", "relation": "英文名", "tail": "Ontology-Mediated_Query_Answering,OMQ", "tail_type": "概念"}]}
{"text": "1.OBDA框架包含外延（extensional）和内涵（intensional）两个部分。", "relation": [{"head": "OBDA框架", "head_type": "概念", "relation": "包含", "tail": "外延", "tail_type": "概念"}, {"head": "OBDA框架", "head_type": "概念", "relation": "包含", "tail": "内涵", "tail_type": "概念"}, {"head": "外延", "head_type": "概念", "relation": "英文名", "tail": "extensional", "tail_type": "概念"}, {"head": "内涵", "head_type": "概念", "relation": "英文名", "tail": "intensional", "tail_type": "概念"}]}
{"text": "OBDA的主要推理任务为查询", "relation": [{"head": "OBDA的主要推理任务", "head_type": "概念", "relation": "研究", "tail": "查询", "tail_type": "概念"}]}
{"text": "Mastro最初是由意大利罗马大学开发的OBDA系统，现在由OBDA_Systems商业化运行。", "relation": [{"head": "Mastro", "head_type": "产品", "relation": "源于", "tail": "意大利罗马大学", "tail_type": "概念"}, {"head": "Mastro", "head_type": "产品", "relation": "属于", "tail": "OBDA系统", "tail_type": "概念"}]}
{"text": "Stardog原本是由Stardog_Union开发的商业化的Triple存储工具。", "relation": [{"head": "Stardog", "head_type": "产品", "relation": "属于", "tail": "Triple存储工具", "tail_type": "概念"}]}
{"text": "一个产生式系统由事实集合、产生式集合和推理引擎三部分组成。", "relation": [{"head": "产生式系统", "head_type": "概念", "relation": "包含", "tail": "事实集合", "tail_type": "概念"},{"head": "产生式系统", "head_type": "概念", "relation": "包含", "tail": "产生式集合", "tail_type": "概念"},{"head": "产生式系统", "head_type": "概念", "relation": "包含", "tail": "推理引擎", "tail_type": "概念"}]}
{"text": "事实集合是运行内存（Working_Memory,WM）为事实（WME）的集合，用于存储当前系统中的所有事实。", "relation": [{"head": "事实集合", "head_type": "概念", "relation": "被定义为", "tail": "运行内存（Working_Memory,WM）为事实（WME）的集合", "tail_type": "概念"}, {"head": "事实集合", "head_type": "概念", "relation": "实现", "tail": "存储当前系统中的所有事实", "tail_type": "概念"}]}
{"text": "推理引擎用于控制系统的执行。", "relation": [{"head": "推理引擎", "head_type": "概念", "relation": "实现", "tail": "控制系统的执行", "tail_type": "概念"}]}
{"text": "Jena是一个用于构建语义网应用的Java框架。", "relation": [{"head": "Jena", "head_type": "产品", "relation": "属于", "tail": "构建语义网应用的Java框架", "tail_type": "概念"}]}
{"text": "按照推理要素的不同，基于归纳的知识图谱推理可以分为以下几类：基于图结构的推理、基于规则学习的推理和基于表示学习的推理。", "relation": [{"head": "基于归纳的知识图谱推理", "head_type": "概念", "relation": "属于", "tail": "基于图结构的推理", "tail_type": "概念"}, {"head": "基于归纳的知识图谱推理", "head_type": "概念", "relation": "属于", "tail": "基于规则学习的推理", "tail_type": "概念"}, {"head": "基于归纳的知识图谱推理", "head_type": "概念", "relation": "属于", "tail": "基于表示学习的推理", "tail_type": "概念"}]}
{"text": "结合了有效采样和随机有走的PRA能够快速有效地利用知识图谱的路径结构对知识图谱进行关系推理，是典型的基于图结构的知识图谱推理算法。", "relation": [{"head": "PRA", "head_type": "概念", "relation": "依靠", "tail": "有效采样和随机有走", "tail_type": "概念"}, {"head": "PRA", "head_type": "概念", "relation": "实现", "tail": "快速有效地利用知识图谱的路径结构对知识图谱进行关系推理", "tail_type": "概念"}, {"head": "PRA", "head_type": "概念", "relation": "属于", "tail": "典型的基于图结构的知识图谱推理算法", "tail_type": "概念"}]}
{"text": "SFE同时还利用了关系的向量表示，通过训练好的关系的表示，将已有路径特征中的关系替换为向量空间中比较相似的关系。", "relation": [{"head": "SFE", "head_type": "概念", "relation": "依靠", "tail": "关系的向量表示", "tail_type": "概念"}]}
{"text": "所以，自动化的规则学习方法应运而生，旨在快速有效地从大规模知识图谱上学习置信度较高的规则，并服务于关系推理任务。", "relation": [{"head": "自动化的规则学习方法", "head_type": "概念", "relation": "实现", "tail": "快速有效地从大规模知识图谱上学习置信度较高的规则", "tail_type": "概念"}, {"head": "自动化的规则学习方法", "head_type": "概念", "relation": "实现", "tail": "关系推理任务", "tail_type": "概念"}]}
{"text": "其中，规则头由一个二元的原子（atom）构成，而规则主体由一个或多个一元原子或二元原子组成。", "relation": [{"head": "规则头", "head_type": "概念", "relation": "包含", "tail": "二元的原子", "tail_type": "概念"}, {"head": "规则主体", "head_type": "概念", "relation": "包含", "tail": "一元原子或二元原子组成", "tail_type": "概念"}]}
{"text": "规则一般包含了两个部分，分别为规则头（head）和规则主体（body），其一般形式为rule:head←body.解读为有规则主体的信息可推出规则头的信息。", "relation": [{"head": "规则", "head_type": "概念", "relation": "包含", "tail": "规则头", "tail_type": "概念"}, {"head": "规则", "head_type": "概念", "relation": "包含", "tail": "规则主体", "tail_type": "概念"}, {"head": "规则头", "head_type": "概念", "relation": "英文名", "tail": "head", "tail_type": "概念"}, {"head": "规则主体", "head_type": "概念", "relation": "英文名", "tail": "body", "tail_type": "概念"}]}
{"text": "原子（atom）是指包含了变量的元组，例如isLocation(X)是一个一元原子表示实体变量X是一个位置实体；hasWife(X,Y)是一个二元原子，表示实体变量X的妻子是实体变量Y。", "relation": [{"head": "原子", "head_type": "概念", "relation": "被定义为", "tail": "包含了变量的元组", "tail_type": "概念"}, {"head": "原子", "head_type": "概念", "relation": "英文名", "tail": "atom", "tail_type": "概念"}]}
{"text": "这条规则里的规则主体就包含了以否定形式出现的原子。", "relation": [{"head": "规则主体", "head_type": "概念", "relation": "包含", "tail": "以否定形式出现的原子", "tail_type": "概念"}]}
{"text": "这几种不同规则的包含关系如下：路径规则∈霍恩规则∈一般规则.即路径规则是霍恩规则的一个子集，而霍恩规则又是一般规则的一个子集，从规则的表达能力来看，一般规则的表达能力最强，包含各种不同的规则类型，而霍恩规则次之，规则路径的表达能力最弱，只能表达特定类型的规则。", "relation": [{"head": "路径规则", "head_type": "概念", "relation": "属于", "tail": "霍恩规则", "tail_type": "概念"}, {"head": "霍恩规则", "head_type": "概念", "relation": "属于", "tail": "一般规则", "tail_type": "概念"}]}
{"text": "对于一个规则rule，在知识图谱中，其支持度（support）指的是满足规则主体和规则头的实例个数，规则的实例化指的是将规则中的变量替换成知识图谱中真实的实体后的结果。", "relation": [{"head": "支持度", "head_type": "概念", "relation": "被定义为", "tail": "满足规则主体和规则头的实例个数", "tail_type": "概念"}, {"head": "规则的实例化", "head_type": "概念", "relation": "被定义为", "tail": "将规则中的变量替换成知识图谱中真实的实体后的结果", "tail_type": "概念"}]}
{"text": "规则头覆盖度（Head_Coverage）的计算方法为即规则支持度和满足规则头的实例个数的比值，即在满足规则头的实例中，同时也满足规则主体的实例比例。", "relation": [{"head": "规则头覆盖度的计算方法", "head_type": "概念", "relation": "被定义为", "tail": "规则支持度和满足规则头的实例个数的比值", "tail_type": "概念"}]}
{"text": "表示学习让算法在学习向量表示的过程中自动捕捉、推理所需的特征，通过训练学习，将知识图谱中离散符号表示的信息编码在不同的向量空间表示中，使得知识图谱的推理能够通过预设的向量空间表示之间的计算自动实现，不需要显式的推理步骤。", "relation": [{"head": "知识图谱中离散符号表示的信息", "head_type": "概念", "relation": "实现", "tail": "将知识图谱中离散符号表示的信息编码在不同的向量空间表示中", "tail_type": "概念"}, {"head": "表示学习", "head_type": "概念", "relation": "被定义为", "tail": "在学习向量表示的过程中自动捕捉、推理所需的特征", "tail_type": "概念"}]}
{"text": "TransE的简单高效说明了知识图谱表示学习方法能够自动且很好地捕捉推理特征，无须人工设计，很适合在大规模复杂的知识图谱上推广，是一种有效的知识图谱推理手段。", "relation": [{"head": "知识图谱表示学习方法", "head_type": "概念", "relation": "实现", "tail": "自动且很好地捕捉推理特征", "tail_type": "概念"}, {"head": "知识图谱表示学习方法", "head_type": "概念", "relation": "属于", "tail": "知识图谱推理手段", "tail_type": "概念"}]}
{"text": "实践证明，TransE由于其有效合理的向量空间假设，是一种简单高效的知识图谱表示学习方法，并且能够完成多种关系的链接预测任务。", "relation": [{"head": "TransE", "head_type": "概念", "relation": "属于", "tail": "知识图谱表示学习方法", "tail_type": "概念"},{"head": "TransE", "head_type": "概念", "relation": "实现", "tail": "多种关系的链接预测任务", "tail_type": "概念"}]}
{"text": "这说明了DistMult天然地假设了所有的关系是对称关系，这显然是不合理的。", "relation": [{"head": "DistMult", "head_type": "产品", "relation": "依靠", "tail": "假设所有的关系是对称关系", "tail_type": "概念"}]}
{"text": "传统的数据流学习主要是从连续和快速更新的数据记录中提取知识结构。", "relation": [{"head": "传统的数据流学习", "head_type": "概念", "relation": "被定义为", "tail": "从连续和快速更新的数据记录中提取知识结构", "tail_type": "概念"}]}
{"text": "具体而言，强化学习中智能体的状态被定义为当前节点实体和目标节点实体的联合表示.智能体的动作则是在当前节点实体的出边（Outgoing_edge）中选择一个适当的边作为组成路径的关系。", "relation": [{"head": "智能体的状态", "head_type": "概念", "relation": "被定义为", "tail": "当前节点实体和目标节点实体的联合表示", "tail_type": "概念"}, {"head": "智能体的动作", "head_type": "概念", "relation": "被定义为", "tail": "当前节点实体的出边（Outgoing_edge）中选择一个适当的边作为组成路径的关系", "tail_type": "概念"}]}
{"text": "元学习的目的是解决“学习如何学习”（Learning_to_Learn），旨在通过少量样本迅速完成学习，其相对主要的应用是少样本学习（Few-Shot_Learning）。", "relation": [{"head": "元学习的目的", "head_type": "概念", "relation": "研究", "tail": "“解决学习如何学习”（Learning_to_Learn）", "tail_type": "概念"}, {"head": "元学习", "head_type": "概念", "relation": "实现", "tail": "少样本学习（Few-Shot_Learning）", "tail_type": "概念"}]}
{"text": "Drools（JBoss_Rules）具有一个易于访问企业策略、易于调整以及易于管理的开源业务规则引擎，符合业内标准，具有速度快、效率高的特点。", "relation": [{"head": "Drools（JBoss_Rules）", "head_type": "产品", "relation": "属于", "tail": "开源业务规则引擎", "tail_type": "概念"}]}