{"text": "第6章知识图谱推理漆桂林东南大学，肖国辉博尔扎诺自由大学，陈华钧浙江大学知识图谱推理在一个知识图谱的发展演变过程中起着重要的作用，知识图谱推理能用来对知识图谱进行补全和质量检测等。", "relation": [{"head": "知识图谱推理", "head_type": "概念", "relation": "实现", "tail": "对知识图谱进行补全和质量检测", "tail_type": "概念"}]}
{"text": "推理的方法大致可以分为逻辑推理和非逻辑推理，其中逻辑推理的过程包含了严格的约束和推理过程，而非逻辑推理的过程相对模糊。", "relation": [{"head": "推理", "head_type": "概念", "relation": "包含", "tail": "逻辑推理", "tail_type": "概念"}, {"head": "推理", "head_type": "概念", "relation": "包含", "tail": "非逻辑推理", "tail_type": "概念"}, {"head": "逻辑推理", "head_type": "概念", "relation": "包含", "tail": "推理过程", "tail_type": "概念"}, {"head": "逻辑推理", "head_type": "概念", "relation": "包含", "tail": "严格的约束", "tail_type": "概念"}]}
{"text": "逻辑推理按照推理方式的不同包含两大类：演绎推理（Deductive_Reasoning）和归纳推理（Inductive_Reasoning）。", "relation": [{"head": "逻辑推理", "head_type": "概念", "relation": "包含", "tail": "归纳推理", "tail_type": "概念"}, {"head": "逻辑推理", "head_type": "概念", "relation": "包含", "tail": "演绎推理", "tail_type": "概念"}, {"head": "演绎推理", "head_type": "概念", "relation": "英文名", "tail": "Deductive_Reasoning", "tail_type": "概念"}, {"head": "归纳推理", "head_type": "概念", "relation": "英文名", "tail": "Inductive_Reasoning", "tail_type": "概念"}]}
{"text": "演绎推理[1]是一种自上而下（top-down_logic）的逻辑推理，是指在给定的一个或多个前提的情况下，推断出一个必然成立的结论的过程。", "relation": [{"head": "演绎推理", "head_type": "概念", "relation": "被定义为", "tail": "一种自上而下的逻辑推理", "tail_type": "概念"}, {"head": "演绎推理", "head_type": "概念", "relation": "被定义为", "tail": "在给定的一个或多个前提的情况下，推断出一个必然成立的结论的过程", "tail_type": "概念"}, {"head": "自上而下", "head_type": "概念", "relation": "英文名", "tail": "top-down_logic", "tail_type": "概念"}]}
{"text": "典型的演绎推理有肯定前件假言推理、否定后件假言推理（Modus_Tollens）以及三段论（Law_of_Syllogism）。", "relation": [{"head": "典型的演绎推理", "head_type": "概念", "relation": "包含", "tail": "肯定前件假言推理", "tail_type": "概念"}, {"head": "典型的演绎推理", "head_type": "概念", "relation": "包含", "tail": "否定后件假言推理", "tail_type": "概念"}, {"head": "典型的演绎推理", "head_type": "概念", "relation": "包含", "tail": "三段论", "tail_type": "概念"}, {"head": "否定后件假言推理", "head_type": "概念", "relation": "英文名", "tail": "Modus_Tollens", "tail_type": "概念"}, {"head": "三段论", "head_type": "概念", "relation": "英文名", "tail": "Law_of_Syllogism", "tail_type": "概念"}]}
{"text": "其中，肯定前件假言推理是指性质命题肯定了假言命题的前件，从而推理出肯定的假言后件。", "relation": [{"head": "肯定前件假言推理", "head_type": "概念", "relation": "被定义为", "tail": "性质命题肯定了假言命题的前件从而推理出肯定的假言后件", "tail_type": "概念"}]}
{"text": "而否定后件假言推理是指性质命题否定了假言命题的后件，从而推理出否定的假言前件。", "relation": [{"head": "否定后件假言推理", "head_type": "概念", "relation": "被定义为", "tail": "性质命题否定了假言命题的后件从而推理出否定的假言前件", "tail_type": "概念"}]}
{"text": "从以上的例子可以看出，演绎推理是一种形式化的逻辑推理。", "relation": [{"head": "演绎推理", "head_type": "概念", "relation": "被定义为", "tail": "一种形式化的逻辑推理", "tail_type": "概念"}]}
{"text": "归纳推理[2]是一种自下而上的推理，是指基于已有的部分观察得出一般结论的过程。", "relation": [{"head": "归纳推理", "head_type": "概念", "relation": "被定义为", "tail": "一种自下而上的推理", "tail_type": "概念"}, {"head": "归纳推理", "head_type": "", "relation": "被定义为", "tail": "基于已有的部分观察得出一般结论的过程", "tail_type": "概念"}]}
{"text": "典型的归纳推理有归纳泛化（Inductive_Generalization）、统计推理（Statistical_Syllogism）。","relation": [{"head": "典型的归纳推理", "head_type": "概念", "relation": "包含", "tail": "归纳泛化（Inductive_Generalization）", "tail_type": "概念"},{"head": "典型的归纳推理", "head_type": "概念", "relation": "包含", "tail": "统计推理（Statistical_Syllogism）", "tail_type": "概念"}, {"head": "归纳泛化", "head_type": "概念", "relation": "英文名", "tail": "Inductive_Generalization", "tail_type": "概念"}, {"head": "统计推理", "head_type": "概念", "relation": "英文名", "tail": "Statistical_Syllogism", "tail_type": "概念"}]}
{"text": "归纳泛化是指基于对个体的观察而得出可能适用于整体的结论，即在整体的一些样本中得到的结论可以泛化到整体上。", "relation": [{"head": "归纳泛化", "head_type": "概念", "relation": "被定义为", "tail": "基于对个体的观察而得出可能适用于整体的结论", "tail_type": "概念"}]}
{"text": "而统计推理是将整体的统计结论应用于个体。", "relation": [{"head": "统计推理", "head_type": "概念", "relation": "被定义为", "tail": "将整体的统计结论应用于个体", "tail_type": "概念"}]}
{"text": "归纳推理是一种非形式化的推理，是由具体到一般的推理过程。", "relation": [{"head": "归纳推理", "head_type": "概念", "relation": "被定义为", "tail": "非形式化的推理", "tail_type": "概念"}, {"head": "归纳推理", "head_type": "概念", "relation": "被定义为", "tail": "具体到一般的推理过程", "tail_type": "概念"}]}
{"text": "溯因推理[3]也是一种逻辑推理，是在给定一个或多个已有观察事实O（Observation），并根据已有的知识T（Theory）推断出对已有观察最简单且最有可能的解释的过程。", "relation": [{"head": "溯因推理", "head_type": "概念", "relation": "属于", "tail": "逻辑推理", "tail_type": "概念"},{"head": "溯因推理", "head_type": "概念", "relation": "被定义为", "tail": "在给定一个或多个已有观察事实O（Observation），并根据已有的知识T（Theory）推断出对已有观察最简单且最有可能的解释的过程。", "tail_type": "概念"}]}
{"text": "溯因推理是归纳推理的一种，因为整个推理过程的前提和结论并没有必然的关系。", "relation": [{"head": "溯因推理", "head_type": "概念", "relation": "属于", "tail": "归纳推理", "tail_type": "概念"}]}
{"text": "由于现实世界的知识千千万万，想要涵盖所有的知识是很难的，所以知识图谱的不完整性很明显，在对知识图谱进行补全的过程中，链接预测是一种典型的推理任务[8]。", "relation": [{"head": "链接预测", "head_type": "概念", "relation": "属于", "tail": "典型的推理任务", "tail_type": "概念"}]}
{"text": "本体的一般定义为概念化的显示规约，它给不同的领域提供共享的词汇。", "relation": [{"head": "本体", "head_type": "概念", "relation": "被定义为定义为", "tail": "概念化的显示规约", "tail_type": "概念"}]}
{"text": "OWL按表达能力从低到高划分成OWL_Lite、OWL_DL和OWL_Full。", "relation": [{"head": "OWL", "head_type": "概念", "relation": "包含", "tail": "OWL_Lite", "tail_type": "概念"}, {"head": "OWL", "head_type": "概念", "relation": "包含", "tail": "OWL_DL", "tail_type": "概念"}, {"head": "OWL", "head_type": "概念", "relation": "包含", "tail": "OWL_Full", "tail_type": "概念"}]}
{"text": "OWL_Lite和OWL_DL在语义上等价于某些描述逻辑（Description_Logics,DLs）[14,15]，而OWL_Full没有对应的描述逻辑。", "relation": [{"head": "OWL_Lite", "head_type": "概念", "relation": "等价", "tail": "某些描述逻辑", "tail_type": "概念"}, {"head": "OWL_DL", "head_type": "概念", "relation": "等价", "tail": "某些描述逻辑", "tail_type": "概念"}, {"head": "描述逻辑", "head_type": "概念", "relation": "英文名", "tail": "Description_Logics,DLs", "tail_type": "概念"}]}
{"text": "目前，OWL是知识图谱语言中最规范、最严谨、表达能力最强的语言，而且OWL基于RDF语法，使表示出来的文档具有语义理解的结构基础，OWL的另外一个作用是促进了统一词汇表的使用，定义了丰富的语义词汇。", "relation": [{"head": "OWL", "head_type": "概念", "relation": "等价", "tail": "知识图谱语言中最规范、最严谨、表达能力最强的语言", "tail_type": "概念"}, {"head": "OWL", "head_type": "概念", "relation": "依靠", "tail": "RDF语法", "tail_type": "概念"}, {"head": "OWL", "head_type": "概念", "relation": "实现", "tail": "统一词汇表的使用", "tail_type": "概念"}, {"head": "OWL", "head_type": "概念", "relation": "实现", "tail": "丰富的语义词汇", "tail_type": "概念"}]}
{"text": "FaCT++是曼彻斯特大学开发的描述逻辑推理机，使用C++实现，且能与Protégé集成。", "relation": [{"head": "FaCT++", "head_type": "产品", "relation": "属于", "tail": "描述逻辑推理机", "tail_type": "概念"}, {"head": "FaCT++", "head_type": "产品", "relation": "依靠", "tail": "C++实现", "tail_type": "概念"}]}
{"text": "Prolog在早期的人工智能研究中应用广泛，多用于实现专家系统。", "relation": [{"head": "Prolog", "head_type": "产品", "relation": "实现", "tail": "专家系统", "tail_type": "概念"}]}
{"text": "在通常情况下，Prolog程序是通过SLD消解和回溯来执行的[25]。", "relation": [{"head": "Prolog程序", "head_type": "产品", "relation": "依靠", "tail": "SLD消解和回溯", "tail_type": "概念"}]}
{"text": "运行结果依赖对规则内部的原子顺序和规则之间的顺序，因此不是完全的声明式的（declarative）。", "relation": [{"head": "运行结果", "head_type": "概念", "relation": "依靠", "tail": "规则内部的原子顺序和规则之间的顺序", "tail_type": "概念"}]}
{"text": "从语法上来说，Datalog程序基本上是Prolog的一个子集。", "relation": [{"head": "Datalog程序", "head_type": "产品", "relation": "属于", "tail": "Prolog的一个子集", "tail_type": "概念"}]}
{"text": "它们的主要区别是在语义层面，Datalog基于完全声明式的模型论的语义，并保证可终止性。", "relation": [{"head": "Datalog", "head_type": "产品", "relation": "依靠", "tail": "完全声明式的模型论的语义", "tail_type": "概念"}, {"head": "Datalog", "head_type": "产品", "relation": "实现", "tail": "可终止性", "tail_type": "概念"}]}
{"text": "OWL_RL的设计目标之一就是找出可以用规则推理来实现的一个OWL的片段。", "relation": [{"head": "OWL_RL", "head_type": "概念", "relation": "研究", "tail": "找出可以用规则推理来实现的一个OWL的片段", "tail_type": "概念"}]}
{"text": "变量用大写字母X、Y、Z表示，有时也会用问号（?）开头，例如?x、?y。", "relation": [{"head": "变量", "head_type": "概念", "relation": "依靠", "tail": "大写字母X、Y、Z表示", "tail_type": "概念"}]}
{"text": "Datalog事实（fact）是形如F(c1,c2,…,cn):-的没有体部且没有变量的规则。", "relation": [{"head": "Datalog事实（fact）", "head_type": "概念", "relation": "被定义为", "tail": "形如F(c1,c2,…,cn):-的没有体部且没有变量的规则", "tail_type": "概念"}]}
{"text": "一个知识图谱可以自然地被看作一个事实集。", "relation": [{"head": "知识图谱", "head_type": "概念", "relation": "属于", "tail": "一个事实集", "tail_type": "概念"}]}
{"text": "SWRL是2004年提出的一个完全基于Datalog的规则语言。", "relation": [{"head": "SWRL", "head_type": "概念", "relation": "等价", "tail": "2004年提出的一个完全基于Datalog的规则语言", "tail_type": "概念"}]}
{"text": "OWL_RL是W3C定义的OWL_2的一个子语言，其设计目标为可以直接转换成Datalog程序，从而使用现有的Datalog推理机推理。", "relation": [{"head": "OWL_RL", "head_type": "概念", "relation": "属于", "tail": "W3C定义的OWL_2的一个子语言", "tail_type": "概念"}, {"head": "设计目标", "head_type": "概念", "relation": "实现", "tail": "直接转换成Datalog程序", "tail_type": "概念"}]}
{"text": "RDFox的输入包括本体（TBox）、数据（ABox）和一个自定义规则集。", "relation": [{"head": "RDFox的输入", "head_type": "概念", "relation": "包含", "tail": "本体（TBox）]", "tail_type": "概念"}, {"head": "RDFox的输入", "head_type": "概念", "relation": "包含", "tail": "数据（ABox）", "tail_type": "概念"}, {"head": "RDFox的输入", "head_type": "概念", "relation": "包含", "tail": "一个自定义规则集", "tail_type": "概念"}, {"head": "本体", "head_type": "概念", "relation": "英文名", "tail": "TBox", "tail_type": "概念"}, {"head": "数据", "head_type": "概念", "relation": "英文名", "tail": "ABox", "tail_type": "概念"}]}
{"text": "第一种情况直接在知识图谱之上的查询称为本体介导的查询回答（Ontology-Mediated_Query_Answering,OMQ）[27]。", "relation": [{"head": "直接在知识图谱之上的查询", "head_type": "概念", "relation": "被定义为", "tail": "本体介导的查询回答", "tail_type": ""}, {"head": "本体介导的查询回答", "head_type": "概念", "relation": "英文名", "tail": "Ontology-Mediated_Query_Answering,OMQ", "tail_type": "概念"}]}
{"text": "1.OBDA框架包含外延（extensional）和内涵（intensional）两个部分。", "relation": [{"head": "OBDA框架", "head_type": "概念", "relation": "包含", "tail": "外延（extensional）和内涵（intensional）两个部分", "tail_type": "概念"}, {"head": "外延", "head_type": "概念", "relation": "英文名", "tail": "extensional", "tail_type": "概念"}, {"head": "内涵", "head_type": "概念", "relation": "英文名", "tail": "intensional", "tail_type": "概念"}]}
{"text": "外延层为符合某个数据库架构（schema）S的一个源数据库D，S通常包括数据库表的定义和完整性约束。", "relation": [{"head": "外延层", "head_type": "概念", "relation": "等价", "tail": "符合某个数据库架构（schema）S的一个源数据库D", "tail_type": "概念"}, {"head": "S", "head_type": "概念", "relation": "包含", "tail": "数据库表的定义", "tail_type": "概念"}, {"head": "S", "head_type": "概念", "relation": "包含", "tail": "完整性约束", "tail_type": "概念"}]}
{"text": "OBDA的主要推理任务为查询", "relation": [{"head": "OBDA的主要推理任务", "head_type": "概念", "relation": "研究", "tail": "查询", "tail_type": "概念"}]}
{"text": "OBDA有多种实现方式，最直接的方式是生成映射得到的知识图谱M(D)，然后保存到一个三元组存储库中，这种方式也称作ETL（Extract_Transform_Load)，优点是实现简单直接。", "relation": [{"head": "OBDA实现方式", "head_type": "概念", "relation": "等价", "tail": "生成映射得到的知识图谱M(D)", "tail_type": "概念"}]}
{"text": "Mastro最初是由意大利罗马大学开发的OBDA系统，现在由OBDA_Systems商业化运行。", "relation": [{"head": "Mastro", "head_type": "产品", "relation": "源于", "tail": "意大利罗马大学", "tail_type": "概念"}, {"head": "Mastro", "head_type": "产品", "relation": "属于", "tail": "OBDA系统", "tail_type": "概念"}]}
{"text": "Stardog原本是由Stardog_Union开发的商业化的Triple存储工具。", "relation": [{"head": "Stardog", "head_type": "产品", "relation": "属于", "tail": "商业化的Triple存储工具", "tail_type": "概念"}]}
{"text": "一个产生式系统由事实集合、产生式集合和推理引擎三部分组成。", "relation": [{"head": "产生式系统", "head_type": "概念", "relation": "包含", "tail": "事实集合", "tail_type": "概念"},{"head": "产生式系统", "head_type": "概念", "relation": "包含", "tail": "产生式集合", "tail_type": "概念"},{"head": "产生式系统", "head_type": "概念", "relation": "包含", "tail": "推理引擎", "tail_type": "概念"}]}
{"text": "事实集合是运行内存（Working_Memory,WM）为事实（WME）的集合，用于存储当前系统中的所有事实。", "relation": [{"head": "事实集合", "head_type": "概念", "relation": "等价", "tail": "运行内存（Working_Memory,WM）为事实（WME）的集合", "tail_type": "概念"}, {"head": "事实集合", "head_type": "概念", "relation": "实现", "tail": "存储当前系统中的所有事实", "tail_type": "概念"}]}
{"text": "推理引擎用于控制系统的执行。", "relation": [{"head": "推理引擎", "head_type": "概念", "relation": "实现", "tail": "控制系统的执行", "tail_type": "概念"}]}
{"text": "目前，最流行的算法是Rete算法，在1979年由Charles_Forgy提出[42]。", "relation": [{"head": "Rete算法", "head_type": "概念", "relation": "属于", "tail": "最流行的算法", "tail_type": "概念"}, {"head": "Charles_Forgy", "head_type": "概念", "relation": "研究", "tail": "Rete算法", "tail_type": "概念"}]}
{"text": "Jena是一个用于构建语义网应用的Java框架。", "relation": [{"head": "Jena", "head_type": "产品", "relation": "属于", "tail": "Java框架", "tail_type": "概念"}, {"head": "Jena", "head_type": "概念", "relation": "实现", "tail": "语义网应用", "tail_type": "概念"}]}
{"text": "按照推理要素的不同，基于归纳的知识图谱推理可以分为以下几类：基于图结构的推理、基于规则学习的推理和基于表示学习的推理。", "relation": [{"head": "基于图结构的推理", "head_type": "概念", "relation": "属于", "tail": "基于归纳的知识图谱推理", "tail_type": "概念"}, {"head": "基于规则学习的推理", "head_type": "概念", "relation": "属于", "tail": "基于归纳的知识图谱推理", "tail_type": "概念"}, {"head": "基于表示学习的推理", "head_type": "概念", "relation": "属于", "tail": "基于归纳的知识图谱推理", "tail_type": "概念"}]}
{"text": "这说明了路径是一种重要的进行关系推理的信息，也是一种重要的图结构。", "relation": [{"head": "路径", "head_type": "概念", "relation": "等价", "tail": "一种重要的进行关系推理的信息", "tail_type": "概念"}, {"head": "路径", "head_type": "概念", "relation": "属于", "tail": "重要的图结构", "tail_type": "概念"}]}
{"text": "结合了有效采样和随机有走的PRA能够快速有效地利用知识图谱的路径结构对知识图谱进行关系推理，是典型的基于图结构的知识图谱推理算法。", "relation": [{"head": "PRA", "head_type": "概念", "relation": "依靠", "tail": "有效采样和随机有走", "tail_type": "概念"}, {"head": "PRA", "head_type": "概念", "relation": "实现", "tail": "快速有效地利用知识图谱的路径结构对知识图谱进行关系推理", "tail_type": "概念"}, {"head": "PRA", "head_type": "概念", "relation": "属于", "tail": "典型的基于图结构的知识图谱推理算法", "tail_type": "概念"}]}
{"text": "尽管采用了随机游走策略来降低搜索空间，当PRA应用在关系丰富且连接稠密的知识图谱上时，依然会面临路径特征爆炸的问题。", "relation": [{"head": "PRA", "head_type": "概念", "relation": "研究", "tail": "路径特征爆炸的问题", "tail_type": "概念"}]}
{"text": "SFE同时还利用了关系的向量表示，通过训练好的关系的表示，将已有路径特征中的关系替换为向量空间中比较相似的关系。", "relation": [{"head": "SFE", "head_type": "概念", "relation": "依靠", "tail": "关系的向量表示", "tail_type": "概念"}]}
{"text": "SFE还增加了一个表示任意关系的关系ANYREL来增加路径特征的丰富性。", "relation": [{"head": "SFE", "head_type": "概念", "relation": "实现", "tail": "增加表示任意关系的关系ANYREL", "tail_type": "概念"}]}
{"text": "规则是基于规则推理的核心，所以规则获取是一个重要的任务。", "relation": [{"head": "规则", "head_type": "概念", "relation": "等价", "tail": "基于规则推理的核心", "tail_type": "概念"}, {"head": "规则获取", "head_type": "概念", "relation": "等价", "tail": "一个重要的任务", "tail_type": "概念"}]}
{"text": "所以，自动化的规则学习方法应运而生，旨在快速有效地从大规模知识图谱上学习置信度较高的规则，并服务于关系推理任务。", "relation": [{"head": "自动化的规则学习方法", "head_type": "概念", "relation": "实现", "tail": "快速有效地从大规模知识图谱上学习置信度较高的规则", "tail_type": "概念"}, {"head": "自动化的规则学习方法", "head_type": "概念", "relation": "实现", "tail": "关系推理任务", "tail_type": "概念"}]}
{"text": "其中，规则头由一个二元的原子（atom）构成，而规则主体由一个或多个一元原子或二元原子组成。", "relation": [{"head": "一个二元的原子（atom）", "head_type": "概念", "relation": "属于", "tail": "规则头", "tail_type": "概念"}, {"head": "一个或多个一元原子或二元原子", "head_type": "概念", "relation": "属于", "tail": "规则主体", "tail_type": "概念"}]}
{"text": "规则一般包含了两个部分，分别为规则头（head）和规则主体（body），其一般形式为rule:head←body.解读为有规则主体的信息可推出规则头的信息。", "relation": [{"head": "规则", "head_type": "概念", "relation": "包含", "tail": "规则头（head）", "tail_type": "概念"},{"head": "规则", "head_type": "概念", "relation": "包含", "tail": "规则主体（body）", "tail_type": "概念"}, {"head": "规则", "head_type": "概念", "relation": "被定义为", "tail": "rule:head←body", "tail_type": "概念"}, {"head": "规则头", "head_type": "概念", "relation": "英文名", "tail": "head", "tail_type": "概念"}, {"head": "规则主体", "head_type": "概念", "relation": "英文名", "tail": "body", "tail_type": "概念"}]}
{"text": "原子（atom）是指包含了变量的元组，例如isLocation(X)是一个一元原子表示实体变量X是一个位置实体；hasWife(X,Y)是一个二元原子，表示实体变量X的妻子是实体变量Y。", "relation": [{"head": "原子", "head_type": "概念", "relation": "被定义为", "tail": "包含了变量的元组", "tail_type": "概念"}, {"head": "原子", "head_type": "概念", "relation": "英文名", "tail": "atom", "tail_type": "概念"}]}
{"text": "这条规则里的规则主体就包含了以否定形式出现的原子。", "relation": [{"head": "规则主体", "head_type": "概念", "relation": "包含", "tail": "以否定形式出现的原子", "tail_type": "概念"}]}
{"text": "这几种不同规则的包含关系如下：路径规则∈霍恩规则∈一般规则.即路径规则是霍恩规则的一个子集，而霍恩规则又是一般规则的一个子集，从规则的表达能力来看，一般规则的表达能力最强，包含各种不同的规则类型，而霍恩规则次之，规则路径的表达能力最弱，只能表达特定类型的规则。", "relation": [{"head": "路径规则", "head_type": "概念", "relation": "属于", "tail": "霍恩规则", "tail_type": "概念"}, {"head": "霍恩规则", "head_type": "概念", "relation": "属于", "tail": "一般规则", "tail_type": "概念"}]}
{"text": "对于一个规则rule，在知识图谱中，其支持度（support）指的是满足规则主体和规则头的实例个数，规则的实例化指的是将规则中的变量替换成知识图谱中真实的实体后的结果。", "relation": [{"head": "支持度", "head_type": "概念", "relation": "等价", "tail": "满足规则主体和规则头的实例个数", "tail_type": "概念"}, {"head": "规则的实例化", "head_type": "概念", "relation": "等价", "tail": "将规则中的变量替换成知识图谱中真实的实体后的结果", "tail_type": "概念"}]}
{"text": "由于知识图谱往往具有明显的不完整性，而前文介绍的规则置信度计算方法间接假设了不存在知识图谱中的三元组是错误的，这显然是不合理的。", "relation": [{"head": "规则置信度计算方法", "head_type": "概念", "relation": "依靠", "tail": "假设不存在知识图谱中的三元组是错误的", "tail_type": "概念"}]}
{"text": "规则头覆盖度（Head_Coverage）的计算方法为即规则支持度和满足规则头的实例个数的比值，即在满足规则头的实例中，同时也满足规则主体的实例比例。", "relation": [{"head": "规则头覆盖度的计算方法", "head_type": "概念", "relation": "等价", "tail": "规则支持度和满足规则头的实例个数的比值", "tail_type": "概念"}]}
{"text": "规则的支持度、置信度以及头覆盖度从不同的角度反映了规则的质量，但三者之间没有必然的关联关系。", "relation": [{"head": "规则的支持度", "head_type": "概念", "relation": "实现", "tail": "规则的质量", "tail_type": "概念"}, {"head": "规则的置信度", "head_type": "概念", "relation": "实现", "tail": "规则的质量", "tail_type": "概念"}, {"head": "头覆盖度", "head_type": "概念", "relation": "实现", "tail": "规则的质量", "tail_type": "概念"}]}
{"text": "即在规则中增加一个原子，这个原子包含一个新的变量和一个已经在规则中出现的元素，可以是出现过的变量，也可以是出现过的实体。", "relation": [{"head": "已经在规则中出现的元素", "head_type": "概念", "relation": "包含", "tail": "出现过的变量", "tail_type": "概念"}, {"head": "已经在规则中出现的元素", "head_type": "概念", "relation": "包含", "tail": "出现过的实体", "tail_type": "概念"}]}
{"text": "无论采用哪种挖掘算子来增加规则中的原子，每一个原子都伴随着需要选择一个知识图谱中的关系。", "relation": [{"head": "每一个原子", "head_type": "概念", "relation": "依靠", "tail": "选择一个知识图谱中的关系", "tail_type": "概念"}]}
{"text": "表示学习让算法在学习向量表示的过程中自动捕捉、推理所需的特征，通过训练学习，将知识图谱中离散符号表示的信息编码在不同的向量空间表示中，使得知识图谱的推理能够通过预设的向量空间表示之间的计算自动实现，不需要显式的推理步骤。", "relation": [{"head": "知识图谱中离散符号表示的信息", "head_type": "概念", "relation": "实现", "tail": "编码在不同的向量空间表示中", "tail_type": "概念"}, {"head": "表示学习", "head_type": "概念", "relation": "实现", "tail": "不需要显式的推理步骤", "tail_type": "概念"}]}
{"text": "TransE的训练目标是最小化损失函数L，可以通过基于梯度的优化算法进行优化求解，直至训练收敛。", "relation": [{"head": "TransE", "head_type": "产品", "relation": "实现", "tail": "最小化损失函数L", "tail_type": "概念"}, {"head": "基于梯度的优化算法", "head_type": "概念", "relation": "实现", "tail": "优化求解", "tail_type": "概念"}]}
{"text": "TransE的简单高效说明了知识图谱表示学习方法能够自动且很好地捕捉推理特征，无须人工设计，很适合在大规模复杂的知识图谱上推广，是一种有效的知识图谱推理手段。", "relation": [{"head": "TransE", "head_type": "产品", "relation": "实现", "tail": "知识图谱表示学习方法能够自动且很好地捕捉推理特征", "tail_type": "概念"}, {"head": "知识图谱表示学习方法", "head_type": "概念", "relation": "实现", "tail": "自动且很好地捕捉推理特征", "tail_type": "概念"}, {"head": "知识图谱表示学习方法", "head_type": "概念", "relation": "实现", "tail": "无须人工设计", "tail_type": "概念"}, {"head": "知识图谱表示学习方法", "head_type": "概念", "relation": "属于", "tail": "有效的知识图谱推理手段", "tail_type": "概念"}]}
{"text": "实践证明，TransE由于其有效合理的向量空间假设，是一种简单高效的知识图谱表示学习方法，并且能够完成多种关系的链接预测任务。", "relation": [{"head": "TransE", "head_type": "产品", "relation": "被定义为", "tail": "一种简单高效的知识图谱表示学习方法", "tail_type": "概念"},{"head": "TransE", "head_type": "产品", "relation": "实现", "tail": "多种关系的链接预测任务", "tail_type": "概念"}]}
{"text": "所以，训练目标是对正确的三元组让hMr与t尽可能接近，而错误的三元组尽可能远离。", "relation": [{"head": "训练目标", "head_type": "概念", "relation": "实现", "tail": "正确的三元组让hMr与t尽可能接近，而错误的三元组尽可能远离", "tail_type": "概念"}]}
{"text": "这说明了DistMult天然地假设了所有的关系是对称关系，这显然是不合理的。", "relation": [{"head": "DistMult", "head_type": "产品", "relation": "依靠", "tail": "假设所有的关系是对称关系", "tail_type": "概念"}]}
{"text": "传统的数据流学习主要是从连续和快速更新的数据记录中提取知识结构。", "relation": [{"head": "传统的数据流学习", "head_type": "概念", "relation": "等价", "tail": "从连续和快速更新的数据记录中提取知识结构", "tail_type": "概念"}]}
{"text": "具体而言，强化学习中智能体的状态被定义为当前节点实体和目标节点实体的联合表示st=（et,etarget−et）.智能体的动作则是在当前节点实体的出边（Outgoing_edge）中选择一个适当的边作为组成路径的关系。", "relation": [{"head": "智能体的状态", "head_type": "概念", "relation": "被定义为", "tail": "当前节点实体和目标节点实体的联合表示st=（et,etarget−et）", "tail_type": "概念"}, {"head": "智能体的动作", "head_type": "概念", "relation": "等价", "tail": "当前节点实体的出边（Outgoing_edge）中选择一个适当的边作为组成路径的关系", "tail_type": "概念"}]}
{"text": "在这类知识图谱推理问题中，需要尽可能避免遍历大规模知识图谱，影响算法的效率。", "relation": [{"head": "这类知识图谱推理问题", "head_type": "概念", "relation": "依靠", "tail": "避免遍历大规模知识图谱", "tail_type": "概念"}]}
{"text": "元学习的目的是解决“学习如何学习”（Learning_to_Learn），旨在通过少量样本迅速完成学习，其相对主要的应用是少样本学习（Few-Shot_Learning）。", "relation": [{"head": "元学习的目的", "head_type": "概念", "relation": "等价", "tail": "“解决学习如何学习”（Learning_to_Learn）", "tail_type": "概念"}, {"head": "元学习的应用", "head_type": "概念", "relation": "等价", "tail": "少样本学习（Few-Shot_Learning）", "tail_type": "概念"}]}
{"text": "Drools（JBoss_Rules）具有一个易于访问企业策略、易于调整以及易于管理的开源业务规则引擎，符合业内标准，具有速度快、效率高的特点。", "relation": [{"head": "Drools（JBoss_Rules）", "head_type": "产品", "relation": "实现", "tail": "易于访问企业策略、易于调整以及易于管理的开源业务规则引擎", "tail_type": "概念"},
{"head": "Drools（JBoss_Rules）", "head_type": "产品", "relation": "实现", "tail": "速度快、效率高", "tail_type": "概念"}]}
{"text": "规则并不能被直接调用，因为它们不是方法或函数，规则的激发是对Working_Memory中数据变化的响应。", "relation": [{"head": "规则的激发", "head_type": "概念", "relation": "等价", "tail": "对Working_Memory中数据变化的响应", "tail_type": "概念"}]}
{"text": "3.构建本体Model是Jena最核心的数据结构，其本质上就是Jena中的知识库结构，即本体。", "relation": [{"head": "构建本体Model", "head_type": "概念", "relation": "等价", "tail": "Jena最核心的数据结构", "tail_type": "概念"}, {"head": "构建本体Model", "head_type": "概念", "relation": "等价", "tail": "Jena中的知识库结构", "tail_type": "概念"}]}