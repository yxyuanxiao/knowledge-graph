{"text": "第3章知识存储王鑫天津大学随着知识图谱规模的日益增长，数据管理愈加重要。"}
{"text": "一方面，以文件形式保存的知识图谱显然无法满足用户的查询、检索、推理、分析及各种应用需求；另一方面，传统数据库的关系模型与知识图谱的图模型之间存在显著差异，关系数据库无法有效地管理大规模知识图谱数据。"}
{"text": "为了更好地进行三元组数据的存储，语义万维网领域发展出专门存储RDF数据的三元组库；数据库领域发展出用于管理属性图的图数据库。"}
{"text": "虽然目前没有一种数据库系统被公认为具有主导地位的知识图谱数据库，但可以预见，随着三元组库和图数据库的相互融合发展，知识图谱的存储和数据管理手段将愈加丰富和强大。"}
{"text": "本章首先介绍图数据模型和图查询语言等基本知识；以演示操作的方式讲解各种主流知识图谱数据库，包括基于关系数据库的存储方案、面向RDF的三元组数据库和原生图数据库；以图数据库Neo4j为例介绍图模型数据的底层存储细节，同时梳理图数据索引和查询处理等关键技术；最后，以ApacheJena为例，针对知识图谱数据库开源工具进行实践。"}
{"text": "3.1知识图谱数据库基本知识本节首先介绍目前表示知识图谱的两种主要图数据模型：RDF图和属性图。"}
{"text": "3.1.1知识图谱数据模型从数据模型角度来看，知识图谱本质上是一种图数据。"}
{"text": "不同领域的知识图谱均须遵循相应的数据模型。"}
{"text": "往往一个数据模型的生命力要看其数学基础的强弱，关系模型长盛不衰的一个重要原因是其数学基础为关系代数。"}
{"text": "知识图谱数据模型的数学基础源于有着近300年历史的数学分支——图论。"}
{"text": "在图论中，图是二元组G=（V,E），其中V是节点集合，E是边集合。"}
{"text": "知识图谱数据模型基于图论中图的定义，用节点集合表示实体，用边集合表示实体间的联系，这种一般和通用的数据表示恰好能够自然地刻画现实世界中事物的广泛联系。"}
{"text": "1.RDF图RDF是W3C制定的在语义万维网上表示和交换机器可理解信息的标准数据模型[1]。"}
{"text": "在RDF三元组集合中，每个Web资源具有一个HTTPURI作为其唯一的id；一个RDF图定义为三元组(s,p,o)的有限集合；每个三元组代表一个陈述句，其中s是主语，p是谓语，o是宾语；(s,p,o)表示资源s与资源o之间具有联系p，或表示资源s具有属性p且其取值为o。"}
{"text": "实际上，RDF三元组集合即为图中的有向边集合。"}
{"text": "如图3-1所示，是一个虚构的软件开发公司的社会网络图，其中有张三、李四、王五和赵六4名程序员，有“图数据库”和“RDF三元组库”2个项目；张三认识李四和王五；张三、王五和赵六参加“图数据库”的开发，该项目使用Java语言；王五参加“RDF三元组库”的开发，该项目使用C++语言。"}
{"text": "图3-1RDF图示例值得注意的是，RDF图对于节点和边上的属性没有内置的支持。"}
{"text": "节点属性可用三元组表示，这类三元组的宾语称为字面量，即图中的矩形。"}
{"text": "边上的属性表示起来稍显烦琐，最常见的是利用RDF中一种叫作“具体化”（reification）的技术[2]，需要引入额外的点表示整个三元组，将边属性表示为以该节点为主语的三元组。"}
{"text": "例如在图3-2中，引入节点ex:participate代表三元组(ex:zhangsan，参加，ex:graphdb)，该节点通过RDF内置属性rdf:subject、rdf:predicate和rdf:object分别与代表的三元组的主语、谓语和宾语建立起联系，这样三元组(ex:participate，权重，0.4)就实现了为原三元组增加边属性的效果。"}
{"text": "图3-2RDF图中边属性的表示2.属性图属性图可以说是目前被图数据库业界采纳最广的一种图数据模型[3]。"}
{"text": "属性图由节点集和边集组成，且满足如下性质：（1）每个节点具有唯一的id；（2）每个节点具有若干条出边；（3）每个节点具有若干条入边；（4）每个节点具有一组属性，每个属性是一个键值对；（5）每条边具有唯一的id；（6）每条边具有一个头节点；（7）每条边具有一个尾节点；（8）每条边具有一个标签，表示联系；（9）每条边具有一组属性，每个属性是一个键值对。"}
{"text": "图3-3给出的属性图不仅表达了RDF图的全部数据，而且还增加了边上的“权重”属性。"}
{"text": "图3-3属性图示例图3-3的每个节点和每条边均有id。"}
{"text": "遵照属性图的要素，节点4的出边集合为{边10,边11}，入边集合为{边8}，属性集合为{姓名=\"王五\"，年龄=32}；边11的头节点是节点3，尾节点是节点4，标签是“参加”，属性集合为{权重=0.4}。"}
{"text": "3.1.2知识图谱查询语言在知识图谱数据模型上，需要借助知识图谱查询语言进行查询操作。"}
{"text": "目前，RDF图上的查询语言是SPARQL；属性图上的查询语言常用的是Cypher和Gremlin。"}
{"text": "1.SPARQLSPARQL是W3C制定的RDF图数据的标准查询语言[4]。"}
{"text": "SPARQL从语法上借鉴了SQL，同样属于声明式查询语言。"}
{"text": "最新的SPARQL1.1版本为有效查询RDF图专门设计了三元组模式、子图模式、属性路径等多种查询机制。"}
{"text": "几乎全部的RDF三元组数据库都实现了SPARQL语言。"}
{"text": "下面通过几个例子介绍SPARQL语言的基本功能。"}
{"text": "查询使用的是RDF图数据。"}
{"text": "（1）查询程序员张三认识的其他程序员输出：说明：PREFIX关键字将ex定义为URI“http://www.example.com/”的前缀缩写，WHERE关键字指明了查询的三元组模式（Triple_Pattern）,SELECT关键字列出了要返回的结果变量。"}
{"text": "三元组模式查询是最基本的SPARQL查询。"}
{"text": "（2）查询程序员张三认识的其他程序员参加的项目输出：说明：这是由两个三元组模式组成的一个基本图模式（Basic_Graph_Pattern）查询，简称为BGP查询。"}
{"text": "实际上，这两个三元组模式之间通过公共变量？p连接为一个链式查询。"}
{"text": "（3）查询节点ex:zhangsan认识的30岁以上的程序员参加的项目名称输出：说明：关键字FILTER用于指明过滤条件，对变量匹配结果进行按条件筛选。"}
{"text": "这里既有？p和？pr分别作为两个三元组模式的宾语和主语连接起来的链式模式，也有？p作为两个三元组模式的主语连接起来的星形结构，该查询是一个更加一般的BGP查询。"}
{"text": "实际上，BGP查询相当于一个带有变量的查询图，查询过程是在数据图中寻找与查询图映射Isomorphism）或子图同态匹配的所有子图，等价于图论中的子图同构（Subgraph（Subgraph_Homomorphism）问题[5]，所以也将BGP查询称为子图匹配查询。"}
{"text": "（4）查询年龄为29的参加了项目ex:graphdb的程序员参加的其他项目及其直接或间接认识的程序员参加的项目输出：说明：这里使用了Path）机制，ex:knows*/ex:participate类似于正则表达式，其表示经过0条、1条或多条ex:knows边，再经过一条ex:participate边。"}
{"text": "1.1引入的属性路径（Property_SPARQL_SPARQL实际上是一整套知识服务标准体系。"}
{"text": "SPARQL1.1语言的语法和语义的完整定义请参见W3C的推荐标准“SPARQL1.1查询语言”[4]，该标准连同其他10个推荐标准共同组成了SPARQL知识平台，包括查询[4]、更新[6]、服务描述[7]、联邦查询[8]、查询结果格式[9]、蕴涵推理[10]和接口协议[11]等。"}
{"text": "开放的SPARQL学习教程有WikiBooks_SPARQL教程[12]、WikidataSPARQL教程[13]和Apache_Jena_SPARQL教程[14]等。"}
{"text": "本章3.4节将以Apache_Jena作为实践工具，讲解如何使用SPARQL进行知识图谱的查询和更新。"}
{"text": "2.CypherCypher最初是图数据库Neo4j中实现的属性图数据查询语言[15]。"}
{"text": "与SPARQL一样，Cypher也是一种声明式语言，即用户只需要声明“查什么”，而无须关心“怎么查”，这就好比乘坐出租车到一个目的地，只需要告诉司机要到哪里，具体的行车路线可由司机安排，乘客并不需要关心。"}
{"text": "这类语言的优点是便于用户学习掌握，同时给予数据库进行查询优化的空间，缺点是不能满足高级用户导航式查询的要求，数据库规划的查询执行计划有可能并不是最优方案。"}
{"text": "2015年，Neo4j公司发起开源项目openCypher[16]，旨在对Cypher进行标准化工作，为其他实现者提供语法和语义的参考标准。"}
{"text": "虽然Cypher的发展目前仍由Neo4j主导，但包括SAP_HANA_Graph[17]、Redis_Graph[18]、AgensGraph[19]和Memgraph[20]等在内的图数据库产品已经实现了Cypher。"}
{"text": "下面通过例子了解Cypher语言的基本功能。"}
{"text": "使用的知识图谱是图3-3中的属性图。"}
{"text": "（1）查询图中的所有程序员节点输出：说明：MATCH关键字指明需要匹配的模式，这里将节点分为了程序员和项目两类，p作为查询变量会依次绑定到每个类型为Programmer的节点，RETURN关键字返回变量p的值作为查询结果。"}
{"text": "（2）查询程序员与“图数据库”项目之间的边输出：说明：此查询返回边及其属性，程序员类型节点与图数据库项目节点之前存在3条标签为参加的边。"}
{"text": "（3）查询从节点1出发的标签为“认识”的边输出：说明：从节点1出发沿“认识”边到达节点2和节点4。"}
{"text": "（4）查询节点1认识的30岁以上的程序员参加的项目名称输出：说明：该查询MATCH子句等价于SPARQLBGP查询的链式查询。"}
{"text": "（5）查询年龄为29的参加了项目3的程序员参加的其他项目及其直接或间接认识的程序员参加的项目输出：说明：“：认识*0..”表示由一个节点到达另一个节点的路径包括0个、1个或多个“认识”边。"}
{"text": "对比该查询的SPARQL版本。"}
{"text": "3.GremlinGremlin是Apache_TinkerPop图计算框架[21]提供的属性图查询语言[22]。"}
{"text": "ApacheTinkerPop被设计为访问图数据库的通用API接口，其作用类似于关系数据库上的JDBC接口。"}
{"text": "Gremlin的定位是图遍历语言，其执行机制好比是一个人置身于图中沿着有向边，从一个节点到另一个节点进行导航式的游走。"}
{"text": "这种执行方式决定了用户使用Gremlin需要指明具体的导航步骤，这和自己驾驶汽车到一个目的地需要知道行车路线是一个道理，所以将Gremlin归为过程式语言，即需要明确“怎么做”。"}
{"text": "这类语言的优点是可以时刻知道自己在图中所处的位置，以及是如何到达该位置的；缺点是用户需要“认识路”！与受到SQL影响的声明式语言SPARQL和Cypher不同，Gremlin更像一种函数式的编程语言接口。"}
{"text": "下面通过几个例子认识Gremlin语言，假设用g代表图3-3中的属性图。"}
{"text": "（1）列出图中所有节点的属性输出：说明：V表示节点集合。"}
{"text": "（2）列出图中所有的边输出：说明：E表示边集合。"}
{"text": "（3）查询从节点1出发的标签为“认识”的边输出：说明：v(1)选取id为1的节点；outE表示节点的出边集合，outE(’认识’)是标签为“认识”的出边集合。"}
{"text": "（4）查询节点1认识的30岁以上的程序员参加的项目名称输出：说明：out(’认识’)选取标签为“认识”的出边指向的邻接节点集合；filter为过滤器，filter{it.年龄>30}的意思是后面只处理年龄大于30的节点。"}
{"text": "（5）查询年龄为29的参加了项目3的程序员参加的其他项目及其直接或间接认识的程序员参加的项目输出：说明：in(’参加’)选取标签为“参加”的入边连接的邻接节点集合；has(’年龄’,29)的作用是只选取具有属性“年龄=29”的节点；as('x')将当前的导航步骤命名为x;loop('x'){it.loops>=0}为从x开始到当前的步骤循环0次、1次或多次。"}
{"text": "对比该查询的SPARQL和Cypher版本。"}
{"text": "3.2常见知识图谱存储方法本节介绍三类知识图谱数据库：基于关系数据库的存储方案、面向RDF的三元组数据库和原生图数据库，多数系统给出了演示操作步骤。"}
{"text": "3.2.1基于关系数据库的存储方案关系数据库拥有40多年的发展历史，从理论到实践有着一整套成熟体系。"}
{"text": "在历史上，关系数据库曾经取代了层次数据库和网状数据库；成功吸收容纳了面向对象数据库和XML数据库，成为现今数据管理的主流数据库产品。"}
{"text": "商业数据库包括Oracle、DB2和SQL_Server等，开源数据库包括PostgreSQL和MySQL等。"}
{"text": "因此基于历史上的成功经验，人们容易想到使用关系数据库存储知识图谱。"}
{"text": "基于关系数据库的存储方案是目前知识图谱采用的一种主要存储方法。"}
{"text": "本小节将按照时间发展顺序简要介绍各种基于关系表的知识图谱存储结构，包括三元组表、水平表、属性表、垂直划分、六重索引和DB2RDF。"}
{"text": "如图3-4所示，下面以摘自DBpedia数据集[23]的RDF数据作为知识图谱进行讲解和举例。"}
{"text": "该知识图谱描述了IBM公司及其创始人Charles_Flint和Google公司及其创始人LarryPage的一些属性和联系。"}
{"text": "对于其他格式的知识图谱，这些存储方案同样适用。"}
{"text": "图3-4摘自DBpedia数据集的RDF知识图谱1.三元组表三元组表是将知识图谱存储到关系数据库的最简单、最直接的办法，就是在关系数据库中建立一张具有3列的表，该表的模式为：三元组表(主语，谓语，宾语)将知识图谱中的每条三元组存储为三元组表中的一行记录。"}
{"text": "表3-1是图3-4中知识图谱对应的三元组表，由于一共有21行，限于篇幅仅列出了前5行。"}
{"text": "表3-1三元组表三元组表存储方案虽然简单明了，但三元组表的行数与知识图谱的边数一样，其最大问题在于将知识图谱查询翻译为SQL查询后的三元组表自连接。"}
{"text": "例如，如图3-5所示的SPARQL查询是查找1850年出生且1934年逝世的创办了某公司的人，翻译为等价的SQL查询后如图3-6所示，这里三元组表的表名为t。"}
{"text": "一般自连接的数量与SPARQL中三元组模式数量相当。"}
{"text": "当三元组表规模较大时，多个自连接操作会使SQL查询性能低下。"}
{"text": "采用三元组表存储方案的代表是RDF数据库系统3store[24]。"}
{"text": "图3-5一个星形SPARQL查询图3-6三元组表方案中SPARQL查询转换为等价的SQL查询2.水平表水平表存储方案同样非常简单，与三元组表不同，其每行记录存储一个知识图谱中一个主语的所有谓语和宾语。"}
{"text": "实际上，水平表就相当于知识图谱的邻接表。"}
{"text": "表3-2是图3-4中知识图谱对应的水平表，共有5行、13列，限于篇幅省略了若干列。"}
{"text": "不难看出，水平表的列数是知识图谱中不同谓语的数量，行数是知识图谱中不同主语的数量。"}
{"text": "表3-2水平表在水平表存储方案中，图3-5所示的SPARQL查询可以等价地翻译为图3-7中的SQL查询。"}
{"text": "这里水平表的表名为t。"}
{"text": "可见，与三元组表相比，水平表的查询大为简化，仅需单表查询即可完成该任务，不用进行连接操作。"}
{"text": "图3-7水平表方案中SPARQL查询转换为等价的SQL查询但是水平表的缺点在于：所需列的数目等于知识图谱中不同谓语数量，在真实知识图谱数据集中，不同谓语数量可能为几千个到上万个，很可能超出关系数据库允许的表中列数目的上限；对于一行来说，仅在极少数列上具有值，表中存在大量空值，空值过多会影响表的存储、索引和查询性能；在知识图谱中，同一主语和谓语可能具有多个不同宾语，即一对多联系或多值属性，而水平表的一行一列上只能存储一个值，无法应对这种情况（可以将多个值用分隔符连接存储为一个值，但这违反关系数据库设计的第一范式）；知识图谱的更新往往会引起谓语的增加、修改或删除，即水平表中列的增加、修改或删除，这是对于表结构的改变，成本很高。"}
{"text": "采用水平表存储方案的代表是早期的RDF数据库系统DLDB[25]。"}
{"text": "3.属性表属性表（Property_Table）存储方案是对水平表的细化，将同类主语分到一个表中，不同类主语分到不同表中。"}
{"text": "这样就解决了表中列的数目过多的问题。"}
{"text": "对于图3-5中的SPARQL查询，在属性表存储方案上等价的SQL查询如图3-9所示；该查询与图3-7中水平表上查询的唯一区别是将表名由t变为了person。"}
{"text": "图3-8属性表图3-9属性表方案中SPARQL查询转换为等价的SQL查询属性表既克服了三元组表的自连接问题，又解决了水平表中列数目过多的问题。"}
{"text": "实际上，水平表方案是属性表存储方案的一种极端情况，即水平表是将所有主语划归为一类，因此属性表中的空值问题与水平表相比会大为缓解。"}
{"text": "但属性表方案仍有缺点：对于规模稍大的真实知识图谱数据，主语的类别可能有几千个到上万个，按照属性表方案，需要建立几千个到上万个表，这往往超过了关系数据库的限制；对于知识图谱上稍复杂的查询，属性表方案仍然会进行多个表之间的连接操作，从而影响查询效率；即使在同一类型中，不同主语具有的谓语集合也可能存在较大差异，这样会造成与水平表中类似的空值问题；水平表方案中存在的一对多联系或多值属性存储问题仍然存在。"}
{"text": "采用属性表存储方案的代表是RDF三元组库Jena[26]。"}
{"text": "4.垂直划分垂直划分（Vertical_Partitioning）存储方案是由美国麻省理工学院的Abadi等人在2007年提出的RDF数据存储方法[27]。"}
{"text": "该方法以三元组的谓语作为划分维度，将RDF知识图谱划分为若干张只包含(主语，宾语)两列的表，表的总数量即知识图谱中不同谓语的数量；也就是说，为每种谓语建立一张表，表中存放知识图谱中由该谓语连接的主语和宾语值。"}
{"text": "对于图3-5中的SPARQL查询，在垂直划分存储方案中等价的SQL查询如图3-11所示；该查询涉及3张谓语表born、died和founder的连接操作。"}
{"text": "由于谓语表中的行都是按照主语列进行排序的，可以快速执行这种以“主语-主语”作为连接条件的查询操作，而这种连接操作又是常用的。"}
{"text": "与之前基于关系数据库的知识图谱存储方案相比，垂直划分有一些突出的优点：谓语表仅存储出现在知识图谱中的三元组，解决了空值问题；一个主语的一对多联系或多值属性存储在谓语表的多行中，解决了多值问题；每个谓语表都按主语列的值进行排序，能够使用归并排序连接（Merge-sort_Join）快速执行不同谓语表的连接查询操作。"}
{"text": "与之前基于关系数据库的知识图谱存储方案相比，垂直划分有一些突出的优点：谓语表仅存储出现在知识图谱中的三元组，解决了空值问题；一个主语的一对多联系或多值属性存储在谓语表的多行中，解决了多值问题；每个谓语表都按主语列的值进行排序，能够使用归并排序连接（Merge-sort_Join）快速执行不同谓语表的连接查询操作。"}
{"text": "图3-10垂直划分存储方案图3-11垂直划分方案中等价的SQL查询不过，垂直划分存储方案依然存在几个缺点：需要创建的表的数目与知识图谱中不同谓语数目相等，而大规模的真实知识图谱（如DBpedia、YAGO、Wikidata等）中谓语数目可能超过几千个，在关系数据库中维护如此规模的表需要很大的开销；越是复杂的知识图谱查询操作，需要执行的表连接操作数量越多，而对于未指定谓语的三元组查询，将发生需要连接全部谓语表进行查询的极端情况；谓语表的数量越多，数据更新维护代价越大，对于一个主语的更新将涉及多张表，产生很高的更新时I/O开销。"}
{"text": "采用垂直划分存储方案的代表数据库是SW-Store[28]。"}
{"text": "5.六重索引六重索引（Sextuple_Indexing）存储方案是对三元组表的扩展，是一种典型的“空间换时间”策略，其将三元组全部6种排列对应地建立为6张表，即spo(主语，谓语，宾语)、pos(谓语，宾语，主语)、osp(宾语，主语，谓语)、sop(主语，宾语，谓语)、pso(谓语，主语，宾语)和ops(宾语，谓语，主语)。"}
{"text": "不难看出，其中spo表就是原来的三元组表。"}
{"text": "六重索引通过6张表的连接操作不仅缓解了三元组表的单表自连接问题，而且加速了某些典型知识图谱查询的效率。"}
{"text": "使用六重索引方法的典型系统有RDF-3X[28]和Hexastore[29]。"}
{"text": "具体来说，六重索引方案的优点有：知识图谱查询中的每种三元组模式查询都可以直接使用相应的索引表进行快速的前缀范围查找，表3-3给出了全部8种三元组模式查询能够使用的索引表；可以通过不同索引表之间的连接操作直接加速知识图谱上的连接查询，如图3-12所示的链式SPARQL查询“查找生于1850年的人创立的公司的营业领域”，可以通过spo和pso表的连接快速执行三元组模式“?person_founder?company”与“?company_industry?ind”的连接操作，避免了单表的自连接。"}
{"text": "表3-3三元组模式查询能够使用的索引表图3-12一个链式SPARQL查询六重索引存储方案存在的问题包括：虽然部分缓解了三元组表的单表自连接问题，但需要花费6倍的存储空间开销、索引维护代价和数据更新时的一致性维护代价，随着知识图谱规模的增大，该问题会愈加突出；当知识图谱查询变得复杂时，会产生大量的连接索引表查询操作，索引表的自连接依然不可避免。"}
{"text": "6.DB2RDFDB2RDF是由IBM研究中心于2013年提出的一种面向实体的RDF知识图谱存储方案[30]，该方案是以往RDF关系存储方案的一种权衡折中，既具备了三元组表、属性表和垂直划分方案的部分优点，又克服了这些方案的部分缺点。"}
{"text": "三元组表的优势在于“行维度”上的灵活性，即存储模式不会随行的增加而变化；DB2RDF方案将这种灵活性扩展到“列维度”上，即将表的列作为谓语和宾语的存储位置，而不将列与谓语进行绑定。"}
{"text": "当插入数据时，将谓语动态地映射存储到某列；方案能够确保将相同的谓语映射到同一组列上。"}
{"text": "DB2RDF存储方案由4张表组成，即dph表、rph表、ds表和rs表；图3-13给出了图3-4中知识图谱对应的DB2RDF存储方案。"}
{"text": "dph（direct_primary_hash）是存储方案的主表，该表中一行存储一个主语（主语列）及其全部谓语（predi列）和宾语（vali列）,0≤i≤k,k为图着色结果值或某个给定值。"}
{"text": "如果一个主语的谓语数量大于k，则一行不足以容纳下一个实体，将在下一行存储第k+1到2k个谓语和宾语，以此类推，这种情况叫作溢出。"}
{"text": "spill列是溢出标志，即对于一行能存储下的实体，该行spill列为0，对于溢出的实体，该实体所有行的spill列为1。"}
{"text": "例如，在图3-13的dph表中，除实体Android溢出外，其余实体均存储为一行。"}
{"text": "对于多值谓语的处理，引入ds（direct_secondary_hash）表。"}
{"text": "当dph表中遇到一个多值谓语时，则在相应的宾语处生成一个唯一的id值；将该id值和每个对应的宾语存储为ds表的一行。"}
{"text": "例如，在图3-13的dph表中，主语Google的谓语industry（pred1列）是多值谓语，则在其宾语列（val1）存储id值lid:1；在ds表中存储lid:1关联的两个宾语Software和Internet。"}
{"text": "实际上，dph表实现了列的共享：一方面，不同实体的相同谓语总是会被分配到相同的列上；另一方面，同一列中可以存储多个不同的谓语。"}
{"text": "例如，主语Charles_Flint和Larry_Page的谓语founder都被分配到pred3列，该列也存储了主语Android的谓语kernel和graphics。"}
{"text": "正是由于DB2RDF方案具备“列共享”机制，才使得在关系表中最大列数目上限的情况下可以存储远超出该上限的谓语数目，也能够有效地解决水平表方案中存在的谓语稀疏性空值问题。"}
{"text": "在真实的知识图谱中，不同主语往往具有不同的谓语集合，例如，谓语born只有人才具有，谓语employees只有公司才具有，这也是能够实现列共享的原因所在。"}
{"text": "图3-13DB2RDF方案从图数据模型的角度来看，dph表和ds表实际上存储了实体节点（主语）的出边信息（从主语经谓语到宾语）；为了提高查询处理效率，还需要存储实体节点的入边信息（从宾语经谓语到主语）。"}
{"text": "为此，DB2RDF方案提供了rph（reverse_primary_hash）表和rs（reverse_secondary_hash）表，如图3-13所示。"}
{"text": "DB2RDF方案中SPARQL查询转换为等价的SQL查询如图3-14所示。"}
{"text": "从中可以看出，对于知识图谱的星型查询，DB2RDF存储方案只需要查询dph表即可完成，无须进行连接操作。"}
{"text": "图3-14DB2RDF方案中SPARQL查询转换为等价的SQL查询在DB2RDF方案中，谓语到列的映射是需要重点考虑的问题。"}
{"text": "因为关系表中最大列的数目是固定的，该映射的两个优化目标是：使用的列的数目不要超过某个值m；尽量减少将同一主语的两个不同谓语分配到同一列的情况，从而减少溢出现象，因为溢出会导致查询时发生自连接。"}
{"text": "谓语到列映射的一种方法是使用一组散列函数，将谓语映射到一组列编号，并将谓语及其宾语存储到这组列中的第一个空列上；在一个主语对应的一行中，如果存储某谓语（及其宾语）时，散列函数计算得出的这组列中的所有列都被之前存储的该主语的谓语占用了，则产生溢出，到下一行存储该谓语。"}
{"text": "例如，表3-4给出了谓语到列映射的散列函数表，其中包括h2两个散列函数，映射了5个谓语到列编号组。"}
{"text": "现在开始存储以h1和Android作为主语的三元组：当存储(Android,developer,Google)时，在dph表中为主语Android插入一个新行，根据h1的值将谓语developer存入列pred1；当存储(Android,version,8.1)时，根据h1的值将谓语version存储列pred2；当存储(Android,kernel,Linux)时，谓语kernel被h1映射到列pred1，但该列已被占用，因而接着被h2映射到列pred3；当存储(Android,preceded,8.0)时，谓语preceded被h1映射到列predk；当存储(Android,graphics,OpenGL)时，谓语graphics被h1映射到列pred3，被h2映射到列pred2，但这两列都已被占用，这时产生溢出，将谓语graphics溢出到下一行的列pred3中存储，如图3-13的dph表所示。"}
{"text": "表3-4谓语到列映射的散列函数表如果可以事先获取知识图谱的一个子集，则可以利用知识图谱的内在结构优化谓语到列的映射。"}
{"text": "方法是将谓语到列的映射转化为图着色（Graph_Coloring）问题[31]。"}
{"text": "将一个主语上出现的不同谓语称为共现谓语（Co-occurrence_Predicates），目标是让共现谓语着上不同颜色（映射到不同列中），非共现谓语可以着上相同颜色（映射到同一列中）。"}
{"text": "为此，构建图着色算法的冲突图（Interference_Graph）：图中节点为知识图谱中的所有谓语；每对共现谓语节点之间由一条边相连。"}
{"text": "图着色问题的要求是为冲突图中的节点着上颜色，使得每个节点的颜色不同于其任一邻接节点的颜色，并使所用颜色数最少；对应到谓语映射问题，即为冲突图中的谓语节点分配列，使得每个谓语映射到的列不同于其任一共现谓语映射到的列，并使所用的列数目最少。"}
{"text": "可见，对于13个谓语，仅使用了5种颜色，即只需使用5列。"}
{"text": "需要指出的是，图着色是经典的NP难问题，对于规模较大的冲突图可用贪心算法（如Welsh-Powell算法）[32]求得近似解。"}
{"text": "图3-15冲突图如果在大规模真实知识图谱（如DBpedia）中，图着色所需颜色数量超过了关系数据表的列数上限m，则根据某种策略（如最频繁使用的前k个谓语）选取一个谓语子集，使得该谓语子集到列的映射满足图着色要求；对于不在该子集中的谓语，再使用前面提到的散列函数组策略进行映射。"}
{"text": "3.2.2面向RDF的三元组数据库由于RDF是W3C推荐的表示语义网上关联数据（Linked_Data）的标准格式，RDF也是表示和发布Web上知识图谱的最主要数据格式之一。"}
{"text": "面向RDF的三元组数据库是专门为存储大规模RDF数据而开发的知识图谱数据库，其支持RDF的标准查询语言SPARQL。"}
{"text": "本节将分别介绍几种主要的开源和商业RDF三元组数据库。"}
{"text": "主要的开源RDF三元组数据库包括：Apache旗下的Jena、Eclipse旗下的RDF4J以及源自学术界的RDF-3X和gStore；主要的商业RDF三元组数据库包括：Virtuoso、AllegroGraph、GraphDB和BlazeGraph。"}
{"text": "ApacheJena将以实践形式进行详细介绍；下面分别介绍RDF4J、RDF-3X、gStore、Virtuoso、AllegroGraph、GraphDB和BlazeGraph。"}
{"text": "1.开源RDF三元组数据库RDF4JRDF4J目前是Eclipse基金会旗下的开源孵化项目，其前身是荷兰软件公司Aduna开发的Sesame框架。"}
{"text": "Sesame框架的历史可以追溯到1999年，当时作为Aduna公司的一个语义Web项目进行开发，后来发展成为语义Web领域一个非常有名的管理和处理RDF的开源Java框架，功能包括RDF数据的解析、存储、推理和查询等。"}
{"text": "2016年5月，Sesame框架改名为RDF4J，并迁移为Eclipse开源项目继续开发。"}
{"text": "RDF4J本身提供内存和磁盘两种RDF存储机制，支持全部的SPARQL1.1查询和更新语言，可以使用与访问本地RDF库相同的API访问远程RDF库，支持所有主流RDF数据格式，包括RDF/XML、Turtle、N-Triples、N-Quads、JSON-LD、TriG和TriX。"}
{"text": "RDF4J框架的重要特点是其模块化的软件架构设计。"}
{"text": "图3-16RDF4J的高层架构图（1）底层的RDF模型定义了URI、空节点（Blank_Node）、字面值（Literal）和语句（Statement）等RDF基本元素。"}
{"text": "（2）Rio代表“RDF_I/O”，即RDF输入/输出，包括各种RDF文件格式的解析器（Parser）和编写器（Writer），解析器负责将RDF文件解析为RDF模型中的三元组语句，编写器负责将三元组语句写为RDF文件。"}
{"text": "（3）Sail_API代表“存储和推理层API”（Storage_And_Inference_Layer_API），是实现RDF存储和推理的底层系统（System）API（即SPI），其作用是将RDF存储和推理功能从底层实现细节中抽象出来，使得底层存储和推理实现模块可以透明地被替换；Sail_API是SAIL底层存储开发者需要实现的API，普通用户无须关心；RDF4J自带了两种SailAPI实现，即基于内存的MemoryStore和基于磁盘的NativeStore。"}
{"text": "（4）存储库API（Repository_API）是用户使用的RDF管理和处理高层API，提供RDF的存储、查询和推理等服务，面向终端用户，简单易用；存储库API的一种实现是基于本地SAIL实现的SailRepository，另一种是基于远程HTTP服务器实现的HttpRepository。"}
{"text": "（5）架构图的顶层是用户开发的应用程序和HTTP服务器，用户应用程序直接调用存储库API;HTTP服务器实现了通过HTTP访问存储库API的Web服务，可通过HttpClient库与HTTP服务器进行远程通信，从而访问远程RDF4J存储库。"}
{"text": "正是由于RDF4J规范的模块化设计，使其成为很多其他RDF三元组数据库（如GraphDB）的上层标准框架，这些三元组库只需要实现各自的SAIL_API，依赖于RDF4J存储库API的应用程序而无须修改，便可以在不同的三元组库之间实现透明切换。"}
{"text": "图3-17使用RDF4J工作台执行SPARQL查询2.开源RDF三元组数据库RDF-3XRDF-3X是由德国马克斯·普朗克计算机科学研究所研发的RDF三元组数据库系统，其最初成果发表于2008年的数据库国际会议VLDB[28]，后经功能扩展和完善，最新版本是GH-RDF3X，源代码可以从GitHub上下载。"}
{"text": "目前，RDF-3X只支持Linux系统。"}
{"text": "RDF-3X的最大特点在于其为RDF数据精心打造的压缩物理存储方案、查询处理和查询优化技术。"}
{"text": "在逻辑存储上，虽然以简单的三元组表为基础，但首次提出全索引方案：建立6种三元组索引spo、sop、osp、ops、pso和pos；建立6种二元聚合索引sp、ps、so、os、po和op；建立3种一元聚合索引s、p、o。"}
{"text": "在物理存储上，采用基于B+树的压缩方案：使用字典快速查找表建立RDF字符串到整数id的映射；使用面向字节的增量编码B+树页面内部，不会跨越不同页压缩技术，实现三元组的压缩存放；三元组压缩限于面，避免了不必要的解压缩操作，能够提高查询效率。"}
{"text": "借助巧妙设计的三元组压缩技术，全索引方案的空间开销是可以接受的，全索引为查询处理和优化带来了巨大便利。"}
{"text": "对于利用全索引方案的查找，仅以spo索引为例进行举例。"}
{"text": "如图3-18所示，利用spo索引查找三元组模式(Albert_Einstein,invented,?x),spo索引中存储的是已经进行字典编码之后的由整数id值组成的(s,p,o)三元组，并且已按照s、p、o值由小到大的顺序进行了排序。"}
{"text": "图3-18使用spo索引进行三元组模式查找RDF-3X的查询处理器首先对SPARQL查询进行转化，生成若干查询执行计划；对于仅包含一个三元组模式的查询，可以通过一次相应索引查找操作完成；对于由多个三元组模式组成的查询，需要对多个连接的顺序进行优化。"}
{"text": "RDF-3X采用的是一种自底向上的动态规划优化算法，其优化过程充分考虑了SPARQL查询的特点，并且最大限度地保持了有利于用全索引方案进行归并连接的连接顺序。"}
{"text": "同时，RDF-3X还开发了基于代价模型的选择度评估（Selectivity_Estimates）机制，采用选择度直方图和频繁连接路径相结合的方法进行查询执行计划的选择度评估。"}
{"text": "RDF-3X是命令行程序，使用RDF-3X装载RDF文件music_1000_triples.nt的命令如图3-19所示，其中的rdf3xload是命令名称，testds是数据库名称；进行SPARQL查询的命令如图3-20所示，rdf3query是命令名称，sparql.rq是SPARQL查询文件名称。"}
{"text": "图3-19使用RDF-3X装载RDF文件图3-20使用RDF-3X进行SPARQL查询3.开源RDF三元组数据库gStoregStore是基于图的RDF三元组数据库。"}
{"text": "gStore将RDF图G中的每个实体节点及其邻居属性和属性值编码成一个二进制位串，由这些位串作为节点组成一张与RDF图G对应的标签图G*。"}
{"text": "在执行SPARQL查询时，将查询图Q也转化为一张查询的标签图Q*。"}
{"text": "gStore的研究工作已经证明了Q*在G*上的匹配是Q在G上匹配的超集。"}
{"text": "为了支持在G*上快速地查找到Q*的匹配位置，gStore系统提出建立“VS树”索引，其基本思想实际上是为标签图G*建立不同详细程度的摘要图（summary_graph）；利用“VS”树索引提供的摘要图，gStore系统提出可以大幅削减SPARQL查询的搜索空间，加快查询速度。"}
{"text": "目前，gStore已经作为开源项目发布，源代码和文档可以从其GitHub项目网站下载。"}
{"text": "与RDF-3X一样，gStore只能在Linux系统上运行。"}
{"text": "关于gStore内部实现的详细信息可参见文献[33]。"}
{"text": "4.商业RDF三元组数据库VirtuosoVirtuoso虽然是可以支持多种数据模型的混合数据库管理系统，但其基础源自开发了多年的传统关系数据库管理系统，因此具备较为完善的事务管理、并发控制和完整性机制。"}
{"text": "Virtuoso同时发布了商业版本VirtuosoUniversalServer（Virtuoso统一服务器）和开源版本OpenLinkVirtuoso。"}
{"text": "图3-21使用Virtuoso进行SPARQL查询5.商业RDF三元组数据库AllegroGraphAllegroGraph是Franz公司开发的RDF三元组数据库。"}
{"text": "由于Franz公司有着深厚的人工智能背景，早期一直开发Common_Lisp和Prolog语言的实现工具，这使得AllegroGraph对语义推理功能具有较为完善的支持。"}
{"text": "AllegroGraph除了三元组数据库的基本功能外，还支持动态物化的RDFS++推理机、OWL2_RL推理机、Prolog规则推理系统、时空推理机制、社会网络分析库、可视化RDF图浏览器等。"}
{"text": "同时，AllegroGraph支持Java、Python、C#、Ruby、Clojure/Scala、Lisp等多种语言的编程访问接口。"}
{"text": "6.商业RDF三元组数据库GraphDBGraphDB是RDF三元组数据库，其前身OWLIM一直是支持W3C语义Web标准的主流产品。"}
{"text": "GraphDB目前有社区免费版、标准版和企业版，其中企业版支持多台机器的集群分布式部署。"}
{"text": "GraphDB的高层架构如图3-26所示。"}
{"text": "图3-26GraphDB的高层架构对于GraphDB的各部分组件自顶向下进行介绍：（1）Workbench是GraphDB的Web管理工具；（2）Engine是查询处理和推理引擎，由查询优化器（Query_Optimiser）、推理机（Reasoner）、存储层（Storage）和插件管理器（Plugin_Manager）组成；●查询优化器能够在多种查询执行计划中挑选出较高效的一种，查询经过解析后会交由查询优化器进行优化；●推理机执行基于RDF规则的前向链推理，由显式三元组推导出全部导出三元组，导出三元组会随显式三元组的更新而同步更新；●存储层使用pos和pso两种三元组索引、psco和pocs两种带有上下文信息的四元组索引以及字面值（Literal）索引存储RDF数据；实体池（Entity_Pool）是GraphDB存储层的核心部件，起到将RDF实体（URI、空节点和字面值）映射到内部整数ID的字典编码器的作用，同时还实现了对事务管理的支持机制。"}
{"text": "（3）Connectors是GraphDB连接外部工具的桥梁，包括用于建立快速关键字查找功能的Lucene和用于建立搜索引擎的Solr和Elasticsearch。"}
{"text": "（4）插件管理器在Engine内起到插件管理作用，既包括GraphDB内部实现的插件，也包括各种外部工具连接器。"}
{"text": "7.商业RDF三元组数据库BlazegraphBlazegraph在1.5版本之前叫作Bigdata，但众所周知的“大数据”的兴起使得这个不温不火的RDF三元组库软件被淹没其中。"}
{"text": "但这个软件在“大数据”兴起前很多年就叫Bigdata，迫不得已改名叫Blazegraph之后，其开发理念也有所调整。"}
{"text": "原来仅仅是支持RDF三元组存储和SPARQL，现在已经定位为全面支持Blueprints标准的图数据库。"}
{"text": "不过，其内部实现技术仍是面向RDF三元组和SPARQL的，因而可以理解为是“基于RDF三元组库的图数据库”。"}
{"text": "从2006年发布至今，Blazegraph一直由SYSTAP公司开发，虽然它既不是最知名的RDF三元组库，也不是最流行的图数据库，但开发进展稳扎稳打，积累了相对全面的功能。"}
{"text": "Blazegraph可以通过其官方网站下载。"}
{"text": "既可以将Blazegraph作为War包部署为Web程序，也可以将其配置为单机或分布式数据库服务器。"}
{"text": "图3-27Blazegraph的Web用户界面8.商业RDF三元组数据库StardogStardog是由美国Stardog_Union公司开发的RDF三元组数据库，其首个公开发布版本是2012年2月发布的Stardog_0.9。"}
{"text": "Stardog支持RDF图数据模型、SPARQL查询语言、属性图模型、Gremlin图遍历语言、OWL2标准、用户自定义的推理与数据分析规则、虚拟图、地理空间查询以及多种编程语言与网络接口支持。"}
{"text": "虽然Stardog发布较晚，但其对OWL2推理机制具有良好的支持，同时具备全文搜索、GraphQL查询、路径查询、融合机器学习任务等功能，能够支持多种不同编程语言和Web访问接口，使得Stardog成为一个知识图谱数据存储和查询平台。"}
{"text": "Stardog分为企业版和社区版，社区版可以免费用于非商业用途。"}
{"text": "3.2.3原生图数据库1.最流行的图数据库Neo4jNeo4j的1.0版本发布于2010年。"}
{"text": "Neo4j基于属性图模型，其存储管理层为属性图结构中的节点、节点属性、边、边属性等设计了专门的存储方案。"}
{"text": "这使得Neo4j在存储层对于图数据的存取效率天生就优于关系数据库。"}
{"text": "同时，Neo4j还具备OLTP数据库必需的ACID事务处理功能。"}
{"text": "Neo4j的不足之处在于其社区版是单机系统，虽然Neo4j企业版支持高可用性（HighAvailability）集群，但其与分布式图存储系统的最大区别在于每个节点上存储图数据库的完整副本（类似于关系数据库镜像的副本集群），不是将图数据划分为子图进行分布式存储，并非真正意义上的分布式数据库系统。"}
{"text": "如果图数据超过一定规模，系统性能就会因为磁盘、内存等限制而大幅降低。"}
{"text": "开发者注册信息后可以免费下载Neo4j桌面打包安装版（Neo4j_Desktop），其中包括Neo4j企业版的全部功能，即Neo4j服务器、客户端及全部组件。"}
{"text": "Neo4j浏览器是功能完善的Neo4j可视化交互式客户端工具，可以用于执行Cypher语言。"}
{"text": "使用Neo4j内置的Movie图数据库执行Cypher查询，返回“TomHanks”所出演的全部电影，如图3-31所示。"}
{"text": "此外，成功启动Neo4j服务器之后，会在7474和7473端口分别开启HTTP和HTTPS服务。"}
{"text": "例如，使用浏览器访问http://localhost:7474/进入Web界面，执行Cypher查询，其功能与Neo4j浏览器是一致的。"}
{"text": "图3-31Neo4j浏览器界面2.分布式图数据库JanusGraphJanusGraph借助第三方分布式索引库Elasticsearch、Solr和Lucene实现各种类型数据的快速检索功能，包括地理信息数据、数值数据和全文搜索。"}
{"text": "JanusGraph的前身Titan是由Aurelius公司开发的，而该公司的创始人Rodriguez博士恰恰就是Blueprints标准及Gremlin语言的主要开发者，Titan对于Blueprints标准和Gremlin语言的全面支持便不难理解，JanusGraph基本上继承了Titan的这一特性。"}
{"text": "同时，JanusGraph也是OLTP图数据库，其支持多用户并发访问和实时图遍历查询。"}
{"text": "另一方面，JanusGraph还具备基于Hadoop_MapReduce的图分析引擎，其可以将Gremlin导航查询自动转化为MapReduce任务。"}
{"text": "从这个角度看，JanusGraph也可作为图计算引擎使用。"}
{"text": "3.图数据库OrientDBOrientDB对于数据模式的支持也相对灵活，可以管理无模式数据（Schema-less），也可以像关系数据库那样定义完整的模式（Schema-full），还可以适应介于两者之间的混合模式（Schema-mixed）数据。"}
{"text": "在查询语言方面，OrientDB支持扩展的SQL和Gremlin用于图上的导航式查询；值得注意的是，在2.2版本引入的MATCH语句实现了声明式的模式匹配，这类似于Cypher语言查询模式。"}
{"text": "从数据管理角度来看，OrientDB是一个功能上相对全面的数据库管理系统，除对图数据基本的存储和查询外，还支持完整的事务处理ACID特性、基于多主机复制模式（Multi-Master_Replication）的分布式部署、对于多种操作系统的支持（由于使用Java开发）和数据库安全性支持等。"}
{"text": "根据2018年2月DB-Engines的排名，OrientDB排在最流行图数据库的第3位。"}
{"text": "4.图数据库CayleyCayley使用Go语言开发，可以作为Go类库使用；对外提供RESTAPI；具有内置的查询编辑器和可视化界面；支持多种查询语言，包括基于Gremlin的Gizmo、GraphQL和MQL；支持多种存储后端，包括键值数据库Bolt、LevelDB,NoSQL数据库MongoDB、CouchDB、PouchDB、ElasticSearch，关系数据库PostgreSQL、MySQL等；具有良好的模块化设计，易于扩展，对新语言和存储后端有良好的支持。"}
{"text": "需要指出的是，Cayley虽然可以存储N-Quads格式的RDF文件，但目前尚不支持SPARQL查询。"}
{"text": "图3-35Cayley查询结果的可视化3.2.4知识图谱数据库比较下面对常用的知识图谱数据库进行比较，如表3-5所示。"}
{"text": "总体来讲，基于关系的存储系统继承了关系数据库的优势，成熟度较高，在硬件性能和存储容量满足的前提下，通常能够适应千万到十亿级三元组规模的管理。"}
{"text": "官方测评显示，关系数据库Oracle_12c配上空间和图数据扩展组件（Spatial_and_Graph）可以管理的三元组数量高达1.08万亿条[34]！当然，这样的性能效果是在Oracle专用硬件上获得的，所需软硬件成本投入很大。"}
{"text": "对于一般在百万到上亿级三元组的管理，使用稍高配置的单机系统和主流RDF三元组数据库（如Jena、RDF4J、Virtuoso等）完全可以胜任。"}
{"text": "如果需要管理几亿到十几亿以上大规模的RDF三元组，则可尝试部署具备分布式存储与查询能力的数据库系统（如商业版的GraphDB和BlazeGraph、开源的JanusGraph等）。"}
{"text": "近年来，以Neo4j为代表的图数据库系统发展迅猛，使用图数据库管理RDF三元组也是一种很好的选择；但目前大部分图数据库还不能直接支持RDF三元组存储，对于这种情况，可采用数据转换方式，先将RDF预处理为图数据库支持的数据格式（如属性图模型），再进行后续管理操作。"}
{"text": "表3-5主要知识图谱数据库的比较续表3.3知识存储关键技术为了适应大规模知识图谱数据的存储管理与查询处理，知识图谱数据库内部针对图数据模型设计了专门的存储方案和查询处理机制。"}
{"text": "本节首先以图数据库Neo4j为例介绍其内部存储方案，然后简要描述知识图谱数据库的两类索引技术。"}
{"text": "3.3.1知识图谱数据库的存储：以Neo4j为例这一节将深入Neo4j图数据库底层，探究其原生的图存储方案。"}
{"text": "对于遵循属性图的图数据库，存储管理层的任务是将属性图编码表示为在磁盘上存储的数据格式。"}
{"text": "虽然不同图数据库的具体存储方案各有差异，但一般认为具有“无索引邻接”特性（Index-FreeAdjacency）的图数据库才称为原生图数据库[35]。"}
{"text": "在实现了“无索引邻接”的图数据库中，每个节点维护着指向其邻接节点的直接引用，这相当于每个节点都可看作是其邻接节点的一个“局部索引”，用其查找邻接节点比使用“全局索引”更能节省时间。"}
{"text": "这就意味着图导航操作代价与图大小无关，仅与图的遍历范围成正比。"}
{"text": "作为对比，来看看在非原生图数据库中使用全局索引关联邻接节点的情形。"}
{"text": "如果觉得这样的查找代价还是可以接受的话，那么换一个问题，“谁认识张三”的查找代价是多少？显然，对于这个查询，需要通过全局索引检查每个节点，看其认识的人中有没有张三，总代价为O(nlogn)，这样的复杂度对于大图数据的遍历操作是不可接受的。"}
{"text": "有人说，可为“被认识”关系再建一个同样的全局索引，但那样索引的维护开销就会翻倍，而且仍然不能做到图遍历操作代价与图规模无关。"}
{"text": "只有将图数据的边表示的关系当作数据库的“一等公民”（即数据库中最基本、最核心的概念，如关系数据库中的“关系”），才能实现真正的“无索引邻接”特性。"}
{"text": "图3-36邻接关系的全局索引示例图3-37将关系作为“一等公民”在Neo4j数据库中，属性图的不同部分是被分开存储在不同文件中的。"}
{"text": "正是这种将图结构与图上属性分开存储的策略，使得Neo4j具有高效率的图遍历操作。"}
{"text": "首先，来看在Neo4j中是如何存储图节点和边的。"}
{"text": "节点记录存储在文件neostore.nodestore.db中。"}
{"text": "节点记录的第0字节inUse是记录使用标志字节的，告诉数据库该记录是否在使用中，还是已经删除并可回收用来装载新的记录；第1～4字节nextRelId是与节点相连的第1条边的id；第5～8字节nextPropId是节点的第1个属性的id。"}
{"text": "边记录存储在文件neostore.relationshipstore.db中。"}
{"text": "边记录第0字节inUse含义与节点记录相同，表示是否正被数据库使用的标志；第1～4字节secondNode分别是该边的起始节点id和终止节点id；第9～12字节relType是指向该边的关系类型的指针；第13～16字节firstPrevRelId和第17～20字节firstNextRelId分别为指向起始节点上前一个和后一个边记录的指针；第21～24字节secPrevRelId和第25～28字节secNextRelId分别为指向终止节点上前一个和后一个边记录的指针；指向前后边记录的4个指针形成了两个“关系双向链”；第29～32字节nextPropId是边上的第1个属性的id。"}
{"text": "和第5～8字节firstNode图3-38Neo4j中节点和边记录的物理存储结构Neo4j实现节点和边快速定位的关键是“定长记录”的存储方案，将具有定长记录的图结构与具有变长记录的属性数据分开存储。"}
{"text": "例如，一个节点记录长度是9字节，如果要查找id为99的节点记录所在位置（id从0开始），则可直接到节点存储文件第891个字节处访问（存储文件从第0个字节开始）。"}
{"text": "边记录也是“定长记录”，长度为33字节。"}
{"text": "这样，数据库已知记录id可以O(1)的代价直接计算其存储地址，而避免了全局索引中O(nlogn)的查找代价。"}
{"text": "图3-39展示了Neo4j中各种存储文件之间是如何交互的。"}
{"text": "存储在节点文件中的节点1和节点4均有指针指向存储在属性文件中各自的第1个属性记录；也有指针指向存储在边文件中各自的第1条边，分别为边7和边8。"}
{"text": "如要查找节点属性，可由节点找到其第1个属性记录，再沿着属性记录的单向链表进行查找；如要查找一个节点上的边，可由节点找到其第1条边，再沿着边记录的双向链表进行查找；当找到了所需的边记录后，可由该边进一步找到边上的属性；还可由边记录出发访问该边连接的两个节点记录（图3-39中的虚线箭头）。"}
{"text": "需要注意的是，每个边记录实际上维护着两个双向链表，一个是起始节点上的边，一个是终止节点上的边，可以将边记录想象为被起始节点和终止节点共同拥有，双向链表的优势在于不仅可在查找节点上的边时进行双向扫描，而且支持在两个节点间高效率地添加和删除边。"}
{"text": "图3-39Neo4j中图的物理存储例如，由节点1导航到节点4的过程为：（1）由节点1知道其第1条边为边7；（2）在边文件中通过定长记录计算出边7的存储地址；（3）由边7通过双向链表找到边8；（4）由边8获得其中的终止节点id（secondNode），即节点4；（5）在节点文件中通过定长记录计算出节点4的存储地址。"}
{"text": "这些操作除了记录字段的读取，就是定长记录地址的计算，均是O(1)时间的高效率操作。"}
{"text": "可见，正是由于将边作为“一等公民”，将图结构实现为定长记录的存储方案，赋予了Neo4j作为原生图数据库的“无索引邻接”特性。"}
{"text": "3.3.2知识图谱数据库的索引图数据上的索引一种是对节点或边上属性数据的索引，一种是对图结构的索引；前者可应用关系数据库中已有的B+树索引技术直接实现，而后者仍是业界没有达成共识的、开放的研究问题。"}
{"text": "1.属性数据索引Neo4j数据库在前述存储方案的基础上还支持用户对属性数据建立索引，目的是加速针对某属性的查询处理性能。"}
{"text": "Neo4j索引的定义通过Cypher语句完成，目前支持对于同一个类型节点的某个属性构建索引。"}
{"text": "例如，对所有程序员节点的姓名属性构建索引。"}
{"text": "在一般情况下，在查询中没有必要指定需要使用的索引，查询优化器会自动选择要用到的索引。"}
{"text": "例如，下面的查询查找姓名为张三的程序员，显然会用到刚刚建立的索引。"}
{"text": "应用该索引无疑会根据姓名属性的值快速定位到姓名是“张三”的节点，而无须扫描程序员节点的全部属性。"}
{"text": "删除索引的语句为：不难发现，为图节点或边的属性建立索引与为关系表的某一列建立索引在本质上并无不同之处，完全可以通过B+树或散列表实现。"}
{"text": "这种索引并不涉及图数据上的任何图结构信息。"}
{"text": "2.图结构索引图结构索引是为图数据中的点边结构信息建立索引的方法。"}
{"text": "利用图结构索引可以对图查询中的结构信息进行快速匹配，从而大幅削减查询搜索空间。"}
{"text": "大体上，图结构索引分为“基于路径的”和“基于子图的”两种。"}
{"text": "（1）基于路径的图索引。"}
{"text": "一种典型的基于路径的图索引叫作GraphGrep[36]。"}
{"text": "这种索引将图中长度小于或等于一个固定长度的全部路径构建为索引结构。"}
{"text": "索引的关键字可以是组成路径的节点或边上属性值或标签的序列。"}
{"text": "图3-40是在图3-3的属性图上构建的GraphGrep索引。"}
{"text": "这里构建的是长度小于或等于2的路径索引，关键字为路径上的边标签序列，值为路径经过的节点id序列。"}
{"text": "例如，索引将关键字“认识.参加”映射到节点id序列(1,4,3)和(1,4,5)。"}
{"text": "利用该路径索引，类似前面出现过的“查询年龄为29的参加了项目3的程序员参加的其他项目及其直接或间接认识的程序员参加的项目”的查询处理效率会大幅提高，因为由节点1出发，根据关键字“认识.参加”，可以快速找到满足条件的节点3和节点5。"}
{"text": "（2）基于子图的索引。"}
{"text": "基于子图的索引可以看作是基于路径索引的一般化形式，是将图数据中的某些子图结构信息作为关键字，将该子图的实例数据作为值而构建的索引结构。"}
{"text": "图3-41是在图3-3的属性图上构建的一种子图索引。"}
{"text": "满足第1个关键字子图的节点序列为(1,2,4)，满足第2个关键字子图的节点序列为(1,4,3)。"}
{"text": "如果查询中包含某些作为关键字的子图结构，则可以利用该子图索引，快速找到与这些子图结构匹配的节点序列，这样可大幅度减小查询操作的搜索空间。"}
{"text": "图3-40基于路径的图索引示例图3-41基于子图的图索引示例不过，一个图数据的子图有指数个，将哪些子图作为关键字建立索引尚未得到很好的解决。"}
{"text": "一种叫作gIndex[37]的索引方法，首先利用数据挖掘方法，在图数据中发现出现次数超过一定阈值的频繁子图，再将去掉冗余之后的频繁子图作为关键字建立子图索引。"}
{"text": "但gIndex建立索引的过程是相当耗时的，而且用户查询中还有可能没有包含任何一个频繁子图，这样就无法利用该子图索引。"}
{"text": "一种更合理的方法是从用户的查询日志中挖掘频繁使用的子图模式，并以此作为关键字建立索引。"}
{"text": "3.4开源工具实践3.4.1三元组数据库Apache_Jena1.开源工具简介Apache_Jena是Apache顶级项目，其前身为惠普实验室开发的Jena工具包。"}
{"text": "Jena是语义Web领域主要的开源框架和RDF三元组库，较好地遵循W3C标准，其功能包括：RDF数据管理、RDFS和OWL本体管理、SPARQL查询处理等。"}
{"text": "Jena具备一套原生存储引擎，可对RDF三元组进行基于磁盘或内存的存储管理；同时具有一套基于规则的推理引擎，用于执行RDFS和OWL本体推理任务。"}
{"text": "本实践相关工具、实验数据及操作说明由OpenKG提供，地址为http://openkg.cn。"}
{"text": "2.开源工具的技术架构ApacheJena框架如图3-42所示。"}
{"text": "自底向上看，Jena的存储API为上层提供基本三元组存储和本体存储功能，支持的底层存储类型包括：基于内存的存储、基于关系数据库的SDB存储、基于原生三元组的TDB存储和用户定制的存储。"}
{"text": "推理API为上层提供本体推理服务，可以使用Jena内置基于规则的推理机进行RDFS和OWL本体上的推理任务，或者选择通过接口调用第三方外部推理机。"}
{"text": "Jena对外界应用程序的API包括实现基本三元组管理功能的RDFAPI、实现RDFS和OWL本体推理功能的本体API和实现查询处理功能的SPARQL_API。"}
{"text": "Java应用程序代码可以通过导入类库的形式直接调用这些API。"}
{"text": "Jena还提供了支持各种RDF三元组格式的解析器和编写器，支持的三元组格式包括：RDF/XML、Turtle、N-Triple和RDFa。"}
{"text": "图3-42Apache_Jena框架实质上，Jena是一个Java框架类库。"}
{"text": "在一般情况下，上述功能需要在Java程序中进行调用。"}
{"text": "Jena为了用户使用方便，提供了一个名为Fuseki的独立RDF数据库Web应用程序。"}
{"text": "本实践将使用Fuseki作为认识知识图谱数据库的入门工具。"}
{"text": "Fuseki是基于Jena的SPARQL服务器，可以作为独立的服务由命令行启动，也可以作为操作系统服务或JavaWeb应用程序。"}
{"text": "Fuseki底层存储基于TDB，具有SPARQL查询处理的Web用户界面，同时提供服务器监控和管理功能界面。"}
{"text": "Fuseki支持最新的SPARQL1.1版本，同时支持SPARQL图存储HTTP协议。"}
{"text": "访问OpenKG可以获取使用实例和整体配置细节。"}
{"text": "3.其他类似工具RDF4J是Eclipse基金会旗下的开源孵化项目，其前身是荷兰软件公司Aduna开发的Sesame框架，其功能包括：RDF数据的解析、存储、推理和查询等。"}
{"text": "RDF4J提供内存和磁盘两种RDF存储机制，支持SPARQL1.1查询和更新语言。"}
{"text": "gStore是由北京大学开发的基于图的RDF三元组数据库。"}
{"text": "AllegroGraph是Franz公司开发的RDF三元组数据库。"}
{"text": "AllegroGraph对语义推理功能具有较为完善的支持。"}
{"text": "除了三元组数据库的基本功能，AllegroGraph_RDFS++推理机、OWL2RL推理机、Prolog规则推理系统、时空推理机制、社会网络分析还支持动态物化的库、可视化RDF图浏览器等。"}
{"text": "GraphDB是由Ontotext软件公司开发的RDF三元组数据库。"}
{"text": "GraphDB实现了RDF4J框架的SAIL层，可以使用RDF4J的RDF模型、解析器和查询引擎直接访问GraphDB。"}
{"text": "GraphDB的特色是对于RDF推理功能的良好支持。"}
{"text": "3.4.2面向RDF的三元组数据库gStore1.开源工具简介gStore是由北京大学计算机科学技术研究所数据管理实验室自2011年开始研发的面向RDF知识图谱的开源图数据库系统，遵循Apache开源协议。"}
{"text": "不同于传统基于关系数据库的RDF数据管理方法，gStore原生基于图数据模型，在存储RDF数据时维持并根据其图结构构建了基于二进制位图索引的新型索引结构——VS树。"}
{"text": "本实践相关工具、实验数据及操作说明由OpenKG提供，下载链接为http://openkg.cn/tool/gstore。"}
{"text": "2.开源工具的技术架构如图3-43所示为gStore的整体处理流程，gStore的RDF数据管理可分为两部分：离线数据存储和在线查询处理。"}
{"text": "图3-43gStore的整体处理流程在离线数据存储阶段，gStore将RDF数据解析成图格式并以邻接表的方式存储在键值数据库上。"}
{"text": "同时，gStore将RDF数据上的所有点和边通过二进制编码的方式编码成若干位图索引，并将这些位图索引组织成VS树。"}
{"text": "在在线查询处理阶段，gStore也将SPARQL查询解析成查询图。"}
{"text": "然后，gStore按照对RDF数据图的编码方式，将SPARQL查询图进行编码以形成一个标签图，并在VS树和RDF数据图的邻接表上进行检索以得到每个查询变量的候选匹配。"}
{"text": "最后，gStore将所有查询变量的候选匹配连接成最终匹配。"}
{"text": "目前，gStore只能在Linux系统上通过Shell命令编译、安装与运行。"}
{"text": "同时，gStore官网还提供了gStore_Workbench，方便用户操作RDF数据库。"}
{"text": "具体包括：（1）环境配置。"}
{"text": "Linux中编译、安装与运行gStore需要预安装一些C++库，包括readline、curl和boost等。"}
{"text": "可以从OpenKG网站或gStore官网上下载gStore源代码，然后通过make来编译得到gStore运行程序。"}
{"text": "同时，通过OpenKG网站或gStore官网可以下载gStore_Workbench，进行编译安装后可以得到gStore_Workbench。"}
{"text": "（2）数据导入。"}
{"text": "gStore目前支持NT格式的RDF数据，利用gStore安装路径下bin目录中gbuild或者gStore_Workbench中的数据库管理页面导入数据。"}
{"text": "gStore_Workbench中的数据库管理页面还记录目前gStore包括的数据库统计信息。"}
{"text": "（3）查询处理。"}
{"text": "gStore目前完全支持SPARQL1.0查询语法，利用gStore安装路径下bin目录中gquery或者gStoreWorkbench中的图数据库查询页面，就可以输入查询然后得到结果。"}
{"text": "gStore同时还提供HTTP接口，可以利用gStore安装路径下bin目录中ghttp启动HTTP服务，进而接收其他机器远程通过HTTP发来的SPARQL查询请求。"}
{"text": "访问OpenKG网站可以获取使用实例和整体配置细节。"}
{"text": "3.其他类似工具Jena的前身是惠普实验室（HP_Labs）2000年开发的工具包。"}
{"text": "Jena从发布起就一直是语义Web领域最为流行的开源Java框架和RDF数据库之一，并始终遵循W3C标准，其提供的API功能包括：RDF数据管理、RDFS和OWL本体管理、SPARQL查询处理。"}
{"text": "针对RDF数据，Jena维护了一张大的三元组表和三种属性表，包括单值属性表、多值属性表和属性类表。"}
{"text": "Virtuoso是OpenLink公司开发的知识图谱管理系统，有免费的社区版和收费的商业版。"}
{"text": "Virtuoso是可以支持包括RDF在内的多种数据模型的混合数据库管理系统。"}
{"text": "其基础源自开发了多年的传统关系数据库管理系统，因此具备较为完善的事务管理、并发控制和完整性机制。"}
