{"text": "知识图谱是一种用图模型来描述知识和建模世界万物之间的关联关系的技术方法[1]。", "relation": [{"head": "知识图谱", "head_type": "知识图谱", "relation": "属于", "tail": "技术方法", "tail_type": "知识图谱"}, {"head": "知识图谱", "head_type": "知识图谱", "relation": "被定义为", "tail": "一种用图模型来描述知识和建模世界万物之间的关联关系的技术方法", "tail_type": "文本"}]}
{"text": "知识图谱由节点和边组成。", "relation": [{"head": "知识图谱", "head_type": "知识图谱", "relation": "由组成", "tail": "节点", "tail_type": "知识图谱"}, {"head": "知识图谱", "head_type": "知识图谱", "relation": "由组成", "tail": "边", "tail_type": "知识图谱"}]}
{"text": "节点可以是实体，如一个人、一本书等，或是抽象的概念，如人工智能、知识图谱等。", "relation": [{"head": "节点", "head_type": "知识图谱", "relation": "内容", "tail": "实体和概念", "tail_type": "文本"}]}
{"text": "边可以是实体的属性，如姓名、书名，或是实体之间的关系，如朋友、配偶。", "relation": [{"head": "边", "head_type": "知识图谱", "relation": "内容", "tail": "实体的属性和实体之间的关系", "tail_type": "文本"}]}
{"text": "知识图谱的早期理念来自Semantic_Web[2,3]（语义网），其最初理想是把基于文本链接的万维网转化成基于实体链接的语义网。", "relation": [{"head": "知识图谱", "head_type": "知识图谱", "relation": "来源", "tail": "Semantic_Web", "tail_type": "知识图谱"}, {"head": "语义网", "head_type": "知识图谱", "relation": "目标", "tail": "把基于文本链接的万维网转化成基于实体链接的语义网", "tail_type": "文本"}, {"head": "语义网", "head_type": "知识图谱", "relation": "英文名", "tail": "Semantic_Web", "tail_type": "文本"}]}
{"text": "Semantic_Web仍然基于图和链接的组织方式，只是图中的节点代表的不只是网页，而是客观世界中的实体（如人、机构、地点等），而超链接也被增加了语义描述，具体标明实体之间的关系（如出生地是、创办人是等）。", "relation": [{"head": "Semantic_Web", "head_type": "知识图谱", "relation": "由组成", "tail": "图", "tail_type": "知识图谱"}, {"head": "Semantic_Web", "head_type": "知识图谱", "relation": "由组成", "tail": "链接", "tail_type": "知识图谱"}]}
{"text": "相对于传统的网页互联网，Semantic_Web的本质是数据的互联网（Web_of_Data）或事物的互联网（Web_of_Things）。", "relation": [{"head": "Semantic_Web", "head_type": "知识图谱", "relation": "等价", "tail": "数据的互联网", "tail_type": "知识图谱"}, {"head": "Semantic_Web", "head_type": "知识图谱", "relation": "等价", "tail": "事物的互联网", "tail_type": "知识图谱"}, {"head": "数据的互联网", "head_type": "知识图谱", "relation": "英文名", "tail": "Web_of_Data", "tail_type": "文本"}, {"head": "事物的互联网", "head_type": "知识图谱", "relation": "英文名", "tail": "Web_of_Things", "tail_type": "文本"}]}
{"text": "如图1-1所示，知识图谱旨在从数据中识别、发现和推断事物与概念之间的复杂关系，是事物关系的可计算模型。", "relation": [{"head": "知识图谱", "head_type": "知识图谱", "relation": "属于", "tail": "事物关系的可计算模型", "tail_type": "知识图谱"}, {"head": "知识图谱", "head_type": "知识图谱", "relation": "目标", "tail": "在从数据中识别、发现和推断事物与概念之间的复杂关系", "tail_type": "文本"}]}
{"text": "知识图谱的构建涉及知识建模、关系抽取、图存储、关系推理、实体融合等多方面的技术，而知识图谱的应用则涉及语义搜索、智能问答、语言理解、决策分析等多个领域。", "relation": [{"head": "知识图谱构建", "head_type": "知识图谱", "relation": "包含", "tail": "知识建模", "tail_type": "知识图谱"}, {"head": "知识图谱构建", "head_type": "知识图谱", "relation": "包含", "tail": "关系抽取", "tail_type": "知识图谱"}, {"head": "知识图谱构建", "head_type": "知识图谱", "relation": "包含", "tail": "图存储", "tail_type": "知识图谱"}, {"head": "知识图谱构建", "head_type": "知识图谱", "relation": "包含", "tail": "关系推理", "tail_type": "知识图谱"}, {"head": "知识图谱构建", "head_type": "知识图谱", "relation": "包含", "tail": "实体融合", "tail_type": "知识图谱"}, {"head": "知识图谱应用", "head_type": "知识图谱", "relation": "包含", "tail": "语义搜索", "tail_type": "知识图谱"}, {"head": "知识图谱应用", "head_type": "知识图谱", "relation": "包含", "tail": "智能问答", "tail_type": "知识图谱"}, {"head": "知识图谱应用", "head_type": "知识图谱", "relation": "包含", "tail": "语言理解", "tail_type": "知识图谱"}, {"head": "知识图谱应用", "head_type": "知识图谱", "relation": "包含", "tail": "决策分析", "tail_type": "知识图谱"}]}
{"text": "构建并利用好知识图谱需要系统性地利用包括知识表示（Knowledge_Representation）、图数据库、自然语言处理、机器学习等多方面的技术。", "relation": [{"head": "知识图谱构建技术", "head_type": "知识图谱", "relation": "包含", "tail": "知识表示", "tail_type": "知识图谱"}, {"head": "知识图谱构建技术", "head_type": "知识图谱", "relation": "包含", "tail": "图数据库", "tail_type": "知识图谱"}, {"head": "知识图谱构建技术", "head_type": "知识图谱", "relation": "包含", "tail": "自然语言处理", "tail_type": "知识图谱"}, {"head": "知识图谱构建技术", "head_type": "知识图谱", "relation": "包含", "tail": "机器学习", "tail_type": "知识图谱"}]}
{"text": "哲学家柏拉图把知识（Knowledge）定义为“Justified_True_Belief”，即知识需要满足三个核心要素：合理性（Justified）、真实性（True）和被相信（Believed）。", "relation": [{"head": "知识", "head_type": "知识图谱", "relation": "被定义为", "tail": "Justified_True_Belief", "tail_type": "文本"}]}
{"text": "简而言之，知识是人类通过观察、学习和思考有关客观世界的各种现象而获得并总结出的所有事实（Fact）、概念（Concept）、规则（Rule）或原则（Principle）的集合。", "relation": [{"head": "知识", "head_type": "知识图谱", "relation": "被定义为", "tail": "事实、概念、规则或原则的集合", "tail_type": "文本"}]}
{"text": "知识表示是现实世界的可计算模型（Computable_Model_of_Reality）。", "relation": [{"head": "知识表示", "head_type": "知识表示", "relation": "被定义为", "tail": "现实世界的可计算模型", "tail_type": "文本"}, {"head": "世界的可计算模型", "head_type": "知识表示", "relation": "英文名", "tail": "Computable_Model_of_Reality", "tail_type": "文本"}]}
{"text": "早期的专家系统最常用的知识表示方法包括基于框架的语言（Frame-based_Languages）和产生式规则（Production_Rules）等。", "relation": [{"head": "早期的专家系统知识表示方法", "head_type": "知识表示", "relation": "包含", "tail": "基于框架的语言", "tail_type": "知识表示"}, {"head": "早期的专家系统知识表示方法", "head_type": "知识表示", "relation": "包含", "tail": "产生式规则", "tail_type": "知识表示"}, {"head": "基于框架的语言", "head_type": "知识表示", "relation": "英文名", "tail": "Frame-based_Languages", "tail_type": "文本"}, {"head": "产生式规则", "head_type": "知识表示", "relation": "英文名", "tail": "Production_Rules", "tail_type": "文本"}]}
{"text": "框架语言主要用于描述客观世界的类别、个体、属性及关系等，较多地被应用于辅助自然语言理解。", "relation": [{"head": "框架语言", "head_type": "知识表示", "relation": "作用", "tail": "描述客观世界的类别、个体、属性及关系等", "tail_type": "文本"}]}
{"text": "产生式规则主要用于描述类似于IF-THEN的逻辑结构，适合于刻画过程性知识。", "relation": [{"head": "产生式规则", "head_type": "知识表示", "relation": "作用", "tail": "描述类似于IF-THEN的逻辑结构，适合于刻画过程性知识。", "tail_type": "文本"}]}
{"text": "如图1-4所示，传统的知识库，如Douglas_Lenat从1984年开始创建的常识知识库Cyc，仅包含700万条[1]的事实描述（Assertion）。", "relation": [{"head": "知识库", "head_type": "知识图谱项目", "relation": "包含", "tail": "Cyc", "tail_type": "知识图谱项目"}]}
{"text": "由著名人工智能专家Marvin_Minsky于1999年起开始构建的ConceptNet[24]常识知识库依靠了互联网众规模在百万级别，最新的包、专家创建和游戏三种方法，但早期的ConceptNet5.0也仅包含2800万个RDF三元组关系描述。", "relation": [{"head": "知识库", "head_type": "知识图谱项目", "relation": "包含", "tail": "ConceptNet", "tail_type": "知识图谱项目"}, {"head": "ConceptNet", "head_type": "知识图谱项目", "relation": "创建时间", "tail": "1999", "tail_type": "时间"}, {"head": "ConceptNet", "head_type": "知识图谱项目", "relation": "创建者", "tail": "Marvin_Minsky", "tail_type": "人物/实验室"}]}
{"text": "随后，知识图谱在辅助智能问答、自然语言理解、大数据分析、推荐计算、物联网设备互联、可解释性人工智能等多个方面展现出丰富的应用价值。", "relation": [{"head": "知识图谱应用", "head_type": "知识图谱", "relation": "包含", "tail": "辅助智能问答", "tail_type": "知识图谱"}, {"head": "知识图谱应用", "head_type": "知识图谱", "relation": "包含", "tail": "自然语言理解", "tail_type": "知识图谱"}, {"head": "知识图谱应用", "head_type": "知识图谱", "relation": "包含", "tail": "大数据分析", "tail_type": "知识图谱"}, {"head": "知识图谱应用", "head_type": "知识图谱", "relation": "包含", "tail": "推荐计算", "tail_type": "知识图谱"}, {"head": "知识图谱应用", "head_type": "知识图谱", "relation": "包含", "tail": "物联网设备互联", "tail_type": "知识图谱"}, {"head": "知识图谱应用", "head_type": "知识图谱", "relation": "包含", "tail": "可解释性人工智能", "tail_type": "知识图谱"}]}
{"text": "除了辅助搜索，知识图谱也被广泛用于人机问答交互中。", "relation": [{"head": "知识图谱应用", "head_type": "知识图谱", "relation": "包含", "tail": "人机问答交互", "tail_type": "知识图谱"}]}
{"text": "在产业界，IBM_Watson背后依托DBpedia和Yago等百科知识库和WordNet等语言学知识库实现深度知识问答。", "relation": [{"head": "IBM_Watson", "head_type": "知识图谱项目", "relation": "属于", "tail": "知识问答项目", "tail_type": "知识问答"}]}
{"text": "Amazon_Alex主要依靠True_Knowledge公司积累的知识图谱。", "relation": [{"head": "Amazon_Alex", "head_type": "知识图谱项目", "relation": "属于", "tail": "知识问答项目", "tail_type": "知识问答"}]}
{"text": "度秘、Siri的进化版Viv、小爱机器人、天猫精灵背后都有海量知识图谱作为支撑。", "relation": [{"head": "度秘", "head_type": "知识图谱项目", "relation": "属于", "tail": "知识问答项目", "tail_type": "知识问答"}]}
{"text": "典型的基于知识图谱的问答技术或方法包括：基于语义解析、基于图匹配、基于模板学习、基于表示学习和深度学习以及基于混合模型等。", "relation": [{"head": "基于知识图谱的问答技术或方法", "head_type": "知识图谱", "relation": "包含", "tail": "基于语义解析", "tail_type": "知识图谱"}, {"head": "基于知识图谱的问答技术或方法", "head_type": "知识图谱", "relation": "包含", "tail": "基于图匹配", "tail_type": "知识图谱"}, {"head": "基于知识图谱的问答技术或方法", "head_type": "知识图谱", "relation": "包含", "tail": "基于模板学习", "tail_type": "知识图谱"}, {"head": "基于知识图谱的问答技术或方法", "head_type": "知识图谱", "relation": "包含", "tail": "基于表示学习", "tail_type": "知识图谱"}, {"head": "基于知识图谱的问答技术或方法", "head_type": "知识图谱", "relation": "包含", "tail": "基于混合模型", "tail_type": "知识图谱"}]}
{"text": "3.辅助大数据分析知识图谱和语义技术也被用于辅助进行数据分析与决策。", "relation": [{"head": "知识图谱应用", "head_type": "知识图谱", "relation": "包含", "tail": "辅助大数据分析", "tail_type": "知识图谱"}]}
{"text": "例如，知识图谱被广泛用来作为先验知识从文本中抽取实体和关系，如在远程监督中的应用。", "relation": [{"head": "知识图谱应用", "head_type": "知识图谱", "relation": "包含", "tail": "从文本中抽取实体和关系", "tail_type": "知识图谱"}]}
{"text": "知识图谱也被用来辅助实现文本中的实体消歧（Entity_Disambiguation）、指代消解和文本理解等。", "relation": [{"head": "知识图谱应用", "head_type": "知识图谱", "relation": "包含", "tail": "文本中实体消歧", "tail_type": "知识图谱"}, {"head": "知识图谱应用", "head_type": "知识图谱", "relation": "包含", "tail": "指代消解", "tail_type": "知识图谱"}, {"head": "知识图谱应用", "head_type": "知识图谱", "relation": "包含", "tail": "文本理解", "tail_type": "知识图谱"}]}
{"text": "下面分别介绍早期的知识库项目、互联网时代的知识图谱、中文开放知识图谱和垂直领域知识图谱。", "relation": [{"head": "知识图谱项目", "head_type": "知识图谱项目", "relation": "包含", "tail": "早期的知识库项目", "tail_type": "知识图谱项目"}, {"head": "知识图谱项目", "head_type": "知识图谱项目", "relation": "包含", "tail": "互联网时代的知识图谱", "tail_type": "知识图谱项目"}, {"head": "知识图谱项目", "head_type": "知识图谱项目", "relation": "包含", "tail": "中文开放知识图谱", "tail_type": "知识图谱项目"}, {"head": "知识图谱项目", "head_type": "知识图谱项目", "relation": "包含", "tail": "垂直领域知识图谱", "tail_type": "知识图谱项目"}]}
{"text": "1.4.1早期的知识库项目Cyc是持续时间最久、影响范围较广、争议也较多的知识库项目。", "relation": [{"head": "Cyc", "head_type": "知识图谱项目", "relation": "属于", "tail": "早期的知识库项目", "tail_type": "知识图谱项目"}]}
{"text": "Cyc知识库主要由术语（Term）和断言（Assertion）组成。", "relation": [{"head": "Cyc", "head_type": "知识图谱项目", "relation": "由组成", "tail": "术语", "tail_type": "知识图谱项目"}, {"head": "Cyc", "head_type": "知识图谱项目", "relation": "由组成", "tail": "断言", "tail_type": "知识图谱项目"}]}
{"text": "术语包含概念、关系和实体的定义。", "relation": [{"head": "术语", "head_type": "知识图谱项目", "relation": "被定义为", "tail": "概念、关系和实体的定义", "tail_type": "文本"}]}
{"text": "断言用来建立术语之间的关系，既包括事实（Fact）描述，也包含规则（Rule）描述。", "relation": [{"head": "断言", "head_type": "知识图谱项目", "relation": "被定义为", "tail": "建立术语之间的关系", "tail_type": "文本"}]}
{"text": "最新的Cyc知识库已经包含有50万条术语和700万条断言。", "relation": [{"head": "Cyc", "head_type": "知识图谱项目", "relation": "内容", "tail": "50万条术语和700万条断言", "tail_type": "文本"}]}
{"text": "Cyc的主要特点是基于形式化的知识表示方法刻画知识。", "relation": [{"head": "Cyc", "head_type": "知识图谱项目", "relation": "特点", "tail": "基于形式化的知识表示方法刻画知识", "tail_type": "文本"}]}
{"text": "WordNet是最著名的词典知识库，由普林斯顿大学认知科学实验室从1985年开始开发。", "relation": [{"head": "WordNet", "head_type": "知识图谱项目", "relation": "属于", "tail": "早期的知识库项目", "tail_type": "知识图谱项目"}, {"head": "WordNet", "head_type": "知识图谱项目", "relation": "创建时间", "tail": "1985", "tail_type": "时间"}, {"head": "WordNet", "head_type": "知识图谱项目", "relation": "创建者", "tail": "普林斯顿大学认知科学实验室", "tail_type": "人物/实验室"}]}
{"text": "WordNet主要定义了名词、动词、形容词和副词之间的语义关系。", "relation": [{"head": "WordNet", "head_type": "知识图谱项目", "relation": "内容", "tail": "名词、动词、形容词和副词之间的语义关系", "tail_type": "文本"}]}
{"text": "ConceptNet最早源于MIT媒体实验室的OMCS（Open_Mind_Common_Sense）项目。", "relation": [{"head": "ConceptNet", "head_type": "知识图谱项目", "relation": "创建者", "tail": "MIT媒体实验室的OMCS（Open_Mind_Common_Sense）项目", "tail_type": "人物/实验室"}]}
{"text": "与Cyc相比，ConceptNet采用了非形式化、更加接近自然语言的描述，而不是像Cyc一样采用形式化的谓词逻辑。", "relation": [{"head": "ConceptNet", "head_type": "知识图谱项目", "relation": "内容", "tail": "非形式化、更加接近自然语言的描述", "tail_type": "文本"}]}
{"text": "这类知识库的构建方法可以分为三类：互联网众包、专家协作和互联网挖掘。", "relation": [{"head": "互联网时代的知识图谱构建方法", "head_type": "知识图谱项目", "relation": "包含", "tail": "互联网众包", "tail_type": "知识图谱项目"}, {"head": "互联网时代的知识图谱构建方法", "head_type": "知识图谱项目", "relation": "包含", "tail": "专家协作", "tail_type": "知识图谱项目"}, {"head": "互联网时代的知识图谱构建方法", "head_type": "知识图谱项目", "relation": "包含", "tail": "互联网挖掘", "tail_type": "知识图谱项目"}]}
{"text": "Freebase是一个开放共享的、协同构建的大规模链接数据库。", "relation": [{"head": "Freebase", "head_type": "知识图谱项目", "relation": "属于", "tail": "互联网时代的知识图谱", "tail_type": "知识图谱项目"}]}
{"text": "Freebase是由硅谷创业公司MetaWeb于2005年启动的一个语义网项目。", "relation": [{"head": "Freebase", "head_type": "知识图谱项目", "relation": "创建时间", "tail": "2005", "tail_type": "时间"}, {"head": "Freebase", "head_type": "知识图谱项目", "relation": "创建者", "tail": "MetaWeb", "tail_type": "人物/实验室"}]}
{"text": "Freebase基于RDF三元组模型，底层采用图数据库进行存储。", "relation": [{"head": "Freebase", "head_type": "知识图谱项目", "relation": "方法", "tail": "RDF三元组模型", "tail_type": "文本"}]}
{"text": "Freebase的一个特点是不对顶层本体做非常严格的控制，用户可以创建与编辑类和关系的定义。", "relation": [{"head": "Freebase", "head_type": "知识图谱项目", "relation": "特点", "tail": "不对顶层本体做非常严格的控制，用户可以创建与编辑类和关系的定义", "tail_type": "文本"}]}
{"text": "DBpedia采用RDF语义数据模型，总共包含30亿个RDF三元组。", "relation": [{"head": "DBpedia", "head_type": "知识图谱项目", "relation": "属于", "tail": "互联网时代的知识图谱", "tail_type": "知识图谱项目"}, {"head": "DBpedia", "head_type": "知识图谱项目", "relation": "方法", "tail": "RDF语义数据模型", "tail_type": "文本"}]}
{"text": "Schema.org是从2011年开始，由Bing、Google、Yahoo和Yandex等搜索引擎公司共同支持的语义网项目。", "relation": [{"head": "Schema.org", "head_type": "知识图谱项目", "relation": "创建者", "tail": "Bing、Google、Yahoo和Yandex", "tail_type": "人物/实验室"}, {"head": "Schema.org", "head_type": "知识图谱项目", "relation": "创建时间", "tail": "2011", "tail_type": "时间"}]}
{"text": "Schema.org的本质是采用互联网众包的方式生成和收集高质量的知识图谱数据。", "relation": [{"head": "Schema.org", "head_type": "知识图谱项目", "relation": "方法", "tail": "采用互联网众包的方式生成和收集高质量的知识图谱数据", "tail_type": "文本"}]}
{"text": "Wikidata的目标是构建一个免费开放、多语言、任何人或机器都可以编辑修改的大规模链接知识库。", "relation": [{"head": "Wikidata", "head_type": "知识图谱项目", "relation": "属于", "tail": "互联网时代的知识图谱", "tail_type": "知识图谱项目"}, {"head": "Wikidata", "head_type": "知识图谱项目", "relation": "目标", "tail": "构建一个免费开放、多语言、任何人或机器都可以编辑修改的大规模链接知识库", "tail_type": "文本"}]}
{"text": "Wikidata由Wikipedia于2012年启动，早期得到微软联合创始人PaulAllen、Gordon_Betty_Moore基金会以及谷歌的联合资助。", "relation": [{"head": "Wikidata", "head_type": "知识图谱项目", "relation": "创建者", "tail": "Wikipedia", "tail_type": "人物/实验室"}, {"head": "Wikidata", "head_type": "知识图谱项目", "relation": "创建时间", "tail": "2012", "tail_type": "时间"}]}
{"text": "截至2018年，Wikidata已经包含超过5000万个知识条目。", "relation": [{"head": "Wikidata", "head_type": "知识图谱项目", "relation": "内容", "tail": "超过5000万个知识条目", "tail_type": "文本"}]}
{"text": "BabelNet是类似于WordNet的多语言词典知识库。", "relation": [{"head": "BabelNet", "head_type": "知识图谱项目", "relation": "属于", "tail": "互联网时代的知识图谱", "tail_type": "知识图谱项目"}]}
{"text": "BabelNet的目标是解决WordNet在非英语语种中数据缺乏的问题。", "relation": [{"head": "BabelNet", "head_type": "知识图谱项目", "relation": "目标", "tail": "解决WordNet在非英语语种中数据缺乏的问题", "tail_type": "文本"}]}
{"text": "BabelNet采用的方法是将WordNet词典与Wikipedia集成。", "relation": [{"head": "BabelNet", "head_type": "知识图谱项目", "relation": "方法", "tail": "将WordNet词典与Wikipedia集成", "tail_type": "文本"}]}
{"text": "NELL（Never-Ending_Language_Learner）是卡内基梅隆大学开发的知识库。", "relation": [{"head": "NELL", "head_type": "知识图谱项目", "relation": "属于", "tail": "互联网时代的知识图谱", "tail_type": "知识图谱项目"}, {"head": "NELL", "head_type": "知识图谱项目", "relation": "创建者", "tail": "卡内基梅隆大学", "tail_type": "人物/实验室"}]}
{"text": "NELL主要采用互联网挖掘的方法从Web中自动抽取三元组知识。", "relation": [{"head": "NELL", "head_type": "知识图谱项目", "relation": "方法", "tail": "互联网挖掘的方法从Web中自动抽取三元组知识", "tail_type": "文本"}]}
{"text": "Yago是由德国马普研究所研制的链接数据库。", "relation": [{"head": "Yago", "head_type": "知识图谱项目", "relation": "属于", "tail": "互联网时代的知识图谱", "tail_type": "知识图谱项目"}, {"head": "Yago", "head_type": "知识图谱项目", "relation": "创建者", "tail": "德国马普研究所", "tail_type": "人物/实验室"}]}
{"text": "MicrosoftConceptGraph是以概念层次体系为中心的知识图谱。", "relation": [{"head": "MicrosoftConceptGraph", "head_type": "知识图谱项目", "relation": "属于", "tail": "互联网时代的知识图谱", "tail_type": "知识图谱项目"}]}
{"text": "1.4.3中文开放知识图谱OpenKG是一个面向中文域开放知识图谱的社区项目，主要目的是促进中文领域知识图谱数据的开放与互联。", "relation": [{"head": "OpenKG.CN", "head_type": "知识图谱项目", "relation": "属于", "tail": "典型的中文开放知识图谱数据", "tail_type": "知识图谱项目"}]}
{"text": "典型的中文开放知识图谱数据包括百科类的Zhishi.me（狗尾草科技、东南大学）、CN-DBpedia（复旦大学）、XLore（清华大学）、Belief-Engine（中科院自动化所）、PKUPie（北京大学）、ZhOnto（狗尾草科技）等。", "relation": [{"head": "典型的中文开放知识图谱数据", "head_type": "知识图谱项目", "relation": "包含", "tail": "Zhishi.me", "tail_type": "知识图谱项目"}, {"head": "典型的中文开放知识图谱数据", "head_type": "知识图谱项目", "relation": "包含", "tail": "CN-DBpedia", "tail_type": "知识图谱项目"}, {"head": "典型的中文开放知识图谱数据", "head_type": "知识图谱项目", "relation": "包含", "tail": "XLore", "tail_type": "知识图谱项目"}, {"head": "典型的中文开放知识图谱数据", "head_type": "知识图谱项目", "relation": "包含", "tail": "Belief-Engine", "tail_type": "知识图谱项目"}, {"head": "典型的中文开放知识图谱数据", "head_type": "知识图谱项目", "relation": "包含", "tail": "PKUPie", "tail_type": "知识图谱项目"}, {"head": "典型的中文开放知识图谱数据", "head_type": "知识图谱项目", "relation": "包含", "tail": "ZhOnto", "tail_type": "知识图谱项目"}]}
{"text": "1.4.4垂直领域知识图谱领域知识图谱是相对于DBPedia、Yago、Wikidata、百度和谷歌等搜索引擎在使用的知识图谱等通用知识图谱而言的，它是面向特定领域的知识图谱，如电商、金融、医疗等。", "relation": [{"head": "垂直领域知识图谱", "head_type": "知识图谱项目", "relation": "被定义为", "tail": "面向特定领域的知识图谱", "tail_type": "文本"}]}
{"text": "表1-1通用知识图谱与领域知识图谱的比较1.电商领域知识图谱以阿里巴巴电商知识图谱为例[27]，最新发布的知识图谱规模已达到百亿级别。", "relation": [{"head": "阿里巴巴电商知识图谱", "head_type": "知识图谱项目", "relation": "属于", "tail": "垂直领域知识图谱", "tail_type": "知识图谱项目"}]}
{"text": "例如，仅Linked_Life_Data项目包含的RDF三元组规模就达到102亿个[3]，包含从基因、蛋白质、疾病、化学、神经科学、药物等多个领域的知识。", "relation": [{"head": "Linked_Life_Data", "head_type": "知识图谱项目", "relation": "属于", "tail": "垂直领域知识图谱", "tail_type": "知识图谱项目"}]}
{"text": "医学领域的知识结构更加复杂[29-31]，如医学语义网络UMLS包含大量复杂的语义关系，GeneOnto[29]则包含复杂的类层次结构。", "relation": [{"head": "UMLS", "head_type": "知识图谱项目", "relation": "属于", "tail": "垂直领域知识图谱", "tail_type": "知识图谱项目"}, {"head": "GeneOnto", "head_type": "知识图谱项目", "relation": "属于", "tail": "垂直领域知识图谱", "tail_type": "知识图谱项目"}]}
{"text": "3.金融领域知识图谱金融领域比较典型的例子如Kensho采用知识图谱辅助投资顾问和投资研究，国内以恒生电子为代表的金融科技机构以及不少银行、证券机构等也都在开展金融领域的知识图谱构建工作。", "relation": [{"head": "Kensho", "head_type": "知识图谱项目", "relation": "属于", "tail": "垂直领域知识图谱", "tail_type": "知识图谱项目"}]}
{"text": "1.知识来源可以从多种来源获取知识图谱数据，包括文本、结构化数据库、多媒体数据、传感器数据和人工众包等。", "relation": [{"head": "知识图谱构建", "head_type": "知识图谱", "relation": "包含", "tail": "知识来源", "tail_type": "知识图谱"}, {"head": "知识来源", "head_type": "知识图谱", "relation": "包含", "tail": "文本", "tail_type": "知识图谱"}, {"head": "知识来源", "head_type": "知识图谱", "relation": "包含", "tail": "结构化数据库", "tail_type": "知识图谱"}, {"head": "知识来源", "head_type": "知识图谱", "relation": "包含", "tail": "多媒体数据", "tail_type": "知识图谱"}, {"head": "知识来源", "head_type": "知识图谱", "relation": "包含", "tail": "传感器数据", "tail_type": "知识图谱"}, {"head": "知识来源", "head_type": "知识图谱", "relation": "包含", "tail": "人工众包", "tail_type": "知识图谱"}]}
{"text": "2.知识表示与Schema工程知识表示是指用计算机符号描述和表示人脑中的知识，以支持机器模拟人的心智进行推理的方法与技术。", "relation": [{"head": "知识表示", "head_type": "知识表示", "relation": "被定义为", "tail": "用计算机符号描述和表示人脑中的知识", "tail_type": "文本"}]}
{"text": "知识表示决定了图谱构建的产出目标，即知识图谱的语义描述框架（Description_Framework）、Schema与本体（Ontology）、知识交换语法（Syntax）、实体命名及ID体系。", "relation": [{"head": "知识图谱构建", "head_type": "知识图谱构建", "relation": "目标", "tail": "语义描述框架", "tail_type": "知识图谱"}, {"head": "知识图谱构建", "head_type": "知识图谱构建", "relation": "目标", "tail": "Schema与本体", "tail_type": "知识图谱"}, {"head": "知识图谱构建", "head_type": "知识图谱构建", "relation": "目标", "tail": "交换语法", "tail_type": "知识图谱"}, {"head": "知识图谱构建", "head_type": "知识图谱构建", "relation": "目标", "tail": "实体命名", "tail_type": "知识图谱"}, {"head": "知识图谱构建", "head_type": "知识图谱构建", "relation": "目标", "tail": "ID体系", "tail_type": "知识图谱"}, {"head": "语义描述框架", "head_type": "知识图谱构建", "relation": "英文名", "tail": "Description_Framework", "tail_type": "文本"}, {"head": "知识交换语法", "head_type": "知识图谱构建", "relation": "英文名", "tail": "Syntax", "tail_type": "文本"}]}
{"text": "基本描述框架定义知识图谱的基本数据模型（DataModel）和逻辑结构（Structure），如国际万维网联盟（World_Wide_Web_Consortium,W3C）的RDF。", "relation": [{"head": "语义描述框架", "head_type": "知识图谱构建", "relation": "定义", "tail": "知识图谱的基本数据模型和逻辑结构", "tail_type": "文本"}]}
{"text": "Schema与本体定义知识图谱的类集、属性集、关系集和词汇集。", "relation": [{"head": "Schema与本体", "head_type": "知识图谱构建", "relation": "定义", "tail": "知识图谱的类集、属性集、关系集和词汇集", "tail_type": "文本"}]}
{"text": "交换语法定义知识实际存在的物理格式，如Turtle、JSON等。", "relation": [{"head": "交换语法", "head_type": "知识图谱构建", "relation": "定义", "tail": "知识实际存在的物理格式", "tail_type": "文本"}]}
{"text": "实体命名及ID体系定义实体的命名原则及唯一标识规范等。", "relation": [{"head": "实体命名及ID体系", "head_type": "知识图谱构建", "relation": "定义", "tail": "定义实体的命名原则及唯一标识规范等", "tail_type": "文本"}]}
{"text": "按知识类型的不同，知识图谱包括词（Vocabulary）、实体（Entity）、关系（Relation）、事件（Event）、术语体系（Taxonomy）、规则（Rule）等。", "relation": [{"head": "知识图谱", "head_type": "知识图谱", "relation": "由组成", "tail": "词", "tail_type": "知识图谱"}, {"head": "知识图谱", "head_type": "知识图谱", "relation": "由组成", "tail": "实体", "tail_type": "知识图谱"}, {"head": "知识图谱", "head_type": "知识图谱", "relation": "由组成", "tail": "关系", "tail_type": "知识图谱"}, {"head": "知识图谱", "head_type": "知识图谱", "relation": "由组成", "tail": "事件", "tail_type": "知识图谱"}, {"head": "知识图谱", "head_type": "知识图谱", "relation": "由组成", "tail": "术语体系", "tail_type": "知识图谱"}, {"head": "知识图谱", "head_type": "知识图谱", "relation": "由组成", "tail": "规则", "tail_type": "知识图谱"}, {"head": "词", "head_type": "知识图谱", "relation": "英文名", "tail": "Vocabulary", "tail_type": "文本"}, {"head": "实体", "head_type": "知识图谱", "relation": "英文名", "tail": "Entity", "tail_type": "文本"}, {"head": "关系", "head_type": "知识图谱", "relation": "英文名", "tail": "Relation", "tail_type": "文本"}, {"head": "事件", "head_type": "知识图谱", "relation": "英文名", "tail": "Event", "tail_type": "文本"}, {"head": "术语体系", "head_type": "知识图谱", "relation": "英文名", "tail": "Taxonomy", "tail_type": "文本"}, {"head": "规则", "head_type": "知识图谱", "relation": "英文名", "tail": "Rule", "tail_type": "文本"}]}
{"text": "词一级的知识以词为中心，并定义词与词之间的关系，如WordNet、ConceptNet等。", "relation": [{"head": "词", "head_type": "知识图谱", "relation": "定义", "tail": "词与词之间的关系", "tail_type": "文本"}]}
{"text": "实体一级的知识以实体为中心，并定义实体之间的关系、描述实体的术语体系等。", "relation": [{"head": "实体", "head_type": "知识图谱", "relation": "定义", "tail": "实体之间的关系", "tail_type": "文本"}]}
{"text": "3.知识抽取知识抽取按任务可以分为概念抽取、实体识别、关系抽取、事件抽取和规则抽取等。", "relation": [{"head": "知识图谱构建", "head_type": "知识图谱构建", "relation": "包含", "tail": "知识抽取", "tail_type": "知识抽取"}, {"head": "知识抽取", "head_type": "知识抽取", "relation": "包含", "tail": "概念抽取", "tail_type": "知识抽取"}, {"head": "知识抽取", "head_type": "知识抽取", "relation": "包含", "tail": "实体识别", "tail_type": "知识抽取"}, {"head": "知识抽取", "head_type": "知识抽取", "relation": "包含", "tail": "关系抽取", "tail_type": "知识抽取"}, {"head": "知识抽取", "head_type": "知识抽取", "relation": "包含", "tail": "事件抽取", "tail_type": "知识抽取"}, {"head": "知识抽取", "head_type": "知识抽取", "relation": "包含", "tail": "规则抽取", "tail_type": "知识抽取"}]}
{"text": "结构化和文本数据是目前最主要的知识来源。", "relation": [{"head": "知识来源", "head_type": "知识抽取", "relation": "包含", "tail": "从结构化数据库中获取知识", "tail_type": "知识抽取"}, {"head": "知识来源", "head_type": "知识抽取", "relation": "包含", "tail": "从文本数据中获取知识", "tail_type": "知识抽取"}]}
{"text": "从结构化数据库中获取知识一般使用现有的D2R工具[32]，如Triplify、D2RServer、OpenLink、SparqlMap、Ontop等。", "relation": [{"head": "从结构化数据库中获取知识", "head_type": "知识抽取", "relation": "方法", "tail": "D2R工具", "tail_type": "知识抽取"}, {"head": "D2R工具", "head_type": "知识抽取", "relation": "包含", "tail": "Triplify", "tail_type": "知识抽取"}, {"head": "D2R工具", "head_type": "知识抽取", "relation": "包含", "tail": "D2RServer", "tail_type": "知识抽取"}, {"head": "D2R工具", "head_type": "知识抽取", "relation": "包含", "tail": "OpenLink", "tail_type": "知识抽取"}, {"head": "D2R工具", "head_type": "知识抽取", "relation": "包含", "tail": "SparqlMap", "tail_type": "知识抽取"}, {"head": "D2R工具", "head_type": "知识抽取", "relation": "包含", "tail": "Ontop", "tail_type": "知识抽取"}]}
{"text": "从文本中获取知识主要包括实体识别和关系抽取。", "relation": [{"head": "从文本中获取知识", "head_type": "知识抽取", "relation": "包含", "tail": "实体识别", "tail_type": "知识抽取"}, {"head": "从文本中获取知识", "head_type": "知识抽取", "relation": "包含", "tail": "关系抽取", "tail_type": "知识抽取"}]}
{"text": "以关系抽取为例，典型的关系抽取方法可以分为基于特征模板的方法[33-35]、基于核函数的监督学习方法[36-44]、基于远程监督的方法[45,46]和基于深度学习的监督或远程监督方法，如简单CNN、MP-CNN、MWK-CNN、PCNN、PCNN+Att和MIMLCNN等[47-52]。", "relation": [{"head": "关系抽取", "head_type": "知识抽取", "relation": "包含", "tail": "基于特征模板的方法", "tail_type": "知识抽取"}, {"head": "关系抽取", "head_type": "知识抽取", "relation": "包含", "tail": "基于核函数的监督学习方法", "tail_type": "知识抽取"}, {"head": "关系抽取", "head_type": "知识抽取", "relation": "包含", "tail": "基于远程监督的方法", "tail_type": "知识抽取"}, {"head": "关系抽取", "head_type": "知识抽取", "relation": "包含", "tail": "基于深度学习的监督或远程监督方法", "tail_type": "知识抽取"}]}
{"text": "远程监督的思想是，利用一个大型的语义数据库自动获取关系类型标签。", "relation": [{"head": "基于远程监督的方法", "head_type": "知识抽取", "relation": "被定义为", "tail": "利用大型的语义数据库自动获取关系类型标签", "tail_type": "文本"}]}
{"text": "另外，一些工作通过多任务学习等方法将实体和关系做联合抽取[46,53]。", "relation": [{"head": "从文本中获取知识", "head_type": "知识抽取", "relation": "方法", "tail": "将实体和关系做联合抽取", "tail_type": "文本"}]}
{"text": "4.知识融合在构建知识图谱时，可以从第三方知识库产品或已有结构化数据中获取知识输入。", "relation": [{"head": "知识图谱构建", "head_type": "知识图谱", "relation": "包含", "tail": "知识融合", "tail_type": "知识融合"}]}
{"text": "数据层的融合是指实体和关系（包括属性）元组的融合，主要是实体匹配或者对齐，由于知识库中有些实体含义相同但是具有不同的标识符，因此需要对这些实体进行合并处理[55,56]。", "relation": [{"head": "知识融合", "head_type": "知识融合", "relation": "包含", "tail": "数据层的融合", "tail_type": "知识融合"}, {"head": "数据层的融合", "head_type": "知识融合", "relation": "被定义为", "tail": "实体和关系（包括属性）元组的融合", "tail_type": "文本"}, {"head": "数据层的融合", "head_type": "知识融合", "relation": "包含", "tail": "实体匹配", "tail_type": "知识融合"}, {"head": "数据层的融合", "head_type": "知识融合", "relation": "包含", "tail": "实体对齐", "tail_type": "知识融合"}]}
{"text": "此外，还需要对新增实体和关系进行验证和评估，以确保知识图谱的内容一致性和准确性，通常采用的方法是在评估过程中为新加入的知识赋予可信度值，据此进行知识的过滤和融合。", "relation": [{"head": "数据层的融合", "head_type": "知识融合", "relation": "包含", "tail": "对新增实体和关系进行验证和评估", "tail_type": "知识融合"}, {"head": "对新增实体和关系进行验证和评估", "head_type": "知识融合", "relation": "方法", "tail": "在评估过程中为新加入的知识赋予可信度值，据此进行知识的过滤和融合", "tail_type": "文本"}]}
{"text": "实体对齐的任务包括实体消歧和共指消解，即判断知识库中的同名实体是否代表不同的含义以及知识库中是否存在其他命名实体表示相同的含义。", "relation": [{"head": "实体对齐", "head_type": "知识融合", "relation": "包含", "tail": "实体消歧", "tail_type": "知识融合"}, {"head": "实体消歧", "head_type": "知识融合", "relation": "被定义为", "tail": "判断知识库中的同名实体是否代表不同的含义", "tail_type": "文本"}, {"head": "实体对齐", "head_type": "知识融合", "relation": "包含", "tail": "共指消解", "tail_type": "知识融合"}, {"head": "共指消解", "head_type": "知识融合", "relation": "被定义为", "tail": "判断知识库中是否存在其他命名实体表示相同的含义", "tail_type": "文本"}]}
{"text": "一些最新的工作利用知识图谱嵌入方法进行实体对齐，并引入人机协作方式提升实体对齐的质量[62,63]。", "relation": [{"head": "实体对齐", "head_type": "知识融合", "relation": "包含", "tail": "知识图谱嵌入方法", "tail_type": "知识融合"}]}
{"text": "本体是针对特定领域中Schema定义、概念模型和公理定义而言的，目的是弥合词汇异构性和语义歧义的间隙，使沟通达成共识。", "relation": [{"head": "本体", "head_type": "知识图谱", "relation": "目标", "tail": "弥合词汇异构性和语义歧义的间隙", "tail_type": "文本"}]}
{"text": "因此，本体对齐通常带来的是共识模式的演化和变化，本体对齐的主要问题之一也可以转化为怎样管理这种演化和变化[64]。", "relation": [{"head": "本体对齐", "head_type": "知识融合", "relation": "目标", "tail": "管理共识模式的演化和变化", "tail_type": "文本"}]}
{"text": "常见的本体演化管理框架有KAON[65]、Conto-diff[66]、OntoView等。", "relation": [{"head": "本体演化管理框架", "head_type": "知识融合", "relation": "包含", "tail": "KAON", "tail_type": "知识图谱项目"}, {"head": "本体演化管理框架", "head_type": "知识融合", "relation": "包含", "tail": "Conto-diff", "tail_type": "知识图谱项目"}, {"head": "本体演化管理框架", "head_type": "知识融合", "relation": "包含", "tail": "OntoView", "tail_type": "知识图谱项目"}]}
{"text": "5.知识图谱补全与推理常用的知识图谱补全方法包括：基于本体推理的补全方法，如基于描述逻辑的推理[67-69]，以及相关的推理机实现，如RDFox、Pellet、RACER、HermiT、TrOWL等。", "relation": [{"head": "知识图谱补全方法", "head_type": "知识推理", "relation": "包含", "tail": "基于本体推理的补全方法", "tail_type": "知识推理"}, {"head": "本体推理的补全方法", "head_type": "知识推理", "relation": "包含", "tail": "基于描述逻辑的推理", "tail_type": "知识推理"}]}
{"text": "5.知识图谱补全与推理常用的知识图谱补全方法包括：基于本体推理的补全方法，如基于描述逻辑的推理[67-70]，以及相关的推理机实现，如RDFox、Pellet、RACER、HermiT、TrOWL等。", "relation": [{"head": "本体推理的补全方法", "head_type": "知识推理", "relation": "包含", "tail": "相关的推理机实现", "tail_type": "知识推理"}]}
{"text": "这类推理主要针对TBox，即概念层进行推理，也可以用来对实体级的关系进行补全。", "relation": [{"head": "基于本体推理的补全方法", "head_type": "知识推理", "relation": "特点", "tail": "对概念层进行推理，对实体级的关系进行补全", "tail_type": "文本"}]}
{"text": "另外一类的知识补全算法实现基于图结构和关系路径特征的方法，如基于随机游走获取路径特征的PRA算法[70]、基于子图结构的SFE算法[71]、基于层次化随机游走模型的PRA算法[72]。", "relation": [{"head": "知识图谱补全方法", "head_type": "知识推理", "relation": "包含", "tail": "基于图结构和关系路径特征的方法", "tail_type": "知识推理"}, {"head": "基于图结构和关系路径特征的方法", "head_type": "知识推理", "relation": "包含", "tail": "基于随机游走获取路径特征的PRA算法[", "tail_type": "知识推理"}, {"head": "基于图结构和关系路径特征的方法", "head_type": "知识推理", "relation": "包含", "tail": "基于子图结构的SFE算法", "tail_type": "知识推理"}, {"head": "基于图结构和关系路径特征的方法", "head_type": "知识推理", "relation": "包含", "tail": "基于层次化随机游走模型的PRA算法", "tail_type": "知识推理"}]}
{"text": "这类算法的共同特点是通过两个实体节点之间的路径，以及节点周围图的结构提取特征，并通过随机游走等算法降低特征抽取的复杂度，然后叠加线性的学习模型进行关系的预测。", "relation": [{"head": "基于图结构和关系路径特征的方法", "head_type": "知识推理", "relation": "特点", "tail": "通过两个实体节点之间的路径，以及节点周围图的结构提取特征，并通过随机游走等算法降低特征抽取的复杂度，然后叠加线性的学习模型进行关系的预测", "tail_type": "文本"}]}
{"text": "这类简单的嵌入模型一般只能实现单步的推理。", "relation": [{"head": "知识图谱补全方法", "head_type": "知识推理", "relation": "包含", "tail": "基于表示学习和知识图谱嵌入的链接预测", "tail_type": "知识推理"}]}
{"text": "对于更为复杂的模型，如向量空间中引入随机游走模型的方法，在同一个向量空间中将路径与实体和关系一起表示出来再进行补全的模型[81,82]。", "relation": [{"head": "基于表示学习和知识图谱嵌入的链接预测", "head_type": "知识推理", "relation": "包含", "tail": "向量空间中引入随机游走模型的方法", "tail_type": "知识推理"}]}
{"text": "文本信息也被用来辅助实现知识图谱的补全[83-88]。", "relation": [{"head": "文本信息", "head_type": "知识推理", "relation": "实现", "tail": "知识图谱的补全", "tail_type": "知识推理"}]}
{"text": "6.知识检索与知识分析基于知识图谱的知识检索的实现形式主要包括语义检索和智能问答。", "relation": [{"head": "知识图谱", "head_type": "知识图谱", "relation": "包含", "tail": "语义检索", "tail_type": "语义搜索"}, {"head": "知识图谱", "head_type": "知识图谱", "relation": "包含", "tail": "知识问答", "tail_type": "知识问答"}]}
{"text": "传统搜索引擎依靠网页之间的超链接实现网页的搜索，而语义搜索直接对事物进行搜索，如人物、机构、地点等。", "relation": [{"head": "语义搜索", "head_type": "语义搜索", "relation": "被定义为", "tail": "直接对事物进行搜索", "tail_type": "文本"}]}
{"text": "知识图谱的主要数据模型有RDF图（RDF_graph）和属性图（Property_Graph）两种；知识图谱查询语言可分为声明式（Declarative）和导航式（Navigational）两类。", "relation": [{"head": "知识图谱数据类型", "head_type": "知识存储", "relation": "包含", "tail": "RDF图", "tail_type": "知识存储"}, {"head": "知识图谱数据类型", "head_type": "知识存储", "relation": "包含", "tail": "属性图", "tail_type": "知识存储"}, {"head": "知识图谱查询语言", "head_type": "知识存储", "relation": "包含", "tail": "声明式查询语言", "tail_type": "知识存储"}, {"head": "知识图谱查询语言", "head_type": "知识存储", "relation": "包含", "tail": "导航式查询语言", "tail_type": "知识存储"}]}
{"text": "RDF三元组库主要是由Semantic_Web领域推动开发的数据库管理系统，其数据模型RDF图和查询语言SPARQL均遵守W3C标准。", "relation": [{"head": "RDF三元组库", "head_type": "知识存储", "relation": "属于", "tail": "数据库管理系统", "tail_type": "知识存储"}, {"head": "RDF三元组库数据模型", "head_type": "知识存储", "relation": "等价", "tail": "RDF图", "tail_type": "知识存储"}, {"head": "RDF三元组库查询语言", "head_type": "知识存储", "relation": "等价", "tail": "SPARQL", "tail_type": "知识存储"}]}
{"text": "查询语言SPARQL从语法上借鉴了SQL语言，属于声明式查询语言。", "relation": [{"head": "SPARQL", "head_type": "知识存储", "relation": "属于", "tail": "声明式查询语言", "tail_type": "知识存储"}]}
{"text": "Cypher是开源图数据库Neo4j中实现的图查询语言。", "relation": [{"head": "Cypher", "head_type": "知识存储", "relation": "属于", "tail": "图查询语言", "tail_type": "知识存储"}]}
{"text": "PGQL是Oracle公司开发的图查询语言。", "relation": [{"head": "PGQL", "head_type": "知识存储", "relation": "创建者", "tail": "Oracle", "tail_type": "人物/实验室"}, {"head": "PGQL", "head_type": "知识存储", "relation": "属于", "tail": "图查询语言", "tail_type": "知识存储"}]}
{"text": "G-Core是由LDBC（Linked_Data_Benchmarks_Council）组织设计的图查询语言。", "relation": [{"head": "G-Core", "head_type": "知识存储", "relation": "创建者", "tail": "LDBC", "tail_type": "人物/实验室"}, {"head": "G-Core", "head_type": "知识存储", "relation": "属于", "tail": "图查询语言", "tail_type": "知识存储"}]}
{"text": "目前，基于三元组库和图数据库能够提供的知识图谱数据存储方案可分为三类：（1）基于关系的存储方案。", "relation": [{"head": "存储方案", "head_type": "知识存储", "relation": "包含", "tail": "基于关系的存储方案", "tail_type": "知识存储"}]}
{"text": "包括三元组表、水平表、属性表、垂直划分、六重索引和DB2RDF等。", "relation": [{"head": "基于关系的存储方案", "head_type": "知识存储", "relation": "包含", "tail": "水平表", "tail_type": "知识存储"}, {"head": "基于关系的存储方案", "head_type": "知识存储", "relation": "包含", "tail": "属性表", "tail_type": "知识存储"}, {"head": "基于关系的存储方案", "head_type": "知识存储", "relation": "包含", "tail": "垂直划分", "tail_type": "知识存储"}, {"head": "基于关系的存储方案", "head_type": "知识存储", "relation": "包含", "tail": "六重索引", "tail_type": "知识存储"}, {"head": "基于关系的存储方案", "head_type": "知识存储", "relation": "包含", "tail": "DB2RDF", "tail_type": "知识存储"}]}
{"text": "三元组表是将知识图谱中的每条三元组存储为一行具有三列的记录（主语，谓语，宾语）。", "relation": [{"head": "三元组表", "head_type": "知识存储", "relation": "被定义为", "tail": "将知识图谱中的每条三元组存储为一行具有三列的记录（主语，谓语，宾语）。", "tail_type": "文本"}]}
{"text": "三元组表存储方案虽然简单明了，但三元组表的行数与知识图谱的边数一样，其问题是将知识图谱查询翻译为SQL后会产生大量三元组表的自连接操作，影响效率。", "relation": [{"head": "三元组表", "head_type": "知识存储", "relation": "特点", "tail": "简单明了", "tail_type": "文本"}, {"head": "三元组表", "head_type": "知识存储", "relation": "缺点", "tail": "将知识图谱查询翻译为SQL后会产生大量三元组表的自连接操作", "tail_type": "文本"}]}
{"text": "水平表存储方案的每行记录存储知识图谱中一个主语的所有谓语和宾语，相当于知识图谱的邻接表。", "relation": [{"head": "水平表", "head_type": "知识存储", "relation": "被定义为", "tail": "每行记录存储知识图谱中一个主语的所有谓语和宾语", "tail_type": "文本"}]}
{"text": "但其缺点在于所需列数目过多，表中产生大量空值，无法存储多值宾语等。", "relation": [{"head": "水平表", "head_type": "知识存储", "relation": "缺点", "tail": "所需列数目过多，表中产生大量空值，无法存储多值宾语等", "tail_type": "文本"}]}
{"text": "属性表存储方案将同一类主语分配到一个表中，是对水平表存储方案的细化。", "relation": [{"head": "属性表", "head_type": "知识存储", "relation": "被定义为", "tail": "将同一类主语分配到一个表中", "tail_type": "文本"}]}
{"text": "属性表解决了三元组表的自连接问题和水平表的列数目过多问题。", "relation": [{"head": "属性表", "head_type": "知识存储", "relation": "特点", "tail": "解决了三元组表的自连接问题和水平表的列数目过多问题", "tail_type": "文本"}]}
{"text": "但对于真实大规模知识图谱，属性表的问题包括：所需属性表过多，复杂查询的多表连接效率，空值问题和多值宾语问题。", "relation": [{"head": "属性表", "head_type": "知识存储", "relation": "缺点", "tail": "所需属性表过多，复杂查询的多表连接效率，空值问题和多值宾语问题", "tail_type": "文本"}]}
{"text": "垂直划分存储方案为知识图谱中的每种谓语建立一张两列的表（主语，宾语），表中存放由该谓语连接的主语和宾语，支持“主语-主语”作为连接条件的查询操作的快速执行。", "relation": [{"head": "垂直划分", "head_type": "知识存储", "relation": "被定义为", "tail": "每种谓语建立一张两列的表（主语，宾语）", "tail_type": "文本"}]}
{"text": "垂直划分有效解决了空值问题和多值宾语问题；但其仍有缺点，包括：大规模知识图谱的谓语表数目过多、复杂查询表连接过多、更新维护代价大等。", "relation": [{"head": "垂直划分", "head_type": "知识存储", "relation": "特点", "tail": "有效解决空值问题和多值宾语问题", "tail_type": "文本"}, {"head": "垂直划分", "head_type": "知识存储", "relation": "缺点", "tail": "大规模知识图谱的谓语表数目过多、复杂查询表连接过多、更新维护代价大等", "tail_type": "文本"}]}
{"text": "六重索引存储方案是将三元组全部6种排列对应地建立为6张表。", "relation": [{"head": "六重索引", "head_type": "知识存储", "relation": "被定义为", "tail": "将三元组全部6种排列对应地建立为6张表", "tail_type": "文本"}]}
{"text": "六重索引通过“空间交换时间”策略有效缓解了三元组表的自连接问题，但需要更多的存储空间开销和索引更新维护代价。", "relation": [{"head": "六重索引", "head_type": "知识存储", "relation": "特点", "tail": "缓解三元组表的自连接问题", "tail_type": "文本"}, {"head": "六重索引", "head_type": "知识存储", "relation": "缺点", "tail": "需要更多的存储空间开销和索引更新维护代价", "tail_type": "文本"}]}
{"text": "三元组表的灵活性体现在“行维度”上，无论多少行三元组数据，表模式只有3列固定不变；DB2RDF方案将这种灵活性推广到了“列维度”，列名称不再和谓语绑定，将同一主语的所有谓语和宾语动态分配到某列。", "relation": [{"head": "DB2RDF", "head_type": "知识存储", "relation": "被定义为", "tail": "列名称不再和谓语绑定，将同一主语的所有谓语和宾语动态分配到某列", "tail_type": "文本"}]}
{"text": "（2）面向RDF的三元组库。", "relation": [{"head": "存储方案", "head_type": "知识存储", "relation": "包含", "tail": "面向RDF的三元组库", "tail_type": "知识存储"}]}
{"text": "主要的RDF三元组库包括：商业系统Virtuoso、AllegroGraph、GraphDB和BlazeGraph，开源系统Jena、RDF-3X和gStore[96]。", "relation": [{"head": "Virtuoso", "head_type": "知识图谱项目", "relation": "属于", "tail": "面向RDF的三元组库", "tail_type": "知识存储"}, {"head": "AllegroGraph", "head_type": "知识图谱项目", "relation": "属于", "tail": "面向RDF的三元组库", "tail_type": "知识存储"}, {"head": "GraphDB", "head_type": "知识图谱项目", "relation": "属于", "tail": "面向RDF的三元组库", "tail_type": "知识存储"}, {"head": "BlazeGraph", "head_type": "知识图谱项目", "relation": "属于", "tail": "面向RDF的三元组库", "tail_type": "知识存储"}, {"head": "Jena", "head_type": "知识图谱项目", "relation": "属于", "tail": "面向RDF的三元组库", "tail_type": "知识存储"}, {"head": "RDF-3X", "head_type": "知识图谱项目", "relation": "属于", "tail": "面向RDF的三元组库", "tail_type": "知识存储"}, {"head": "gStore", "head_type": "知识图谱项目", "relation": "属于", "tail": "面向RDF的三元组库", "tail_type": "知识存储"}]}
{"text": "RDF4J目前是Eclipse基金会旗下的开源孵化项目，其功能包括RDF数据的解析、存储、推理和查询等。", "relation": [{"head": "RDF4J", "head_type": "知识图谱项目", "relation": "创建者", "tail": "Eclipse", "tail_type": "人物/实验室"}]}
{"text": "RDF4J框架的主要特点是其模块化的软件架构设计。", "relation": [{"head": "RDF4J", "head_type": "知识图谱项目", "relation": "特点", "tail": "模块化的软件架构设计", "tail_type": "文本"}]}
{"text": "RDF-3X是德国马克斯·普朗克计算机科学研究所开发的三元组数据库，其特点是为RDF优化设计的物理存储方案和查询处理方法，是实现六重索引的典型系统。", "relation": [{"head": "RDF-3X", "head_type": "知识图谱项目", "relation": "属于", "tail": "面向RDF的三元组库", "tail_type": "知识存储"}]}
{"text": "RDF-4X是德国马克斯·普朗克计算机科学研究所开发的三元组数据库，其特点是为RDF优化设计的物理存储方案和查询处理方法，是实现六重索引的典型系统。", "relation": [{"head": "RDF-3X", "head_type": "知识图谱项目", "relation": "创建者", "tail": "马克斯·普朗克计算机科学研究所", "tail_type": "人物/实验室"}, {"head": "RDF-3X", "head_type": "知识图谱项目", "relation": "特点", "tail": "为RDF优化设计的物理存储方案和查询处理方法", "tail_type": "文本"}]}
{"text": "gStore是由北京大学、加拿大滑铁卢大学和香港科技大学联合研究项目开发的基于图RDF三元组数据库。", "relation": [{"head": "gStore", "head_type": "知识图谱项目", "relation": "创建者", "tail": "北京大学、加拿大滑铁卢大学和香港科技大学联合研究项目", "tail_type": "人物/实验室"}, {"head": "gStore", "head_type": "知识图谱项目", "relation": "属于", "tail": "基于图RDF三元组数据库", "tail_type": "知识存储"}]}
{"text": "gStore的底层存储使用RDF图对应的标签图（Signature_Graph）并建立“VS树”索引结构以加速查找。", "relation": [{"head": "gStore", "head_type": "知识图谱项目", "relation": "方法", "tail": "使用RDF图对应的标签图并建立“VS树”索引结构以加速查找", "tail_type": "文本"}]}
{"text": "Virtuoso是由OpenLink公司开发的商业混合数据库产品，支持关系数据、对象-关系数据、RDF数据、XML数据和文本数据的统一管理。", "relation": [{"head": "Virtuoso", "head_type": "知识图谱项目", "relation": "属于", "tail": "基于图RDF三元组数据库", "tail_type": "知识存储"}, {"head": "Virtuoso", "head_type": "知识图谱项目", "relation": "创建者", "tail": "OpenLink", "tail_type": "人物/实验室"}, {"head": "Virtuoso", "head_type": "知识图谱项目", "relation": "特点", "tail": "支持关系数据、对象-关系数据、RDF数据、XML数据和文本数据的统一管理", "tail_type": "文本"}]}
{"text": "AllegroGraph是美国Franz公司开发的RDF三元组数据库。", "relation": [{"head": "AllegroGraph", "head_type": "知识图谱项目", "relation": "属于", "tail": "基于图RDF三元组数据库", "tail_type": "知识存储"}, {"head": "AllegroGraph", "head_type": "知识图谱项目", "relation": "创建者", "tail": "Franz公司", "tail_type": "人物/实验室"}]}
{"text": "AllegroGraph除了三元组数据库的基本功能，还支持动态物化的RDFS++推理机、OWL2_RL推理机、Prolog规则推理系统、时空推理机制、社会网络分析库、可视化RDF图浏览器等。", "relation": [{"head": "AllegroGraph", "head_type": "知识图谱项目", "relation": "特点", "tail": "支持三元组数据库的基本功能、动态物化的RDFS++推理机、OWL2_RL推理机、Prolog规则推理系统、时空推理机制、社会网络分析库、可视化RDF图浏览器等", "tail_type": "文本"}]}
{"text": "GraphDB是由保加利亚的Ontotext软件公司开发的RDF三元组数据库。", "relation": [{"head": "GraphDB", "head_type": "知识图谱项目", "relation": "属于", "tail": "基于图RDF三元组数据库", "tail_type": "知识存储"}, {"head": "GraphDB", "head_type": "知识图谱项目", "relation": "创建者", "tail": "Ontotext", "tail_type": "人物/实验室"}]}
{"text": "GraphDB的特色是良好支持RDF推理功能，其使用内置的基于规则的“前向链”（Forward-Chaining）推理机，由显式知识经过推理得到导出知识，对这些导出知识进行优化存储；导出知识会在知识库更新后相应地同步更新。", "relation": [{"head": "GraphDB", "head_type": "知识图谱项目", "relation": "特点", "tail": "良好支持RDF推理功能", "tail_type": "文本"}]}
{"text": "Blazegraph是一个基于RDF三元组库的图数据库管理系统，在用户接口层同时支持RDF三元组和属性图模型，既实现了SPARQL语言，也实现了Blueprints标准及Gremlin语言。", "relation": [{"head": "Blazegraph", "head_type": "知识图谱项目", "relation": "属于", "tail": "基于图RDF三元组数据库", "tail_type": "知识存储"}]}
{"text": "通过分布式动态分片B+树和服务总线技术，Blazegraph支持真正意义上的集群分布式存储和查询处理。", "relation": [{"head": "Blazegraph", "head_type": "知识图谱项目", "relation": "特点", "tail": "支持真正意义上的集群分布式存储和查询处理", "tail_type": "文本"}]}
{"text": "Stardog是由美国Stardog_Union公司开发的RDF三元组数据库，支持RDF图数据模型、SPARQL查询语言、属性图模型、Gremlin图遍历语言、OWL2标准、用户自定义的推理与数据分析规则、虚拟图、地理空间查询以及多用编程语言与网络接口支持。", "relation": [{"head": "Stardog", "head_type": "知识图谱项目", "relation": "属于", "tail": "基于图RDF三元组数据库", "tail_type": "知识存储"}, {"head": "Stardog", "head_type": "知识图谱项目", "relation": "创建者", "tail": "Stardog_Union", "tail_type": "人物/实验室"}]}
{"text": "（3）原生图数据库。", "relation": [{"head": "存储方案", "head_type": "知识存储", "relation": "包含", "tail": "面向RDF的三元组库", "tail_type": "知识存储"}]}
{"text": "Neo4j是用Java实现的开源图数据库。", "relation": [{"head": "Neo4j", "head_type": "知识图谱项目", "relation": "属于", "tail": "图数据库", "tail_type": "知识存储"}]}
{"text": "JanusGraph是在原有Titan系统基础上继续开发的开源分布式图数据库，目前是Linux基金会旗下的一个开源项目。", "relation": [{"head": "JanusGraph", "head_type": "知识图谱项目", "relation": "属于", "tail": "图数据库", "tail_type": "知识存储"}]}
{"text": "JanusGraph的主要缺点是分布式查询功能仅限于基于Cassandra或HBase提供的分布式读写实现的简单导航查询，对于很多稍复杂的查询类型，目前还不支持真正意义上的分布式查询处理，例如子图匹配查询、正则路径查询等。", "relation": [{"head": "JanusGraph", "head_type": "知识图谱项目", "relation": "缺点", "tail": "不支持真正意义上的分布式查询处理", "tail_type": "文本"}]}
{"text": "Cayley是由谷歌公司工程师开发的一款轻量级开源图数据库，于2014年6月在GitHub上发布。", "relation": [{"head": "Cayley", "head_type": "知识图谱项目", "relation": "创建者", "tail": "谷歌公司", "tail_type": "人物/实验室"}, {"head": "Cayley", "head_type": "知识图谱项目", "relation": "属于", "tail": "图数据库", "tail_type": "知识存储"}]}
{"text": "1.6.2知识图谱与智能问答基于知识图谱的问答（Knowledge-based_Question_Answering,KBQA，下称“知识问答”）是智能问答系统的核心功能，是一种人机交互的自然方式。", "relation": [{"head": "知识问答", "head_type": "知识问答", "relation": "属于", "tail": "知识图谱", "tail_type": "知识图谱"}]}
{"text": "知识问答依托一个大型知识库（知识图谱、结构化数据库等），将用户的自然语言问题转化成结构化查询语句（如SPARQL、SQL等），直接从知识库中导出用户所需的答案。", "relation": [{"head": "知识库", "head_type": "知识问答", "relation": "实现", "tail": "知识问答", "tail_type": "知识问答"}]}
{"text": "事实型问题按问题类型可分为单知识点问题（Single-hop_Questions）和多知识点问题（Multi-hop_Questions）；按问题的领域可分为垂直领域问题和通用领域问题。", "relation": [{"head": "事实型问题", "head_type": "知识问答", "relation": "包含", "tail": "单知识点问题", "tail_type": "知识问答"}, {"head": "事实型问题", "head_type": "知识问答", "relation": "包含", "tail": "多知识点问题", "tail_type": "知识问答"}, {"head": "单知识点问题", "head_type": "知识问答", "relation": "英文名", "tail": "Single-hop_Questions", "tail_type": "文本"}, {"head": "多知识点问题", "head_type": "知识问答", "relation": "英文名", "tail": "Multi-hop_Questions", "tail_type": "文本"}, {"head": "事实型问题", "head_type": "知识问答", "relation": "包含", "tail": "垂直领域问题", "tail_type": "知识问答"}, {"head": "事实型问题", "head_type": "知识问答", "relation": "包含", "tail": "通用领域问题", "tail_type": "知识问答"}]}
{"text": "相对于通用领域或开放领域，垂直领域下的知识图谱规模更小、精度更高，知识问答的质量更容易提升。", "relation": [{"head": "垂直领域问题", "head_type": "知识问答", "relation": "特点", "tail": "规模更小、精度更高，知识问答的质量高", "tail_type": "文本"}]}
{"text": "知识问答技术的成熟与落地不仅能提高人们检索信息的精度和效率，还能提升用户的产品体验。", "relation": [{"head": "知识问答技术", "head_type": "知识问答", "relation": "作用", "tail": "提高人们检索信息的精度和效率，还能提升用户的产品体验", "tail_type": "文本"}]}
{"text": "这涉及自然语言处理、信息检索和推理（Reasoning）等多个领域的不同技术。", "relation": [{"head": "知识问答技术", "head_type": "知识问答", "relation": "包含", "tail": "自然语言处理", "tail_type": "知识问答"}, {"head": "知识问答技术", "head_type": "知识问答", "relation": "包含", "tail": "信息检索和推理", "tail_type": "知识问答"}]}
{"text": "相关研究工作在近五年来受到越来越多国内外学者的关注，研究方法主要可分为三大类：基于语义解析（Semantic_Parsing）的方法、基于信息检索（Information_Retrieval）的方法和基于概率模型（Probabilistic_Models）的方法。", "relation": [{"head": "知识问答方法", "head_type": "知识问答", "relation": "包含", "tail": "基于语义解析的方法", "tail_type": "知识问答"}, {"head": "知识问答方法", "head_type": "知识问答", "relation": "包含", "tail": "基于信息检索的方法", "tail_type": "知识问答"}, {"head": "知识问答方法", "head_type": "知识问答", "relation": "包含", "tail": "基于概率模型的方法", "tail_type": "知识问答"}]}
{"text": "大部分先进的知识问答方法是基于语义解析的，目的是将自然语言问句解析成结构化查询语句，进而在知识库上执行查询得到答案。", "relation": [{"head": "基于语义解析的方法", "head_type": "知识问答", "relation": "目标", "tail": "将自然语言问句解析成结构化查询语句，进而在知识库上执行查询得到答案", "tail_type": "文本"}]}
{"text": "在基于语义解析的方法训练过程中，问答模型隐式地学习了标注数据中蕴涵的语法解析规律。这使得模型能具有更好的可解释性。", "relation": [{"head": "基于语义解析的方法", "head_type": "知识问答", "relation": "特点", "tail": "学习了标注数据中蕴涵的语法解析规律，使得模型能具有更好的可解释性", "tail_type": "文本"}]}
{"text": "但是，数据标注需要花费大量的人力和财力，是不切实际的。", "relation": [{"head": "基于语义解析的方法", "head_type": "知识问答", "relation": "缺点", "tail": "需要花费大量的人力和财力", "tail_type": "文本"}]}
{"text": "基于信息检索的知识问答大致可分为两步：①通过粗粒度信息检索，在知识库中直接筛选出候选答案；②根据问句中抽取出的特征，对候选答案进行排序。", "relation": [{"head": "基于信息检索的方法", "head_type": "知识问答", "relation": "内容", "tail": "通过粗粒度信息检索，在知识库中直接筛选出候选答案，根据问句中抽取出的特征，对候选答案进行排序", "tail_type": "文本"}]}
{"text": "1.6.3知识图谱与机器推理推理是指基于已知的事实或知识推断得出未知的事实或知识的过程。", "relation": [{"head": "知识推理", "head_type": "知识推理", "relation": "属于", "tail": "知识图谱", "tail_type": "知识图谱"}, {"head": "知识推理", "head_type": "知识推理", "relation": "被定义为", "tail": "基于已知的事实或知识推断得出未知的事实或知识的过程。", "tail_type": "文本"}]}
{"text": "典型的推理包括演绎推理（Deductive_Reasoning）、溯因推理（Inductive_Reasoning）、归纳推理（Abductive_Reasoning）、类比推理（Analogical_Reasoning）等。", "relation": [{"head": "知识推理", "head_type": "知识推理", "relation": "包含", "tail": "演绎推理", "tail_type": "知识推理"}, {"head": "知识推理", "head_type": "知识推理", "relation": "包含", "tail": "溯因推理", "tail_type": "知识推理"}, {"head": "知识推理", "head_type": "知识推理", "relation": "包含", "tail": "归纳推理", "tail_type": "知识推理"}, {"head": "知识推理", "head_type": "知识推理", "relation": "包含", "tail": "类比推理", "tail_type": "知识推理"}, {"head": "演绎推理", "head_type": "知识推理", "relation": "英文名", "tail": "Deductive_Reasoning", "tail_type": "文本"}, {"head": "溯因推理", "head_type": "知识推理", "relation": "英文名", "tail": "Inductive_Reasoning", "tail_type": "文本"}, {"head": "归纳推理", "head_type": "知识推理", "relation": "英文名", "tail": "Abductive_Reasoning", "tail_type": "文本"}, {"head": "类比推理", "head_type": "知识推理", "relation": "英文名", "tail": "Analogical_Reasoning", "tail_type": "文本"}]}
{"text": "在知识图谱中，推理主要用于对知识图谱进行补全（Knowledge_Base_Completion,KBC）和知识图谱质量的校验。", "relation": [{"head": "知识推理", "head_type": "知识推理", "relation": "作用", "tail": "补全知识图谱，校验知识图谱质量", "tail_type": "文本"}]}
{"text": "知识图谱中的知识可分为概念层和实体层。", "relation": [{"head": "知识图谱", "head_type": "知识图谱", "relation": "包含", "tail": "概念层", "tail_type": "知识图谱"}, {"head": "知识图谱", "head_type": "知识图谱", "relation": "包含", "tail": "实体层", "tail_type": "知识图谱"}]}
{"text": "知识图谱推理的任务是根据知识图谱中已有的知识推理出新的知识或识别出错误的知识。", "relation": [{"head": "知识推理", "head_type": "知识图谱", "relation": "作用", "tail": "根据知识图谱中已有的知识推理出新的知识或识别出错误的知识", "tail_type": "文本"}]}
{"text": "其中，概念层的推理主要包括概念之间的包含关系推理，实体层的推理主要包括链接预测与冲突检测，实体层与概念层之间的推理主要包括实例检测。", "relation": [{"head": "概念层推理", "head_type": "知识推理", "relation": "包含", "tail": "概念之间的包含关系推理", "tail_type": "知识推理"}, {"head": "实体层推理", "head_type": "知识推理", "relation": "包含", "tail": "链接预测与冲突检测", "tail_type": "知识推理"}, {"head": "实体层与概念层之间的推理", "head_type": "知识推理", "relation": "包含", "tail": "实例检测", "tail_type": "知识推理"}]}
{"text": "推理的方法主要包含基于规则的推理、基于分布式表示学习的推理、基于神经网络的推理以及混合推理。", "relation": [{"head": "知识推理方法", "head_type": "知识推理", "relation": "包含", "tail": "基于规则的推理", "tail_type": "知识推理"}, {"head": "知识推理方法", "head_type": "知识推理", "relation": "包含", "tail": "基于分布式表示学习的推理", "tail_type": "知识推理"}, {"head": "知识推理方法", "head_type": "知识推理", "relation": "包含", "tail": "基于神经网络的推理", "tail_type": "知识推理"}, {"head": "知识推理方法", "head_type": "知识推理", "relation": "包含", "tail": "混合推理", "tail_type": "知识推理"}]}
{"text": "1.基于规则的推理基于规则的推理通过定义或学习知识中存在的规则进行推理。", "relation": [{"head": "基于规则的推理方法", "head_type": "知识推理", "relation": "被定义为", "tail": "基于定义或学习知识中存在的规则进行推理", "tail_type": "文本"}]}
{"text": "根据规则的真值类型，可分为硬逻辑规则和软逻辑规则。", "relation": [{"head": "规则的真值类型", "head_type": "知识推理", "relation": "包含", "tail": "硬逻辑规则", "tail_type": "知识推理"}, {"head": "规则的真值类型", "head_type": "知识推理", "relation": "包含", "tail": "软逻辑规则", "tail_type": "知识推理"}]}
{"text": "硬逻辑规则中的每条规则的真值都为1，即绝对正确，人工编写的规则多为硬逻辑规则。", "relation": [{"head": "硬逻辑规则", "head_type": "知识推理", "relation": "被定义为", "tail": "每条规则的真值都为1", "tail_type": "文本"}]}
{"text": "软逻辑规则即每条规则的真值为区间在0到1之间的概率，规则挖掘系统的结果多为软逻辑规则，其学习过程一般是基于规则中结论与条件的共现特征，典型方法有AMIE[110]等。", "relation": [{"head": "软逻辑规则", "head_type": "知识推理", "relation": "被定义为", "tail": "每条规则的真值为区间在0到1之间的概率", "tail_type": "文本"}]}
{"text": "基于规则的推理方法最主要的优点是在通常情况下规则比较接近人思考问题时的推理过程，其推理结论可解释，所以对人比较友好。", "relation": [{"head": "基于规则的推理方法", "head_type": "知识推理", "relation": "特点", "tail": "推理结论可解释，对人比较友好", "tail_type": "文本"}]}
{"text": "2.基于分布式表示学习的推理分布式表示学习的核心是将知识图谱映射到连续的向量空间中，并为知识图谱中的元素学习分布式表示为低维稠密的向量或矩阵。", "relation": [{"head": "基于分布式表示学习的推理", "head_type": "知识推理", "relation": "被定义为", "tail": "将知识图谱映射到连续的向量空间中，并为知识图谱中的元素学习分布式表示为低维稠密的向量或矩阵", "tail_type": "文本"}]}
{"text": "分布式表示学习通过各元素的分布式表示之间的计算完成隐式的推理。", "relation": [{"head": "基于分布式表示学习的推理", "head_type": "知识推理", "relation": "方法", "tail": "各元素的分布式表示之间的计算完成隐式的推理", "tail_type": "文本"}]}
{"text": "3.基于神经网络的推理基于神经网络的推理通过神经网络的设计模拟知识图谱推理，其中NTN[117]用一个双线性张量层判断头实体和尾实体的关系，ConvE[118]等在实体和关系的表示向量排布出的二维矩阵上采用卷机神经网络进行链接预测，R-GCN[119]通过图卷积网络捕捉实体的相邻实体信息，IRN[120]采用记忆矩阵以及以递归神经网络为结构的控制单元模拟多步推理的过程。", "relation": [{"head": "基于神经网络的推理", "head_type": "知识推理", "relation": "被定义为", "tail": "通过神经网络的设计模拟知识图谱推理", "tail_type": "文本"}]}
{"text": "网络结构的设计多样，能够满足不同的推理需求。", "relation": [{"head": "基于神经网络的推理", "head_type": "知识推理", "relation": "特点", "tail": "设计多样能够满足不同的推理需求", "tail_type": "文本"}]}
{"text": "例如，NeuralLP[121]是一种可微的知识图谱推理方法，融合了关系的表示学习、规则学习以及循环神经网络，由LSTM生成多步推理中的隐变量，并通过隐变量生成在多步推理过程中对每种关系的注意力。", "relation": [{"head": "NeuralLP", "head_type": "知识图谱项目", "relation": "属于", "tail": "知识推理方法", "tail_type": "知识推理"}, {"head": "NeuralLP", "head_type": "知识图谱项目", "relation": "特点", "tail": "融合了关系的表示学习、规则学习以及循环神经网络", "tail_type": "文本"}]}
{"text": "DeepPath[122]和MINERVA[123]用强化学习方法学习知识图谱多步推理过程中的路径选择策略。", "relation": [{"head": "DeepPath", "head_type": "知识图谱项目", "relation": "属于", "tail": "知识推理方法", "tail_type": "知识推理"}, {"head": "DeepPath", "head_type": "知识图谱项目", "relation": "特点", "tail": "强化学习方法学习知识图谱多步推理过程", "tail_type": "文本"}, {"head": "MINERVA", "head_type": "知识图谱项目", "relation": "属于", "tail": "知识推理方法", "tail_type": "知识推理"}, {"head": "MINERVA", "head_type": "知识图谱项目", "relation": "特点", "tail": "强化学习方法学习知识图谱多步推理过程", "tail_type": "文本"}]}
{"text": "RUGE[124]将已有的推理规则输入知识图谱表示学习过程中，约束和影响表示学习结果并取得更好的推理效果。", "relation": [{"head": "RUGE", "head_type": "知识图谱项目", "relation": "属于", "tail": "知识推理方法", "tail_type": "知识推理"}, {"head": "RUGE", "head_type": "知识图谱项目", "relation": "特点", "tail": "将已有的推理规则输入知识图谱表示学习过程中，约束和影响表示学习结果并取得更好的推理效果", "tail_type": "文本"}]}
{"text": "混合推理能够结合规则推理、表示学习推理以及神经网络推理的能力并实现优势互补，能够同时提升推理结果的精确性和可解释性。", "relation": [{"head": "混合推理", "head_type": "知识推理", "relation": "特点", "tail": "结合规则推理、表示学习推理以及神经网络推理的能力并实现优势互补，能够同时提升推理结果的精确性和可解释性", "tail_type": "文本"}]}
{"text": "基于规则的知识图谱推理研究主要分为两部分：一是自动规则挖掘系统，二是基于规则的推理系统。", "relation": [{"head": "基于规则的知识图谱推理研究", "head_type": "知识推理", "relation": "内容", "tail": "自动规则挖掘系统，基于规则的推理系统", "tail_type": "文本"}]}
{"text": "基于表示学习的知识图谱推理研究的主要研究趋势是，一方面提高表示学习结果对知识图谱中含有的语义信息的捕捉能力，目前的研究多集中在链接预测任务上，其他推理任务有待跟进研究；另一方面是利用分布式表示作为桥梁，将知识图谱与文本、图像等异质信息结合，实现信息互补以及更多样化的综合推理。", "relation": [{"head": "基于表示学习的知识图谱推理研究", "head_type": "知识推理", "relation": "内容", "tail": "一方面提高表示学习结果对知识图谱中含有的语义信息的捕捉能力，目前的研究多集中在链接预测任务上，其他推理任务有待跟进研究；另一方面是利用分布式表示作为桥梁，将知识图谱与文本、图像等异质信息结合，实现信息互补以及更多样化的综合推理", "tail_type": "文本"}]}
{"text": "基于神经网络的知识表示推理的主要发展趋势是设计更加有效和有意义的神经网络结构，来实现更加高效且精确的推理，通过对神经网络中间结果的解析实现对推理结果的部分解释是比较值得关注的方向。", "relation": [{"head": "基于神经网络的知识表示推理的趋势", "head_type": "知识推理", "relation": "内容", "tail": "设计更加有效和有意义的神经网络结构，来实现更加高效且精确的推理，通过对神经网络中间结果的解析实现对推理结果的部分解释", "tail_type": "文本"}]}
{"text": "第2章知识图谱表示与建模漆桂林东南大学，潘志霖阿伯丁大学，陈华钧浙江大学知识图谱表示（Knowledge_Graph_Representation）指的是用什么语言对知识图谱进行建模，从而可以方便知识计算。", "relation": [{"head": "知识图谱表示", "head_type": "知识表示", "relation": "实现", "tail": "建模知识图谱", "tail_type": "知识表示"}, {"head": "知识图谱表示", "head_type": "知识表示", "relation": "英文名", "tail": "Knowledge_Graph_Representation", "tail_type": "文本"}]}
{"text": "从图的角度来看，知识图谱是一个语义网络，即一种用互联的节点和弧表示知识的一个结构[1]。", "relation": [{"head": "知识图谱", "head_type": "知识图谱", "relation": "属于", "tail": "语义网络", "tail_type": "知识图谱"}, {"head": "语义网络", "head_type": "知识图谱", "relation": "被定义为", "tail": "一种用互联的节点和弧表示知识的一个结构", "tail_type": "文本"}]}
{"text": "语义网络中的节点可以代表一个概念（concept）、一个属性（attribute）、一个事件（event）或者一个实体（entity）；而弧表示节点之间的关系，弧的标签指明了关系的类型。", "relation": [{"head": "节点", "head_type": "知识图谱", "relation": "内容", "tail": "概念", "tail_type": "文本"}, {"head": "节点", "head_type": "知识图谱", "relation": "内容", "tail": "属性", "tail_type": "文本"}, {"head": "节点", "head_type": "知识图谱", "relation": "内容", "tail": "事件", "tail_type": "文本"}, {"head": "节点", "head_type": "知识图谱", "relation": "内容", "tail": "实体", "tail_type": "文本"}]}
{"text": "语义网络中的语义主要体现在图中边的含义。", "relation": [{"head": "语义网络中的语义", "head_type": "知识图谱", "relation": "来源", "tail": "边的含义", "tail_type": "知识图谱"}]}
{"text": "为了给这些边赋予语义，研究人员提出了术语语言（Terminological_Language），并最终提出了描述逻辑（Description_Logic），描述逻辑是一阶谓词逻辑的一个子集，推理复杂度是可判定的。", "relation": [{"head": "描述逻辑", "head_type": "知识图谱", "relation": "属于", "tail": "一阶谓词逻辑", "tail_type": "知识图谱"}, {"head": "描述逻辑", "head_type": "知识图谱", "relation": "英文名", "tail": "Description_Logic", "tail_type": "文本"}, {"head": "描述逻辑", "head_type": "知识图谱", "relation": "目标", "tail": "给边赋予语义", "tail_type": "文本"}]}
{"text": "W3C采用了以描述逻辑为逻辑基础的本体语言OWL作为定义Web术语的标准语言。", "relation": [{"head": "OWL", "head_type": "知识表示", "relation": "属于", "tail": "定义Web术语的标准语言", "tail_type": "知识表示"}, {"head": "OWL", "head_type": "知识表示", "relation": "被定义为", "tail": "描述逻辑为逻辑基础的本体语言", "tail_type": "文本"}]}
{"text": "2.1什么是知识表示20世纪90年代，MIT_AI实验室的R.Davis定义了知识表示的五大用途或特点：●客观事物的机器标示（A_KR_is_a_Surrogate），即知识表示首先需要定义客观实体的机器指代或指称。", "relation": [{"head": "知识表示的五大用途或特点", "head_type": "知识表示", "relation": "包含", "tail": "客观事物的机器标示", "tail_type": "知识表示"}, {"head": "知识表示", "head_type": "知识表示", "relation": "特点", "tail": "客观事物的机器标示", "tail_type": "文本"}, {"head": "客观事物的机器标示", "head_type": "知识表示", "relation": "英文名", "tail": "A_KR_is_a_Surrogate", "tail_type": "文本"}]}
{"text": "知识表示的五大用途或特点：●一组本体约定和概念模型（A_KR_is_a_Set_of_Ontological_Commitments），即知识表示还需要定义用于描述客观事物的概念和类别体系。", "relation": [{"head": "知识表示的五大用途或特点", "head_type": "知识表示", "relation": "包含", "tail": "一组本体约定和概念模型", "tail_type": "知识表示"}, {"head": "知识表示", "head_type": "知识表示", "relation": "特点", "tail": "一组本体约定和概念模型", "tail_type": "文本"}, {"head": "一组本体约定和概念模型", "head_type": "知识表示", "relation": "英文名", "tail": "A_KR_is_a_Set_of_Ontological_Commitments", "tail_type": "文本"}]}
{"text": "知识表示的五大用途或特点：●支持推理的表示基础（A_KR_is_a_Theory_of_Intelligent_Reasoning），即知识表示还需要提供机器推理的模型与方法。", "relation": [{"head": "知识表示的五大用途或特点", "head_type": "知识表示", "relation": "包含", "tail": "支持推理的表示基础", "tail_type": "知识表示"}, {"head": "知识表示", "head_type": "知识表示", "relation": "特点", "tail": "支持推理的表示基础", "tail_type": "文本"}, {"head": "支持推理的表示基础", "head_type": "知识表示", "relation": "英文名", "tail": "A_KR_is_a_Theory_of_Intelligent_Reasoning", "tail_type": "文本"}]}
{"text": "知识表示的五大用途或特点：●用于高效计算的数据结构（A_KR_is_a_medium_for_Efficient_Computation），即知识表示也是一种用于高效计算的数据结构。", "relation": [{"head": "知识表示的五大用途或特点", "head_type": "知识表示", "relation": "包含", "tail": "用于高效计算的数据结构", "tail_type": "知识表示"}, {"head": "知识表示", "head_type": "知识表示", "relation": "特点", "tail": "用于高效计算的数据结构", "tail_type": "文本"}, {"head": "用于高效计算的数据结构", "head_type": "知识表示", "relation": "英文名", "tail": "A_KR_is_a_medium_for_Efficient_Computation", "tail_type": "文本"}]}
{"text": "知识表示的五大用途或特点：●人可理解的机器语言（A_KR_is_a_Medium_of_Human_Expression），即知识表示还必须接近于人的认知，是人可理解的机器语言。", "relation": [{"head": "知识表示的五大用途或特点", "head_type": "知识表示", "relation": "包含", "tail": "人可理解的机器语言", "tail_type": "知识表示"}, {"head": "知识表示", "head_type": "知识表示", "relation": "特点", "tail": "人可理解的机器语言", "tail_type": "文本"}, {"head": "人可理解的机器语言", "head_type": "知识表示", "relation": "英文名", "tail": "A_KR_is_a_Medium_of_Human_Expression", "tail_type": "文本"}]}
{"text": "有关知识表示的研究可以追溯到人工智能的早期研究。", "relation": [{"head": "有关知识表示的研究", "head_type": "知识表示", "relation": "来源", "tail": "人工智能的早期研究", "tail_type": "知识表示"}]}
{"text": "例如，认知科学家M.RossQuillian和Allan_M.Collins提出了语义网络的知识表示方法[2-3]，以网络的方式描述概念之间的语义关系。", "relation": [{"head": "语义网络的知识表示方法", "head_type": "知识表示", "relation": "实现", "tail": "概念之间的语义关系", "tail_type": "知识表示"}]}
{"text": "典型的语义网络如WordNet属于词典类的知识库，主要定义名词、动词、形容词和副词之间的语义关系。", "relation": [{"head": "WordNet", "head_type": "知识图谱项目", "relation": "属于", "tail": "词典类的知识库", "tail_type": "知识图谱项目"}, {"head": "语义网络", "head_type": "知识图谱", "relation": "包含", "tail": "WordNet", "tail_type": "知识图谱项目"}]}
{"text": "传统的专家系统通常包含知识库和推理引擎（InferenceEngine）两个核心模块。", "relation": [{"head": "传统的专家系统", "head_type": "知识表示", "relation": "包含", "tail": "知识库模块", "tail_type": "知识表示"}, {"head": "推理引擎", "head_type": "知识表示", "relation": "英文名", "tail": "InferenceEngine", "tail_type": "文本"}, {"head": "知识库", "head_type": "知识表示", "relation": "英文名", "tail": "KnowledgeBase", "tail_type": "文本"}]}
{"text": "为了解决这一问题，人们开始研究具有较好的理论模型基础和算法复杂度的知识表示框架，比较有代表性的是描述逻辑语言（Description_Logic）[4]。", "relation": [{"head": "描述逻辑语言", "head_type": "知识表示", "relation": "属于", "tail": "知识表示框架", "tail_type": "知识表示"}, {"head": "描述逻辑语言", "head_type": "知识表示", "relation": "英文名", "tail": "Description_Logic", "tail_type": "文本"}]}
{"text": "描述逻辑是目前大多数本体语言（如OWL）的理论基础。", "relation": [{"head": "本体语言", "head_type": "知识表示", "relation": "来源", "tail": "描述逻辑", "tail_type": "知识表示"}, {"head": "OWL", "head_type": "知识图谱项目", "relation": "属于", "tail": "本体语言", "tail_type": "知识表示"}]}
{"text": "第一个描述逻辑语言是1985年由RonaldJ.Brachman等提出的KL-ONE[5]。", "relation": [{"head": "KL-ONE", "head_type": "知识图谱项目", "relation": "属于", "tail": "描述逻辑语言", "tail_type": "知识表示"}, {"head": "KL-ONE", "head_type": "知识图谱项目", "relation": "被定义为", "tail": "第一个描述逻辑语言", "tail_type": "文本"}]}
{"text": "描述逻辑主要用于刻画概念（Concepts）、属性（Roles）、个体（Individual）、关系（Relationships）、元语（Axioms，即逻辑描述Logic_Statement）等知识表达要素。", "relation": [{"head": "描述逻辑", "head_type": "知识表示", "relation": "作用", "tail": "刻画知识表达要素", "tail_type": "文本"}, {"head": "概念", "head_type": "知识表示", "relation": "属于", "tail": "知识表达要素", "tail_type": "知识表示"}, {"head": "概念", "head_type": "知识表示", "relation": "英文名", "tail": "Concepts", "tail_type": "文本"}, {"head": "属性", "head_type": "知识表示", "relation": "属于", "tail": "知识表达要素", "tail_type": "知识表示"}, {"head": "属性", "head_type": "知识表示", "relation": "英文名", "tail": "Roles", "tail_type": "文本"}, {"head": "个体", "head_type": "知识表示", "relation": "属于", "tail": "知识表达要素", "tail_type": "知识表示"}, {"head": "个体", "head_type": "知识表示", "relation": "英文名", "tail": "Individual", "tail_type": "文本"}, {"head": "关系", "head_type": "知识表示", "relation": "属于", "tail": "知识表达要素", "tail_type": "知识表示"}, {"head": "关系", "head_type": "知识表示", "relation": "英文名", "tail": "Relationships", "tail_type": "文本"}, {"head": "元语", "head_type": "知识表示", "relation": "属于", "tail": "知识表达要素", "tail_type": "知识表示"}, {"head": "元语", "head_type": "知识表示", "relation": "英文名", "tail": "Axioms", "tail_type": "文本"}]}
{"text": "语义网的基础数据模型RDF受到了元数据模型、框架系统和面向对象语言等多方面的影响，其最初是为人们在Web上发布结构化数据提供一个标准的数据描述框架。", "relation": [{"head": "RDF", "head_type": "知识图谱项目", "relation": "被定义为", "tail": "语义网的基础数据模型", "tail_type": "文本"}]}
{"text": "无论是早期专家系统时代的知识表示方法，还是语义网时代的知识表示模型，都属于以符号逻辑为基础的知识表示方法。", "relation": [{"head": "早期专家系统时代的知识表示方法", "head_type": "知识表示", "relation": "属于", "tail": "以符号逻辑为基础的知识表示方法", "tail_type": "知识表示"}, {"head": "语义网时代的知识表示模型", "head_type": "知识表示", "relation": "属于", "tail": "以符号逻辑为基础的知识表示方法", "tail_type": "知识表示"}]}
{"text": "符号知识表示的特点是易于刻画显式、离散的知识，因而具有内生的可解释性。", "relation": [{"head": "符号知识表示", "head_type": "知识表示", "relation": "特点", "tail": "易于刻画显式、离散的知识", "tail_type": "文本"}, {"head": "符号知识表示", "head_type": "知识表示", "relation": "特点", "tail": "易于刻画显式、离散的知识，因而具有内生的可解释性", "tail_type": "文本"}]}
{"text": "但由于人类知识还包含大量不易于符号化的隐性知识，完全基于符号逻辑的知识表示通常由于知识的不完备而失去鲁棒性，特别是推理很难达到实用。", "relation": [{"head": "人类知识", "head_type": "知识表示", "relation": "包含", "tail": "不易于符号化的隐性知识", "tail_type": "知识表示"}]}
{"text": "由此催生了采用连续向量的方式来表示知识的研究。", "relation": [{"head": "知识表示", "head_type": "知识表示", "relation": "方法", "tail": "采用连续向量的方式", "tail_type": "文本"}]}
{"text": "随着表示学习的发展，以及自然语言处理领域词向量等嵌入（Embedding）技术手段的出现，启发了人们用类似于词向量的低维稠密向量的方式表示知识。", "relation": [{"head": "知识表示", "head_type": "知识表示", "relation": "方法", "tail": "类似于词向量的低维稠密向量的方式", "tail_type": "文本"}]}
{"text": "这种基于连续向量的知识表示可以实现通过数值运算来发现新事实和新关系，并能更有效发现更多的隐式知识和潜在假设，这些隐式知识通常是人的主观不易于观察和总结出来的。", "relation": [{"head": "基于连续向量的知识表示", "head_type": "知识表示", "relation": "实现", "tail": "发现新事实和新关系", "tail_type": "知识表示"}, {"head": "基于连续向量的知识表示", "head_type": "知识表示", "relation": "实现", "tail": "发现更多的隐式知识和潜在假设", "tail_type": "知识表示"}]}
{"text": "2.2.1一阶谓词逻辑一阶谓词逻辑（或简称一阶逻辑）（First_Order_Logic）是公理系统的标准形式逻辑。", "relation": [{"head": "一阶谓词逻辑", "head_type": "知识表示", "relation": "被定义为", "tail": "公理系统的标准形式逻辑", "tail_type": "文本"}]}
{"text": "2.2.2一阶谓词逻辑一阶谓词逻辑（或简称一阶逻辑）（First_Order_Logic）是公理系统的标准形式逻辑。", "relation": [{"head": "一阶谓词逻辑", "head_type": "知识表示", "relation": "英文名", "tail": "First_Order_Logic", "tail_type": "文本"}]}
{"text": "2.2.3一阶谓词逻辑一阶谓词逻辑（或简称一阶逻辑）（First_Order_Logic）是公理系统的标准形式逻辑。", "relation": [{"head": "一阶谓词逻辑", "head_type": "知识表示", "relation": "等价", "tail": "一阶逻辑", "tail_type": "知识表示"}]}
{"text": "不同于命题逻辑（Propositional_Logic），一阶逻辑支持量词（Quantifier）和谓词（Predicate）。", "relation": [{"head": "命题逻辑", "head_type": "知识表示", "relation": "英文名", "tail": "Propositional_Logic", "tail_type": "知识表示"}]}
{"text": "但是，在一阶逻辑里，可以用谓词和变量表示知识，例如，图灵奖得主（x）表示x是图灵奖得主。", "relation": [{"head": "一阶逻辑", "head_type": "知识表示", "relation": "实现", "tail": "用谓词和变量表示知识", "tail_type": "知识表示"}]}
{"text": "1.一阶谓词逻辑优点●结构性。", "relation": [{"head": "一阶谓词逻辑", "head_type": "知识表示", "relation": "特点", "tail": "结构性", "tail_type": "文本"}]}
{"text": "一阶谓词逻辑优点●严密性。", "relation": [{"head": "一阶谓词逻辑", "head_type": "知识表示", "relation": "特点", "tail": "紧密性", "tail_type": "文本"}]}
{"text": "一阶谓词逻辑有形式化的语法和语义，以及相关的推理规则。", "relation": [{"head": "一阶谓词逻辑", "head_type": "知识表示", "relation": "包含", "tail": "形式化的语法和语义", "tail_type": "知识表示"}, {"head": "一阶谓词逻辑", "head_type": "知识表示", "relation": "包含", "tail": "相关的推理规则", "tail_type": "知识表示"}]}
{"text": "一阶谓词逻辑优点●可实现性。", "relation": [{"head": "一阶谓词逻辑", "head_type": "知识表示", "relation": "特点", "tail": "可实现性", "tail_type": "文本"}]}
{"text": "2.一阶谓词逻辑缺点●有限的可用性。", "relation": [{"head": "一阶谓词逻辑", "head_type": "知识表示", "relation": "缺点", "tail": "有限的可用性。", "tail_type": "文本"}]}
{"text": "一阶逻辑的逻辑归结只是半可判定性的。", "relation": [{"head": "一阶逻辑的逻辑归结", "head_type": "知识表示", "relation": "特点", "tail": "半可判定性", "tail_type": "文本"}]}
{"text": "一阶谓词逻辑缺点●无法表示不确定性知识。", "relation": [{"head": "一阶谓词逻辑", "head_type": "知识表示", "relation": "缺点", "tail": "无法表示不确定性知识", "tail_type": "知识表示"}]}
{"text": "2.2.2霍恩子句和霍恩逻辑霍恩子句（Horn_Clause）得名于逻辑学家Alfred_Horn[6]。", "relation": [{"head": "霍恩子句", "head_type": "知识表示", "relation": "创建者", "tail": "Alfred_Horn", "tail_type": "人物/实验室"}, {"head": "霍恩子句", "head_type": "知识表示", "relation": "英文名", "tail": "Horn_Clause", "tail_type": "文本"}]}
{"text": "霍恩子句是带有最多一个肯定（positive）文字的子句，肯定文字指的是没有否定符号的文字。", "relation": [{"head": "霍恩子句", "head_type": "知识表示", "relation": "被定义为", "tail": "带有最多一个肯定文字的子句", "tail_type": "文本"}, {"head": "肯定文字", "head_type": "知识表示", "relation": "被定义为", "tail": "没有否定符号的文字", "tail_type": "文本"}]}
{"text": "霍恩逻辑（Horn_Logic）是一阶逻辑的子集。", "relation": [{"head": "霍恩逻辑", "head_type": "知识表示", "relation": "属于", "tail": "一阶逻辑的子集", "tail_type": "知识表示"}]}
{"text": "基于霍恩逻辑的知识库是一个霍恩规则的集合。", "relation": [{"head": "基于霍恩逻辑的知识库", "head_type": "知识表示", "relation": "属于", "tail": "基于霍恩规则的集合", "tail_type": "知识表示"}]}
{"text": "一个霍恩规则由原子公式构成：B1∧∧Bn→H，其中H是头原子公式，B1,,Bn是体原子公式。", "relation": [{"head": "霍恩规则", "head_type": "知识表示", "relation": "由组成", "tail": "原子公式", "tail_type": "知识表示"}]}
{"text": "事实是霍恩规则的特例，它们是没有体原子公式且没有变量的霍恩Berners-Lee）是一个事实，可以简写为图灵奖得主规则。", "relation": [{"head": "事实", "head_type": "知识表示", "relation": "属于", "tail": "霍恩规则的特例", "tail_type": "知识表示"}]}
{"text": "1.霍恩逻辑的优点●结构性。", "relation": [{"head": "霍恩逻辑", "head_type": "知识表示", "relation": "特点", "tail": "结构性", "tail_type": "文本"}]}
{"text": "霍恩逻辑的优点●严密性。", "relation": [{"head": "霍恩逻辑", "head_type": "知识表示", "relation": "特点", "tail": "严密性", "tail_type": "文本"}]}
{"text": "霍恩逻辑有形式化的语法和语义，以及相关的推理规则。", "relation": [{"head": "霍恩逻辑", "head_type": "知识表示", "relation": "包含", "tail": "形式化的语法和语义", "tail_type": "知识表示"}, {"head": "霍恩逻辑", "head_type": "知识表示", "relation": "包含", "tail": "相关的推理规则", "tail_type": "知识表示"}]}
{"text": "霍恩逻辑的优点●易实现性。", "relation": [{"head": "霍恩逻辑", "head_type": "知识表示", "relation": "特点", "tail": "易实现性", "tail_type": "文本"}]}
{"text": "2.霍恩逻辑的缺点●有限的表达能力。", "relation": [{"head": "霍恩逻辑", "head_type": "知识表示", "relation": "缺点", "tail": "有限的表达能力", "tail_type": "文本"}]}
{"text": "有限的表达能力包括不能定义类表达式，不能够任意使用量化。", "relation": [{"head": "有限的表达能力", "head_type": "知识表示", "relation": "包含", "tail": "不能定义类表达式", "tail_type": "知识表示"}, {"head": "有限的表达能力", "head_type": "知识表示", "relation": "包含", "tail": "不能够任意使用量化", "tail_type": "知识表示"}]}
{"text": "霍恩逻辑的缺点●无法表示不确定性知识。", "relation": [{"head": "霍恩逻辑", "head_type": "知识表示", "relation": "缺点", "tail": "无法表示不确定性知识", "tail_type": "文本"}]}
{"text": "2.2.3语义网络语义网络是由Quillian等人提出用于表达人类的语义知识并且支持推理[3]。", "relation": [{"head": "语义网络", "head_type": "知识图谱", "relation": "作用", "tail": "表达人类的语义知识", "tail_type": "文本"}, {"head": "语义网络", "head_type": "知识图谱", "relation": "作用", "tail": "支持推理人类的语义知识", "tail_type": "文本"}, {"head": "语义网络", "head_type": "知识图谱", "relation": "创建者", "tail": "Quillian", "tail_type": "人物/实验室"}]}
{"text": "语义网络又称联想网络，它在形式上是一个带标识的有向图。", "relation": [{"head": "语义网络", "head_type": "知识图谱", "relation": "等价", "tail": "联想网络", "tail_type": "知识表示"}]}
{"text": "图中“节点”用以表示各种事物、概念、情况、状态等。", "relation": [{"head": "节点", "head_type": "知识图谱", "relation": "内容", "tail": "事物", "tail_type": "文本"}, {"head": "节点", "head_type": "知识图谱", "relation": "内容", "tail": "概念", "tail_type": "文本"}, {"head": "节点", "head_type": "知识图谱", "relation": "内容", "tail": "情况", "tail_type": "文本"}, {"head": "节点", "head_type": "知识图谱", "relation": "内容", "tail": "状态", "tail_type": "文本"}]}
{"text": "每个节点可以带有若干属性。", "relation": [{"head": "节点", "head_type": "知识图谱", "relation": "包含", "tail": "属性", "tail_type": "知识图谱"}]}
{"text": "节点与节点间的“连接弧”（称为联想弧）用以表示各种语义联系、动作。", "relation": [{"head": "连接弧", "head_type": "知识图谱", "relation": "等价", "tail": "联想弧", "tail_type": "知识图谱"}, {"head": "连接弧", "head_type": "知识图谱", "relation": "作用", "tail": "表示各种语义联系、动作", "tail_type": "文本"}]}
{"text": "语义网络的单元是三元组：（节点1，联想弧，节点2）。", "relation": [{"head": "语义网络的单元", "head_type": "知识图谱", "relation": "被定义为", "tail": "三元组", "tail_type": "文本"}, {"head": "三元组", "head_type": "知识图谱", "relation": "被定义为", "tail": "（节点1，联想弧，节点2）", "tail_type": "文本"}]}
{"text": "1.语义网络的优点1）联想性。2）易用性。3）结构性。", "relation": [{"head": "语义网络", "head_type": "知识图谱", "relation": "特点", "tail": "联想性、易用性、结构性", "tail_type": "文本"}]}
{"text": "语义网络最初是作为人类联想记忆模型提出来的。", "relation": [{"head": "语义网络", "head_type": "知识图谱", "relation": "来源", "tail": "人类联想记忆模型", "tail_type": "知识图谱"}]}
{"text": "语义网络是一种结构化的知识表示方法，对数据子图特别有效。", "relation": [{"head": "语义网络", "head_type": "知识图谱", "relation": "属于", "tail": "结构化的知识表示方法", "tail_type": "知识表示"}]}
{"text": "语义网络能把事物的属性以及事物间的各种语义联想显式地表示出来。", "relation": [{"head": "语义网络", "head_type": "知识图谱", "relation": "实现", "tail": "显式地表示事物的属性", "tail_type": "知识图谱"}, {"head": "语义网络", "head_type": "知识图谱", "relation": "实现", "tail": "显式地表示事物间的各种语义联想", "tail_type": "知识图谱"}]}
{"text": "2.语义网络的缺点1）无形式化语法。", "relation": [{"head": "语义网络", "head_type": "知识图谱", "relation": "缺点", "tail": "无形式化语法", "tail_type": "文本"}]}
{"text": "语义网络表示知识的手段多种多样，虽然灵活性很高，但同时也由于表示形式的不一致提高了对其处理的复杂性。", "relation": [{"head": "语义网络", "head_type": "知识图谱", "relation": "包含", "tail": "多种多样表示知识的手段", "tail_type": "知识表示"}]}
{"text": "2.2.4框架框架（Frame）最早由Marvin_Minsky在1975年提出[7]，目标是更好地理解视觉推理和自然语言处理。", "relation": [{"head": "框架", "head_type": "知识图谱", "relation": "目标", "tail": "更好地理解视觉推理和自然语言处理", "tail_type": "文本"}, {"head": "框架", "head_type": "知识图谱", "relation": "英文名", "tail": "Frame", "tail_type": "文本"}, {"head": "框架", "head_type": "知识图谱", "relation": "创建时间", "tail": "1975", "tail_type": "时间"}, {"head": "框架", "head_type": "知识图谱", "relation": "创建者", "tail": "Marvin_Minsky", "tail_type": "人物/实验室"}]}
{"text": "框架理论的基本思想是：认为人们对现实世界中各种事物的认识都以一种类似于框架的结构存储在记忆中。", "relation": [{"head": "框架理论", "head_type": "知识图谱", "relation": "内容", "tail": "人们对现实世界中各种事物的认识都以一种类似于框架的结构存储在记忆中", "tail_type": "文本"}]}
{"text": "框架是一种描述对象（事物、事件或概念等）属性的数据结构。", "relation": [{"head": "框架", "head_type": "知识图谱", "relation": "属于", "tail": "描述对象属性的数据结构", "tail_type": "知识图谱"}, {"head": "事物", "head_type": "知识图谱", "relation": "属于", "tail": "对象", "tail_type": "知识图谱"}, {"head": "事件", "head_type": "知识图谱", "relation": "属于", "tail": "对象", "tail_type": "知识图谱"}, {"head": "概念", "head_type": "知识图谱", "relation": "属于", "tail": "对象", "tail_type": "知识图谱"}]}
{"text": "在框架理论中，类是知识表示的基本单位。", "relation": [{"head": "类", "head_type": "知识表示", "relation": "被定义为", "tail": "知识表示的基本单位", "tail_type": "文本"}]}
{"text": "每个类有一些槽，每个槽又可分为若干“侧面”。", "relation": [{"head": "类", "head_type": "知识表示", "relation": "包含", "tail": "槽侧面", "tail_type": "知识图谱"}]}
{"text": "一个槽用于表示描述对象的一个属性，而一个侧面用语表示槽属性的一个方面，槽和侧面都可以有属性值，分别称为槽值和侧面值。", "relation": [{"head": "槽", "head_type": "知识表示", "relation": "作用", "tail": "表示描述对象的一个属性", "tail_type": "文本"}]}
{"text": "一个槽用于表示描述对象的一个属性，而一个侧面用于表示槽属性的一个方面，槽和侧面都可以有属性值，分别称为槽值和侧面值。", "relation": [{"head": "侧面", "head_type": "知识表示", "relation": "作用", "tail": "表示槽属性的一个方面", "tail_type": "文本"}]}
{"text": "除此之外，框架还允许给属性设默认值，以及设立触发器以维护框架。", "relation": [{"head": "框架", "head_type": "知识图谱", "relation": "实现", "tail": "给属性设默认值", "tail_type": "知识图谱"}, {"head": "框架", "head_type": "知识图谱", "relation": "实现", "tail": "设立触发器以维护框架", "tail_type": "知识图谱"}]}
{"text": "表2-1带变量框架实例表2-2变量赋值框架实例1.框架的优点1）结构性：能把事物的属性以及事物间的各种语义联想显式地表示出来。", "relation": [{"head": "框架", "head_type": "知识图谱", "relation": "特点", "tail": "结构性", "tail_type": "文本"}, {"head": "结构性", "head_type": "知识图谱", "relation": "内容", "tail": "能把事物的属性以及事物间的各种语义联想显式地表示出来", "tail_type": "文本"}]}
{"text": "框架的优点2）框架对于知识的描述比较全面，支持默认值以及触发器。", "relation": [{"head": "框架", "head_type": "知识图谱", "relation": "特点", "tail": "框架对于知识的描述比较全面，支持默认值以及触发器", "tail_type": "文本"}]}
{"text": "2.框架的缺点1）框架的构建成本非常高，对知识库的质量要求非常高。", "relation": [{"head": "框架", "head_type": "知识图谱", "relation": "缺点", "tail": "构建成本非常高", "tail_type": "文本"}, {"head": "框架", "head_type": "知识图谱", "relation": "缺点", "tail": "对知识库的质量要求非常高", "tail_type": "文本"}]}
{"text": "框架的缺点2）默认值会增大推理的复杂度。", "relation": [{"head": "框架", "head_type": "知识图谱", "relation": "缺点", "tail": "默认值会增大推理的复杂度", "tail_type": "文本"}]}
{"text": "框架的缺点3）无法表示不确定性知识。", "relation": [{"head": "框架", "head_type": "知识图谱", "relation": "缺点", "tail": "无法表示不确定性知识", "tail_type": "文本"}]}
{"text": "2.2.5描述逻辑描述逻辑是一阶逻辑的一个可判定子集。", "relation": [{"head": "描述逻辑", "head_type": "知识表示", "relation": "属于", "tail": "一阶逻辑的一个可判定子集", "tail_type": "知识表示"}]}
{"text": "描述逻辑最初由Ronald_J.Brachman在1985年提出。", "relation": [{"head": "描述逻辑", "head_type": "知识表示", "relation": "创建者", "tail": "Ronald_J.Brachman", "tail_type": "人物/实验室"}, {"head": "描述逻辑", "head_type": "知识表示", "relation": "创建时间", "tail": "1985", "tail_type": "时间"}]}
{"text": "描述逻辑可以被看成是利用一阶逻辑对语义网络和框架进行形式化后的产物。", "relation": [{"head": "描述逻辑", "head_type": "知识表示", "relation": "等价", "tail": "利用一阶逻辑对语义网络和框架进行形式化后的产物", "tail_type": "知识表示"}]}
{"text": "一元谓词称为类，二元谓词称为关系。", "relation": [{"head": "一元谓词", "head_type": "知识表示", "relation": "等价", "tail": "类", "tail_type": "知识表示"}, {"head": "二元谓词", "head_type": "知识表示", "relation": "等价", "tail": "关系", "tail_type": "知识表示"}]}
{"text": "描述逻辑的重要特征是同时具有很强的表达能力和可判定性。", "relation": [{"head": "描述逻辑", "head_type": "知识表示", "relation": "特点", "tail": "很强的表达能力", "tail_type": "文本"}, {"head": "描述逻辑", "head_type": "知识表示", "relation": "特点", "tail": "很强的可判定性", "tail_type": "文本"}]}
{"text": "描述逻辑近年来受到广泛关注，被选为W3C互联网本体语言（OWL）的理论基础。", "relation": [{"head": "描述逻辑", "head_type": "知识表示", "relation": "被定义为", "tail": "W3C互联网本体语言（OWL）的理论基础", "tail_type": "文本"}]}
{"text": "2.描述逻辑的缺点1）有限的表达能力。2）无法表示不确定性知识。", "relation": [{"head": "描述逻辑", "head_type": "知识表示", "relation": "缺点", "tail": "有限的表达能力，无法表示不确定性知识", "tail_type": "文本"}]}
{"text": "1.描述逻辑的优点1）结构性。2）严密性。3）多样性。4）易实现性。描述逻辑能把事物的属性以及事物间的各种语义联想显式地表示出来。", "relation": [{"head": "描述逻辑", "head_type": "知识表示", "relation": "特点", "tail": "结构性、严密性，多样性，易实现性，把事物的属性显式地表示出来", "tail_type": "文本"}]}
{"text": "描述逻辑有形式化的语法和语义，以及相关的推理规则。", "relation": [{"head": "描述逻辑", "head_type": "知识表示", "relation": "包含", "tail": "形式化的语法", "tail_type": "知识表示"}, {"head": "描述逻辑", "head_type": "知识表示", "relation": "包含", "tail": "语义以及相关的推理规则", "tail_type": "知识表示"}]}
{"text": "描述逻辑具有大量可判定的扩展，以满足不同应用场景的需求。", "relation": [{"head": "描述逻辑", "head_type": "知识表示", "relation": "包含", "tail": "可判定的扩展", "tail_type": "知识表示"}]}
{"text": "早期Web的标准语言HTML和XML无法适应语义网对知识表示的要求，所以W3C提出了新的Web的标准语言RDF、RDFS和OWL。", "relation": [{"head": "RDF", "head_type": "知识图谱项目", "relation": "属于", "tail": "Web的标准语言", "tail_type": "知识表示"}, {"head": "RDFS", "head_type": "知识图谱项目", "relation": "属于", "tail": "Web的标准语言", "tail_type": "知识表示"}, {"head": "OWL", "head_type": "知识图谱项目", "relation": "属于", "tail": "Web的标准语言", "tail_type": "知识表示"}, {"head": "RDF", "head_type": "知识图谱项目", "relation": "创建者", "tail": "W3C", "tail_type": "实验室"}, {"head": "RDFS", "head_type": "知识图谱项目", "relation": "创建者", "tail": "W3C", "tail_type": "实验室"}, {"head": "OWL", "head_type": "知识图谱项目", "relation": "创建者", "tail": "W3C", "tail_type": "实验室"}]}
{"text": "RDF和RDFS的语法可以跟XML兼容。", "relation": [{"head": "RDF", "head_type": "知识图谱项目", "relation": "实现", "tail": "语法可以跟XML兼容", "tail_type": "知识表示"}, {"head": "RDFS", "head_type": "知识图谱项目", "relation": "实现", "tail": "语法可以跟XML兼容", "tail_type": "知识表示"}]}
{"text": "RDF是W3C的RDF工作组制定的关于知识图谱的国际标准。", "relation": [{"head": "RDF", "head_type": "知识图谱项目", "relation": "属于", "tail": "关于知识图谱的国际标准", "tail_type": "知识图谱"}]}
{"text": "RDF是W3C一系列语义网标准的核心，如图2-4所示。", "relation": [{"head": "RDF", "head_type": "知识图谱项目", "relation": "被定义为", "tail": "W3C一系列语义网标准的核心", "tail_type": "文本"}]}
{"text": "●表示组（Representation）包括URI/IRI、XML和RDF。", "relation": [{"head": "表示组", "head_type": "知识图谱", "relation": "包含", "tail": "URI/IRI", "tail_type": "知识图谱项目"}, {"head": "表示组", "head_type": "知识图谱", "relation": "包含", "tail": "XML", "tail_type": "知识图谱项目"}, {"head": "表示组", "head_type": "知识图谱", "relation": "包含", "tail": "RDF", "tail_type": "知识图谱项目"}, {"head": "表示组", "head_type": "知识图谱", "relation": "英文名", "tail": "Representation", "tail_type": "文本"}]}
{"text": "URI/IRI和XML主要是为RDF提供语法基础。", "relation": [{"head": "URI/IRI", "head_type": "知识图谱项目", "relation": "作用", "tail": "为RDF提供语法基础", "tail_type": "文本"}, {"head": "XML", "head_type": "知识图谱项目", "relation": "作用", "tail": "为RDF提供语法基础", "tail_type": "文本"}]}
{"text": "●推理组（Reasoning）包括RDF-S、本体OWL、规则RIF和统一逻辑。", "relation": [{"head": "推理组", "head_type": "知识图谱", "relation": "包含", "tail": "RDF-S", "tail_type": "知识图谱项目"}, {"head": "推理组", "head_type": "知识图谱", "relation": "包含", "tail": "本体OWL", "tail_type": "知识图谱项目"}, {"head": "推理组", "head_type": "知识图谱", "relation": "包含", "tail": "规则RIF", "tail_type": "知识图谱项目"}, {"head": "推理组", "head_type": "知识图谱", "relation": "包含", "tail": "统一逻辑", "tail_type": "知识图谱项目"}, {"head": "推理组", "head_type": "知识图谱", "relation": "英文名", "tail": "Reasoning", "tail_type": "文本"}]}
{"text": "目前，跟知识图谱最相关的有：图2-4W3C的语义网标准栈及其分组2006年，人们开始用RDF发布和链接数据，从而生成基于RDF的知识图谱，比较知名的有DBpedia、Yago和Freebase。", "relation": [{"head": "DBpedia", "head_type": "知识图谱项目", "relation": "属于", "tail": "基于RDF的知识图谱", "tail_type": "知识图谱"}, {"head": "Yago", "head_type": "知识图谱项目", "relation": "属于", "tail": "基于RDF的知识图谱", "tail_type": "知识图谱"}, {"head": "Freebase", "head_type": "知识图谱项目", "relation": "属于", "tail": "基于RDF的知识图谱", "tail_type": "知识图谱"}]}
{"text": "2009年，Tim_Berners-Lee为进一步推动语义网开放数据的发展，进一步提出了开放链接数据的五星级原则，如表2-3所示。", "relation": [{"head": "开放链接数据的五星级原则", "head_type": "知识图谱", "relation": "创建者", "tail": "Tim_Berners-Lee", "tail_type": "人物"}, {"head": "开放链接数据的五星级原则", "head_type": "知识图谱", "relation": "创建时间", "tail": "2009年", "tail_type": "时间"}]}
{"text": "表2-3开放链接数据的五星级原则Tim_Berners-Lee提出了实现五星级原则的四个步骤：●使用URIs对事物命名；●使用HTTP_URIs，以方便搜索；●使用RDF描述事物并提供SPARQL端点，以方便对RDF图谱查询；●链接不同的图谱（例如通过owl:sameAs），以方便数据重用。", "relation": [{"head": "开放链接数据的五星级原则", "head_type": "知识图谱", "relation": "由组成", "tail": "使用URIs对事物命名", "tail_type": "知识图谱"}, {"head": "开放链接数据的五星级原则", "head_type": "知识图谱", "relation": "由组成", "tail": "使用HTTP_URIs", "tail_type": "知识图谱"}, {"head": "开放链接数据的五星级原则", "head_type": "知识图谱", "relation": "由组成", "tail": "使用RDF描述事物并提供SPARQL端点", "tail_type": "知识图谱"}, {"head": "开放链接数据的五星级原则", "head_type": "知识图谱", "relation": "由组成", "tail": "链接不同的图谱", "tail_type": "知识图谱"}]}
{"text": "每一份知识可以被分解为如下形式：(subject,predicate,object)。", "relation": [{"head": "知识", "head_type": "知识图谱", "relation": "等价", "tail": "(subject,predicate,object)", "tail_type": "知识图谱"}]}
{"text": "RDF中的主语是一个个体（Individual），个体是类的实例。", "relation": [{"head": "RDF中的主语", "head_type": "知识图谱", "relation": "等价", "tail": "个体", "tail_type": "知识图谱"}, {"head": "RDF", "head_type": "知识图谱项目", "relation": "包含", "tail": "RDF中的主语", "tail_type": "知识图谱"}, {"head": "个体", "head_type": "知识图谱", "relation": "等价", "tail": "类的实例", "tail_type": "知识图谱"}, {"head": "RDF", "head_type": "知识图谱项目", "relation": "包含", "tail": "RDF中的谓语", "tail_type": "知识图谱"}, {"head": "RDF", "head_type": "知识图谱项目", "relation": "包含", "tail": "RDF中的宾语", "tail_type": "知识图谱"}]}
{"text": "RDF中的谓语是一个属性。", "relation": [{"head": "RDF中的谓语", "head_type": "知识图谱", "relation": "等价", "tail": "属性", "tail_type": "知识图谱"}]}
{"text": "属性可以连接两个个体，或者连接一个个体和一个数据类型的实例。", "relation": [{"head": "属性", "head_type": "知识图谱", "relation": "作用", "tail": "连接两个个体", "tail_type": "文本"}, {"head": "属性", "head_type": "知识图谱", "relation": "作用", "tail": "连接一个个体和一个数据类型的实例", "tail_type": "文本"}]}
{"text": "换言之，RDF中的宾语可以是一个个体，例如（IBM-Talk,speaker,Jeff）也可以是一个数据类型的实例，例如（IBM-Talk,talkDate,“05-10-2012”^xsd:date）。", "relation": [{"head": "RDF中的宾语", "head_type": "知识图谱", "relation": "等价", "tail": "个体", "tail_type": "知识图谱"}, {"head": "RDF中的宾语", "head_type": "知识图谱", "relation": "等价", "tail": "数据类型的实例", "tail_type": "知识图谱"}]}
{"text": "在RDF中，三元组中的主谓宾都有一个全局标识URI，包括以上例子中的Jeff、IBM_Talk_和KG，如图2-7所示。", "relation": [{"head": "RDF中的主语", "head_type": "知识图谱", "relation": "由组成", "tail": "一个全局标识URI", "tail_type": "知识图谱"}, {"head": "RDF中的谓语", "head_type": "知识图谱", "relation": "由组成", "tail": "一个全局标识URI", "tail_type": "知识图谱"}, {"head": "RDF中的宾语", "head_type": "知识图谱", "relation": "由组成", "tail": "一个全局标识URI", "tail_type": "知识图谱"}]}
{"text": "RDF允许没有全局标识的空白节点（Blank_Node）。", "relation": [{"head": "RDF", "head_type": "知识图谱项目", "relation": "实现", "tail": "没有全局标识的空白节点", "tail_type": "知识图谱"}]}
{"text": "空白节点的前缀为“_”。", "relation": [{"head": "空白节点的前缀", "head_type": "知识图谱", "relation": "被定义为", "tail": "“_”", "tail_type": "文本"}]}
{"text": "RDF是抽象的数据模型，支持不同的序列化格式，例如RDF/XML、Turtle和N-Triple，如图2-10所示。", "relation": [{"head": "RDF", "head_type": "知识图谱项目", "relation": "属于", "tail": "抽象的数据模型", "tail_type": "知识图谱"}, {"head": "RDF", "head_type": "知识图谱项目", "relation": "实现", "tail": "不同的序列化格式", "tail_type": "知识图谱"}]}
{"text": "RDF是抽象的数据模型，支持不同的序列化格式，例如RDF/XML、Turtle和N-Triple，如图2-11所示。", "relation": [{"head": "不同的序列化格式", "head_type": "知识图谱", "relation": "包含", "tail": "RDF/XML", "tail_type": "知识图谱项目"}]}
{"text": "RDF是抽象的数据模型，支持不同的序列化格式，例如RDF/XML、Turtle和N-Triple，如图2-12所示。", "relation": [{"head": "不同的序列化格式", "head_type": "知识图谱", "relation": "包含", "tail": "Turtle", "tail_type": "知识图谱项目"}]}
{"text": "RDF是抽象的数据模型，支持不同的序列化格式，例如RDF/XML、Turtle和N-Triple，如图2-13所示。", "relation": [{"head": "不同的序列化格式", "head_type": "知识图谱", "relation": "包含", "tail": "N-Triple", "tail_type": "知识图谱项目"}]}
{"text": "图2-10不同的序列化格式2.开放世界假设不同于经典数据库采用封闭世界假设，RDF采用的是开放世界假设。", "relation": [{"head": "RDF", "head_type": "知识图谱项目", "relation": "方法", "tail": "开放世界假设", "tail_type": "文本"}]}
{"text": "采用开放世界假设意味着RDF图谱可以被分布式储存，如图2-11所示。", "relation": [{"head": "RDF图谱", "head_type": "知识图谱", "relation": "实现", "tail": "分布式储存", "tail_type": "知识图谱"}]}
{"text": "RDF用到了类以及属性描述个体之间的关系。", "relation": [{"head": "RDF", "head_type": "知识图谱项目", "relation": "作用", "tail": "用类以及属性描述个体之间的关系", "tail_type": "文本"}]}
{"text": "这些类和属性由模式（schema）定义。", "relation": [{"head": "类", "head_type": "知识图谱", "relation": "来源", "tail": "模式", "tail_type": "知识图谱"}, {"head": "属性", "head_type": "知识图谱", "relation": "来源", "tail": "模式", "tail_type": "知识图谱"}]}
{"text": "RDF_Schema（RDF模式，简称RDFS）提供了对类和属性的简单描述，从而给RDF数据提供词汇建模的语言。", "relation": [{"head": "RDF_Schema", "head_type": "知识图谱项目", "relation": "等价", "tail": "RDFS", "tail_type": "知识图谱项目"}, {"head": "RDFS", "head_type": "知识图谱项目", "relation": "包含", "tail": "对类和属性的简单描述", "tail_type": "知识图谱"}]}
{"text": "RDFS提供了最基本的对类和属性的描述元语：●rdf:type：用于指定个体的类；●rdfs:subClassOf：用于指定类的父类；●rdfs:subPropertyOf：用于指定属性的父属性；●rdfs:domain：用于指定属性的定义域；●rdfs:range：用于指定属性的值域。", "relation": [{"head": "RDFS", "head_type": "知识图谱项目", "relation": "包含", "tail": "对类和属性的描述元语", "tail_type": "知识图谱"}, {"head": "对类和属性的描述元语", "head_type": "知识图谱", "relation": "包含", "tail": "rdf:type", "tail_type": "知识图谱"}, {"head": "对类和属性的描述元语", "head_type": "知识图谱", "relation": "包含", "tail": "rdfs:subClassOf", "tail_type": "知识图谱"}, {"head": "对类和属性的描述元语", "head_type": "知识图谱", "relation": "包含", "tail": "rdfs:subPropertyOf", "tail_type": "知识图谱"}, {"head": "对类和属性的描述元语", "head_type": "知识图谱", "relation": "包含", "tail": "rdfs:domain", "tail_type": "知识图谱"}, {"head": "对类和属性的描述元语", "head_type": "知识图谱", "relation": "包含", "tail": "rdfs:range", "tail_type": "知识图谱"}, {"head": "rdf:type", "head_type": "知识图谱", "relation": "被定义为", "tail": "用于指定个体的类", "tail_type": "文本"}, {"head": "rdfs:subClassOf", "head_type": "知识图谱", "relation": "被定义为", "tail": "指定类的父类", "tail_type": "文本"}, {"head": "rdfs:subPropertyOf", "head_type": "知识图谱", "relation": "被定义为", "tail": "指定属性的父属性", "tail_type": "文本"}, {"head": "rdfs:domain", "head_type": "知识图谱", "relation": "被定义为", "tail": "指定属性的定义域", "tail_type": "文本"}, {"head": "rdfs:range", "head_type": "知识图谱", "relation": "被定义为", "tail": "指定属性的值域", "tail_type": "文本"}]}
{"text": "知识被分为两类，一类是数据层面的知识，例如haofen_type_Person（haofen是Person类的一个实例），另外一类是模式层面的知识，例如speaker_domainPerson（speaker属性的定义域是Person类）。", "relation": [{"head": "知识", "head_type": "知识图谱", "relation": "包含", "tail": "数据层面的知识", "tail_type": "知识图谱"}, {"head": "知识", "head_type": "知识图谱", "relation": "包含", "tail": "模式层面的知识", "tail_type": "知识图谱"}]}
{"text": "图2-13Author是Creator的子类图2-14RDFS示例2.3.2OWL和OWL2Fragments前面介绍了RDF和RDFS，通过RDF（S）可以表示一些简单的语义，但在更复杂的场景下，RDF（S）语义的表达能力显得太弱，还缺少常用的特征：（1）对于局部值域的属性定义。", "relation": [{"head": "RDFS", "head_type": "知识图谱项目", "relation": "缺点", "tail": "缺少对于局部值域的属性定义", "tail_type": "文本"}]}
{"text": "RDF（S）语义的表达能力显得太弱，还缺少常用的特征：（2）类、属性、个体的等价性。", "relation": [{"head": "RDFS", "head_type": "知识图谱项目", "relation": "缺点", "tail": "缺少类、属性、个体的等价性", "tail_type": "文本"}]}
{"text": "RDF（S）语义的表达能力显得太弱，还缺少常用的特征：（3）不相交类的定义。", "relation": [{"head": "RDFS", "head_type": "知识图谱项目", "relation": "缺点", "tail": "缺少不相交类的定义", "tail_type": "文本"}]}
{"text": "RDF（S）语义的表达能力显得太弱，还缺少常用的特征：（4）基数约束。", "relation": [{"head": "RDFS", "head_type": "知识图谱项目", "relation": "缺点", "tail": "缺少基数约束", "tail_type": "文本"}]}
{"text": "RDF（S）语义的表达能力显得太弱，还缺少常用的特征：（5）关于属性特性的描述。", "relation": [{"head": "RDFS", "head_type": "知识图谱项目", "relation": "缺点", "tail": "缺少关于属性特性的描述", "tail_type": "文本"}]}
{"text": "为了得到一个表达能力更强的本体语言，W3C提出了OWL语言扩展RDFS，作为在语义网上表示本体的推荐语言。", "relation": [{"head": "OWL", "head_type": "知识图谱项目", "relation": "目标", "tail": "得到一个表达能力更强的本体语言", "tail_type": "文本"}, {"head": "OWL", "head_type": "知识图谱项目", "relation": "被定义为", "tail": "在语义网上表示本体的推荐语言", "tail_type": "文本"}]}
{"text": "1.OWL的语言特征如图2-15所示，OWL1有OWL_Lite、OWL_DL、OWL_Full三个子语言，三个子语言的特征和使用限制举例如表2-4所示。", "relation": [{"head": "OWL1", "head_type": "知识图谱项目", "relation": "包含", "tail": "OWL_Lite", "tail_type": "知识图谱项目"}, {"head": "OWL1", "head_type": "知识图谱项目", "relation": "包含", "tail": "OWL_DL", "tail_type": "知识图谱项目"}, {"head": "OWL1", "head_type": "知识图谱项目", "relation": "包含", "tail": "OWL_Full", "tail_type": "知识图谱项目"}]}
{"text": "首先，OWL_Full可以看成是RDF的扩展；其次，OWL_Lite和OWL_Full可以看成是一个约束化的RDF的扩展；再次，所有的OWL文Full文档；最档（Lite、DL、Full）都是一个RDF文档，所有的RDF文档都是一个OWL后，只有一些RDF文档是一个合法的OWL_Lite和OWL_DL文档。", "relation": [{"head": "OWL_Full", "head_type": "知识图谱项目", "relation": "等价", "tail": "RDF的扩展", "tail_type": "知识图谱项目"}, {"head": "OWL_Full", "head_type": "知识图谱项目", "relation": "等价", "tail": "一个约束化的RDF的扩展", "tail_type": "知识图谱项目"}, {"head": "OWL_Lite", "head_type": "知识图谱项目", "relation": "等价", "tail": "一个约束化的RDF的扩展", "tail_type": "知识图谱项目"}]}
{"text": "2.OWL的重要词汇（1）等价性声明。", "relation": [{"head": "OWL", "head_type": "知识图谱项目", "relation": "包含", "tail": "OWL的重要词汇", "tail_type": "知识图谱"}, {"head": "OWL的重要词汇", "head_type": "知识图谱", "relation": "包含", "tail": "等价性声明", "tail_type": "知识图谱"}]}
{"text": "等价性声明的内容是声明两个类、属性和实例是等价的。", "relation": [{"head": "等价性声明", "head_type": "知识图谱", "relation": "内容", "tail": "声明两个类、属性和实例是等价的", "tail_type": "文本"}]}
{"text": "OWL的重要词汇（2）属性传递性声明。", "relation": [{"head": "OWL的重要词汇", "head_type": "知识图谱", "relation": "包含", "tail": "属性传递性声明", "tail_type": "知识图谱"}]}
{"text": "属性传递性声明的内容是声明一个属性是传递关系。", "relation": [{"head": "传递关系", "head_type": "知识图谱", "relation": "内容", "tail": "声明一个属性是传递关系", "tail_type": "文本"}]}
{"text": "OWL的重要词汇（3）属性互逆声明。", "relation": [{"head": "OWL的重要词汇", "head_type": "知识图谱", "relation": "包含", "tail": "属性互逆声明", "tail_type": "知识图谱"}]}
{"text": "属性互逆声明的内容是声明两个属性有互逆的关系。", "relation": [{"head": "属性互逆声明", "head_type": "知识图谱", "relation": "内容", "tail": "声明两个属性有互逆的关系", "tail_type": "文本"}]}
{"text": "OWL的重要词汇（4）属性的函数性声明。", "relation": [{"head": "OWL的重要词汇", "head_type": "知识图谱", "relation": "包含", "tail": "属性的函数性声明", "tail_type": "知识图谱"}]}
{"text": "属性的函数性声明的内容是声明一个属性是函数。", "relation": [{"head": "属性的函数性声明", "head_type": "知识图谱", "relation": "内容", "tail": "声明一个属性是函数", "tail_type": "文本"}]}
{"text": "OWL的重要词汇（5）属性的对称性声明。", "relation": [{"head": "OWL的重要词汇", "head_type": "知识图谱", "relation": "包含", "tail": "属性的对称性声明", "tail_type": "知识图谱"}]}
{"text": "属性的对称性声明的内容是声明一个属性是对称的。", "relation": [{"head": "属性的对称性声明", "head_type": "知识图谱", "relation": "内容", "tail": "声明一个属性是对称的", "tail_type": "文本"}]}
{"text": "OWL的重要词汇（6）属性的全称限定声明。", "relation": [{"head": "OWL的重要词汇", "head_type": "知识图谱", "relation": "包含", "tail": "属性的全称限定声明。", "tail_type": "知识图谱"}]}
{"text": "属性的全称限定声明的内容是声明一个属性是全称限定。", "relation": [{"head": "属性的全称限定声明。", "head_type": "知识图谱", "relation": "内容", "tail": "声明一个属性是全称限定", "tail_type": "文本"}]}
{"text": "OWL的重要词汇（7）属性的存在限定声明。", "relation": [{"head": "OWL的重要词汇", "head_type": "知识图谱", "relation": "包含", "tail": "属性的存在限定声明。", "tail_type": "知识图谱"}]}
{"text": "属性的存在限定声明的内容是声明一个属性是存在限定。", "relation": [{"head": "属性的存在限定声明。", "head_type": "知识图谱", "relation": "内容", "tail": "声明一个属性是存在限定", "tail_type": "文本"}]}
{"text": "OWL的重要词汇（8）属性的基数限定声明。", "relation": [{"head": "OWL的重要词汇", "head_type": "知识图谱", "relation": "包含", "tail": "属性的基数限定声明。", "tail_type": "知识图谱"}]}
{"text": "属性的基数限定声明的内容是声明一个属性的基数。", "relation": [{"head": "属性的基数限定声明。", "head_type": "知识图谱", "relation": "内容", "tail": "声明一个属性的基数", "tail_type": "文本"}]}
{"text": "OWL的重要词汇（9）相交的类声明。", "relation": [{"head": "OWL的重要词汇", "head_type": "知识图谱", "relation": "包含", "tail": "相交的类声明", "tail_type": "知识图谱"}]}
{"text": "相交的类声明的内容是声明一个类是等价于两个类相交。", "relation": [{"head": "相交的类声明", "head_type": "知识图谱", "relation": "内容", "tail": "声明一个类是等价于两个类相交", "tail_type": "文本"}]}
{"text": "第3章知识存储王鑫天津大学随着知识图谱规模的日益增长，数据管理愈加重要。", "relation": [{"head": "知识存储", "head_type": "知识存储", "relation": "实现", "tail": "知识图谱数据管理", "tail_type": "知识图谱"}]}
{"text": "一方面，以文件形式保存的知识图谱显然无法满足用户的查询、检索、推理、分析及各种应用需求；另一方面，传统数据库的关系模型与知识图谱的图模型之间存在显著差异，关系数据库无法有效地管理大规模知识图谱数据。", "relation": [{"head": "知识图谱", "head_type": "知识图谱", "relation": "包含", "tail": "数据库", "tail_type": "知识图谱"}]}
{"text": "为了更好地进行三元组数据的存储，语义万维网领域发展出专门存储RDF数据的三元组库；数据库领域发展出用于管理属性图的图数据库。", "relation": [{"head": "三元组数据库", "head_type": "知识存储", "relation": "作用", "tail": "存储RDF数据", "tail_type": "文本"}]}
{"text": "3.1知识图谱数据库基本知识本节首先介绍目前表示知识图谱的两种主要图数据模型：RDF图和属性图。", "relation": [{"head": "知识图谱数据库", "head_type": "知识存储", "relation": "作用", "tail": "目前表示知识图谱的两种主要图数据模型", "tail_type": "文本"}]}
{"text": "3.1.1知识图谱数据模型从数据模型角度来看，知识图谱本质上是一种图数据。", "relation": [{"head": "知识图谱", "head_type": "知识图谱", "relation": "属于", "tail": "图数据", "tail_type": "知识图谱"}]}
{"text": "不同领域的知识图谱均须遵循相应的数据模型。", "relation": [{"head": "知识图谱", "head_type": "知识图谱", "relation": "包含", "tail": "数据模型", "tail_type": "知识图谱"}]}
{"text": "往往一个数据模型的生命力要看其数学基础的强弱，关系模型长盛不衰的一个重要原因是其数学基础为关系代数。", "relation": [{"head": "关系模型", "head_type": "知识图谱", "relation": "由组成", "tail": "关系代数", "tail_type": "知识图谱"}]}
{"text": "知识图谱数据模型的数学基础源于有着近300年历史的数学分支——图论。", "relation": [{"head": "数据模型", "head_type": "知识图谱", "relation": "来源", "tail": "图论", "tail_type": "知识图谱"}]}
{"text": "在图论中，图是二元组G=（V,E），其中V是节点集合，E是边集合。", "relation": [{"head": "图", "head_type": "知识存储", "relation": "被定义为", "tail": "二元组G=（V,E）", "tail_type": "文本"}]}
{"text": "知识图谱数据模型基于图论中图的定义，用节点集合表示实体，用边集合表示实体间的联系，这种一般和通用的数据表示恰好能够自然地刻画现实世界中事物的广泛联系。", "relation": [{"head": "数据模型", "head_type": "知识图谱", "relation": "来源", "tail": "图的定义", "tail_type": "知识图谱"}]}
{"text": "1.RDF图RDF是W3C制定的在语义万维网上表示和交换机器可理解信息的标准数据模型[1]。", "relation": [{"head": "RDF", "head_type": "知识表示", "relation": "被定义为", "tail": "W3C制定的在语义万维网上表示和交换机器可理解信息的标准数据模型", "tail_type": "文本"}]}
{"text": "在RDF三元组集合中，每个Web资源具有一个HTTPURI作为其唯一的id；一个RDF图定义为三元组(s,p,o)的有限集合；每个三元组代表一个陈述句，其中s是主语，p是谓语，o是宾语；(s,p,o)表示资源s与资源o之间具有联系p，或表示资源s具有属性p且其取值为o。", "relation": [{"head": "RDF三元组", "head_type": "知识表示", "relation": "属于", "tail": "RDF", "tail_type": "知识表示"}, {"head": "RDF三元组", "head_type": "知识表示", "relation": "被定义为", "tail": "(s,p,o)的有限集合", "tail_type": "文本"}]}
{"text": "实际上，RDF三元组集合即为图中的有向边集合。", "relation": [{"head": "RDF三元组集合", "head_type": "知识表示", "relation": "被定义为", "tail": "图中的有向边集合", "tail_type": "文本"}]}
{"text": "节点属性可用三元组表示，这类三元组的宾语称为字面量，即图中的矩形。", "relation": [{"head": "节点属性", "head_type": "知识表示", "relation": "来源", "tail": "RDF三元组", "tail_type": "知识表示"}]}
{"text": "边上的属性表示起来稍显烦琐，最常见的是利用RDF中一种叫作“具体化”（reification）的技术[2]，需要引入额外的点表示整个三元组，将边属性表示为以该节点为主语的三元组。", "relation": [{"head": "边上的属性", "head_type": "知识表示", "relation": "来源", "tail": "具体化技术", "tail_type": "知识表示"}, {"head": "边上的属性", "head_type": "知识表示", "relation": "英文名", "tail": "reification", "tail_type": "文本"}]}
{"text": "图3-2RDF图中边属性的表示2.属性图属性图可以说是目前被图数据库业界采纳最广的一种图数据模型[3]。", "relation": [{"head": "属性图", "head_type": "知识表示", "relation": "内容", "tail": "目前被图数据库业界采纳最广的一种图数据模型[3]。", "tail_type": "文本"}]}
{"text": "图3-3给出的属性图不仅表达了RDF图的全部数据，而且还增加了边上的“权重”属性。", "relation": [{"head": "属性图", "head_type": "知识表示", "relation": "实现", "tail": "RDF图", "tail_type": "知识表示"}, {"head": "属性图", "head_type": "知识表示", "relation": "实现", "tail": "RDF三元组", "tail_type": "知识表示"}]}
{"text": "目前，RDF图上的查询语言是SPARQL；属性图上的查询语言常用的是Cypher和Gremlin。", "relation": [{"head": "SPARQL", "head_type": "知识图谱项目", "relation": "被定义为", "tail": "RDF图上的查询语言", "tail_type": "文本"}, {"head": "SPARQL", "head_type": "知识图谱项目", "relation": "属于", "tail": "查询语言", "tail_type": "知识图谱项目"}, {"head": "Cypher", "head_type": "知识图谱项目", "relation": "实现", "tail": "属性图", "tail_type": "知识表示"}]}
{"text": "1.SPARQLSPARQL是W3C制定的RDF图数据的标准查询语言[4]。", "relation": [{"head": "SPARQL", "head_type": "知识图谱项目", "relation": "被定义为", "tail": "W3C制定的RDF图数据的标准查询语言", "tail_type": "文本"}]}
{"text": "SPARQL从语法上借鉴了SQL，同样属于声明式查询语言。", "relation": [{"head": "SPARQL", "head_type": "知识图谱项目", "relation": "内容", "tail": "声明式查询语言", "tail_type": "文本"}]}
{"text": "最新的SPARQL1.1版本为有效查询RDF图专门设计了三元组模式、子图模式、属性路径等多种查询机制。", "relation": [{"head": "SPARQL1.1", "head_type": "知识图谱项目", "relation": "作用", "tail": "查询RDF图专门设计了三元组模式、子图模式、属性路径等多种查询机制", "tail_type": "文本"}]}
{"text": "几乎全部的RDF三元组数据库都实现了SPARQL语言。", "relation": [{"head": "RDF三元组数据库", "head_type": "知识表示", "relation": "实现", "tail": "SPARQL语言", "tail_type": "知识图谱项目"}]}
{"text": "三元组模式查询是最基本的SPARQL查询。", "relation": [{"head": "SPARQL查询", "head_type": "知识图谱项目", "relation": "包含", "tail": "三元组模式查询", "tail_type": "知识表示"}]}
{"text": "（2）查询程序员张三认识的其他程序员参加的项目输出：说明：这是由两个三元组模式组成的一个基本图模式（Basic_Graph_Pattern）查询，简称为BGP查询。", "relation": [{"head": "BGP查询", "head_type": "知识图谱项目", "relation": "被定义为", "tail": "两个三元组模式组成的一个基本图模式（Basic_Graph_Pattern）查询，简称为BGP查询。", "tail_type": "文本"}]}
{"text": "实际上，这两个三元组模式之间通过公共变量？p连接为一个链式查询。", "relation": [{"head": "三元组模式", "head_type": "知识表示", "relation": "包含", "tail": "链式查询", "tail_type": "知识表示"}]}
{"text": "这里既有？p和？pr分别作为两个三元组模式的宾语和主语连接起来的链式模式，也有？p作为两个三元组模式的主语连接起来的星形结构，该查询是一个更加一般的BGP查询。", "relation": [{"head": "三元组模式", "head_type": "知识表示", "relation": "由组成", "tail": "链式模式", "tail_type": "知识表示"}, {"head": "三元组模式", "head_type": "知识表示", "relation": "实现", "tail": "星形结构", "tail_type": "知识表示"}]}
{"text": "实际上，BGP查询相当于一个带有变量的查询图，查询过程是在数据图中寻找与查询图映射Isomorphism）或子图同态匹配的所有子图，等价于图论中的子图同构（Subgraph（Subgraph_Homomorphism）问题[5]，所以也将BGP查询称为子图匹配查询。", "relation": [{"head": "BGP查询", "head_type": "知识图谱项目", "relation": "等价", "tail": "子图匹配查询", "tail_type": "知识表示"}]}
{"text": "1.1引入的属性路径（Property_SPARQL_SPARQL实际上是一整套知识服务标准体系。", "relation": [{"head": "SPARQL", "head_type": "知识图谱项目", "relation": "属于", "tail": "知识服务标准体系", "tail_type": "知识表示"}]}
{"text": "SPARQL1.1语言的语法和语义的完整定义请参见W3C的推荐标准“SPARQL1.1查询语言”[4]，该标准连同其他10个推荐标准共同组成了SPARQL知识平台，包括查询[4]、更新[6]、服务描述[7]、联邦查询[8]、查询结果格式[9]、蕴涵推理[10]和接口协议[11]等。", "relation": [{"head": "SPARQL1.1查询语言", "head_type": "知识图谱项目", "relation": "属于", "tail": "SPARQL", "tail_type": "知识图谱项目"}]}
{"text": "2.CypherCypher最初是图数据库Neo4j中实现的属性图数据查询语言[15]。", "relation": [{"head": "Cypher", "head_type": "知识图谱项目", "relation": "属于", "tail": "属性图数据查询语言", "tail_type": "知识表示"}]}
{"text": "与SPARQL一样，Cypher也是一种声明式语言，即用户只需要声明“查什么”，而无须关心“怎么查”，这就好比乘坐出租车到一个目的地，只需要告诉司机要到哪里，具体的行车路线可由司机安排，乘客并不需要关心。", "relation": [{"head": "Cypher", "head_type": "知识图谱项目", "relation": "属于", "tail": "声明式语言", "tail_type": "知识表示"}]}
{"text": "这类语言的优点是便于用户学习掌握，同时给予数据库进行查询优化的空间，缺点是不能满足高级用户导航式查询的要求，数据库规划的查询执行计划有可能并不是最优方案。", "relation": [{"head": "数据库查询语言", "head_type": "知识表示", "relation": "目标", "tail": "便于用户学习掌握同时给予数据库进行查询优化的空间", "tail_type": "文本"}]}
{"text": "2015年，Neo4j公司发起开源项目openCypher[16]，旨在对Cypher进行标准化工作，为其他实现者提供语法和语义的参考标准。", "relation": [{"head": "openCypher", "head_type": "知识图谱项目", "relation": "目标", "tail": "Cypher标准化工作", "tail_type": "文本"}]}
{"text": "虽然Cypher的发展目前仍由Neo4j主导，但包括SAP_HANA_Graph[17]、Redis_Graph[18]、AgensGraph[19]和Memgraph[20]等在内的图数据库产品已经实现了Cypher。", "relation": [{"head": "Cypher", "head_type": "知识图谱项目", "relation": "属于", "tail": "Neo4j主导的图数据库产品", "tail_type": "知识图谱项目"}]}
{"text": "3.GremlinGremlin是Apache_TinkerPop图计算框架[21]提供的属性图查询语言[22]。", "relation": [{"head": "Gremlin", "head_type": "知识图谱项目", "relation": "属于", "tail": "属性图查询语言", "tail_type": "知识表示"}]}
{"text": "ApacheTinkerPop被设计为访问图数据库的通用API接口，其作用类似于关系数据库上的JDBC接口。", "relation": [{"head": "ApacheTinkerPop", "head_type": "知识图谱项目", "relation": "内容", "tail": "访问图数据库的通用API接口", "tail_type": "文本"}]}
{"text": "Gremlin的定位是图遍历语言，其执行机制好比是一个人置身于图中沿着有向边，从一个节点到另一个节点进行导航式的游走。", "relation": [{"head": "Gremlin", "head_type": "知识图谱项目", "relation": "属于", "tail": "图遍历语言", "tail_type": "知识表示"}]}
{"text": "这种执行方式决定了用户使用Gremlin需要指明具体的导航步骤，这和自己驾驶汽车到一个目的地需要知道行车路线是一个道理，所以将Gremlin归为过程式语言，即需要明确“怎么做”。", "relation": [{"head": "Gremlin", "head_type": "知识图谱项目", "relation": "属于", "tail": "过程式语言", "tail_type": "知识表述"}]}
{"text": "这类语言的优点是可以时刻知道自己在图中所处的位置，以及是如何到达该位置的；缺点是用户需要“认识路”！与受到SQL影响的声明式语言SPARQL和Cypher不同，Gremlin更像一种函数式的编程语言接口。", "relation": [{"head": "Gremlin", "head_type": "知识图谱项目", "relation": "属于", "tail": "函数式的编程语言接口", "tail_type": "知识表示"}]}
{"text": "下面通过几个例子认识Gremlin语言，假设用g代表图3-3中的属性图。", "relation": [{"head": "Gremlin", "head_type": "知识图谱项目", "relation": "属于", "tail": "图查询语言", "tail_type": "知识表示"}]}
{"text": "（1）列出图中所有节点的属性输出：说明：V表示节点集合。", "relation": [{"head": "V", "head_type": "知识表示", "relation": "目标", "tail": "列出图中所有节点的属性", "tail_type": "文本"}, {"head": "V", "head_type": "知识表示", "relation": "被定义为", "tail": "节点集合", "tail_type": "文本"}]}
{"text": "3.2常见知识图谱存储方法本节介绍三类知识图谱数据库：基于关系数据库的存储方案、面向RDF的三元组数据库和原生图数据库，多数系统给出了演示操作步骤。", "relation": [{"head": "基于关系数据库的存储方案", "head_type": "知识存储", "relation": "英文名", "tail": "based on relation database storage", "tail_type": "文本"}]}
{"text": "3.2.1基于关系数据库的存储方案关系数据库拥有40多年的发展历史，从理论到实践有着一整套成熟体系。", "relation": [{"head": "关系数据库", "head_type": "知识存储", "relation": "包含", "tail": "关系数据库的存储方案", "tail_type": "知识存储"}]}
{"text": "在历史上，关系数据库曾经取代了层次数据库和网状数据库；成功吸收容纳了面向对象数据库和XML数据库，成为现今数据管理的主流数据库产品。", "relation": [{"head": "关系数据库", "head_type": "知识存储", "relation": "实现", "tail": "历史数据管理的主流数据库产品", "tail_type": "知识图谱项目"}]}
{"text": "商业数据库包括Oracle、DB2和SQL_Server等，开源数据库包括PostgreSQL和MySQL等。", "relation": [{"head": "商业数据库", "head_type": "知识存储", "relation": "包含", "tail": "Oracle", "tail_type": "知识图谱项目"}, {"head": "商业数据库", "head_type": "知识存储", "relation": "包含", "tail": "DB2", "tail_type": "知识图谱项目"}, {"head": "商业数据库", "head_type": "知识存储", "relation": "包含", "tail": "SQL_Server", "tail_type": "知识图谱项目"}, {"head": "开源数据库", "head_type": "知识存储", "relation": "包含", "tail": "PostgreSQL", "tail_type": "知识图谱项目"}, {"head": "开源数据库", "head_type": "知识存储", "relation": "包含", "tail": "MySQL", "tail_type": "知识图谱项目"}]}
{"text": "因此基于历史上的成功经验，人们容易想到使用关系数据库存储知识图谱。", "relation": [{"head": "关系数据库", "head_type": "知识存储", "relation": "实现", "tail": "知识图谱", "tail_type": "知识图谱"}]}
{"text": "本小节将按照时间发展顺序简要介绍各种基于关系表的知识图谱存储结构，包括三元组表、水平表、属性表、垂直划分、六重索引和DB2RDF。", "relation": [{"head": "基于关系表的知识图谱存储结构", "head_type": "知识存储", "relation": "包含", "tail": "三元组表", "tail_type": "知识存储"}, {"head": "基于关系表的知识图谱存储结构", "head_type": "知识存储", "relation": "包含", "tail": "基于关系表的知识图谱存储结构", "tail_type": "知识存储"}]}
{"text": "如图3-4所示，下面以摘自DBpedia数据集[23]的RDF数据作为知识图谱进行讲解和举例。", "relation": [{"head": "RDF数据", "head_type": "知识图谱项目", "relation": "实现", "tail": "知识图谱进行讲解和举例", "tail_type": "知识图谱"}]}
{"text": "该知识图谱描述了IBM公司及其创始人Charles_Flint和Google公司及其创始人LarryPage的一些属性和联系。", "relation": [{"head": "知识图谱", "head_type": "知识存储", "relation": "创建者", "tail": "IBM公司", "tail_type": "人物/实验室"}]}
{"text": "表3-1三元组表三元组表存储方案虽然简单明了，但三元组表的行数与知识图谱的边数一样，其最大问题在于将知识图谱查询翻译为SQL查询后的三元组表自连接。", "relation": [{"head": "三元组表", "head_type": "知识存储", "relation": "属于", "tail": "存储方案", "tail_type": "知识存储"}]}
{"text": "当三元组表规模较大时，多个自连接操作会使SQL查询性能低下。", "relation": [{"head": "自连接操作", "head_type": "知识存储", "relation": "缺点", "tail": "降低SQL查询性能", "tail_type": "文本"}]}
{"text": "采用三元组表存储方案的代表是RDF数据库系统3store[24]。", "relation": [{"head": "RDF数据库系统3store", "head_type": "知识图谱项目", "relation": "属于", "tail": "采用三元组表存储方案", "tail_type": "知识存储"}]}
{"text": "图3-5一个星形SPARQL查询图3-6三元组表方案中SPARQL查询转换为等价的SQL查询2.水平表水平表存储方案同样非常简单，与三元组表不同，其每行记录存储一个知识图谱中一个主语的所有谓语和宾语。", "relation": [{"head": "SPARQL查询", "head_type": "知识图谱项目", "relation": "包含", "tail": "星形SPARQL查询", "tail_type": "知识图谱项目"}]}
{"text": "实际上，水平表就相当于知识图谱的邻接表。", "relation": [{"head": "水平表", "head_type": "知识存储", "relation": "等价", "tail": "知识图谱的邻接表", "tail_type": "知识存储"}]}
{"text": "不难看出，水平表的列数是知识图谱中不同谓语的数量，行数是知识图谱中不同主语的数量。", "relation": [{"head": "水平表的列数", "head_type": "知识存储", "relation": "内容", "tail": "知识图谱中不同谓语的数量", "tail_type": "文本"}, {"head": "水平表的行数", "head_type": "知识存储", "relation": "内容", "tail": "知识图谱中不同主语的数量", "tail_type": "文本"}, {"head": "水平表的列数", "head_type": "知识存储", "relation": "内容", "tail": "知识图谱中不同谓语的数量", "tail_type": "文本"}, {"head": "水平表的行数", "head_type": "知识存储", "relation": "内容", "tail": "知识图谱中不同主语的数量", "tail_type": "文本"}]}
{"text": "表3-2水平表在水平表存储方案中，图3-5所示的SPARQL查询可以等价地翻译为图3-7中的SQL查询。", "relation": [{"head": "水平表存储方案", "head_type": "知识存储", "relation": "包含", "tail": "SPARQL查询", "tail_type": "知识图谱项目"}]}
{"text": "可见，与三元组表相比，水平表的查询大为简化，仅需单表查询即可完成该任务，不用进行连接操作。", "relation": [{"head": "水平表", "head_type": "知识存储", "relation": "特点", "tail": "简化", "tail_type": "文本"}, {"head": "水平表", "head_type": "知识存储", "relation": "英文名", "tail": "level table", "tail_type": "文本"}]}
{"text": "采用水平表存储方案的代表是早期的RDF数据库系统DLDB[25]。", "relation": [{"head": "DLDB", "head_type": "知识图谱项目", "relation": "属于", "tail": "水平表存储方案", "tail_type": "知识存储"}]}
{"text": "3.属性表属性表（Property_Table）存储方案是对水平表的细化，将同类主语分到一个表中，不同类主语分到不同表中。", "relation": [{"head": "属性表", "head_type": "知识存储", "relation": "英文名", "tail": "Property_Table", "tail_type": "文本"}]}
{"text": "对于图3-5中的SPARQL查询，在属性表存储方案上等价的SQL查询如图3-9所示；该查询与图3-7中水平表上查询的唯一区别是将表名由t变为了person。", "relation": [{"head": "SPARQL查询", "head_type": "知识图谱项目", "relation": "特点", "tail": "在属性表存储方案上等价的SQL查询", "tail_type": "文本"}]}
{"text": "图3-8属性表图3-9属性表方案中SPARQL查询转换为等价的SQL查询属性表既克服了三元组表的自连接问题，又解决了水平表中列数目过多的问题。", "relation": [{"head": "属性表", "head_type": "知识存储", "relation": "作用", "tail": "SPARQL查询转换为等价的SQL查询", "tail_type": "文本"}, {"head": "属性表", "head_type": "知识存储", "relation": "实现", "tail": "SPARQL查询", "tail_type": "知识图谱项目"}]}
{"text": "实际上，水平表方案是属性表存储方案的一种极端情况，即水平表是将所有主语划归为一类，因此属性表中的空值问题与水平表相比会大为缓解。", "relation": [{"head": "水平表方案", "head_type": "知识存储", "relation": "属于", "tail": "属性表存储方案", "tail_type": "知识存储"}, {"head": "水平表方案", "head_type": "知识存储", "relation": "被定义为", "tail": "属性表存储方案的一种极端情况", "tail_type": "文本"}]}
{"text": "采用属性表存储方案的代表是RDF三元组库Jena[26]。", "relation": [{"head": "RDF三元组库Jena", "head_type": "知识图片项目", "relation": "属于", "tail": "采用属性表存储方案", "tail_type": "知识存储"}]}
{"text": "4.垂直+101:159划分垂直划分（Vertical_Partitioning）存储方案是由美国麻省理工学院的Abadi等人在2007年提出的RDF数据存储方法[27]。", "relation": [{"head": "垂直划分", "head_type": "知识存储", "relation": "属于", "tail": "存储方案", "tail_type": "知识存储"}]}
{"text": "4.垂直划分垂直划分（Vertical_Partitioning）存储方案是由美国麻省理工学院的Abadi等人在2007年提出的RDF数据存储方法[27]。", "relation": [{"head": "垂直划分", "head_type": "知识存储", "relation": "英文名", "tail": "Vertical_Partitioning", "tail_type": "文本"}]}
{"text": "该方法以三元组的谓语作为划分维度，将RDF知识图谱划分为若干张只包含(主语，宾语)两列的表，表的总数量即知识图谱中不同谓语的数量；也就是说，为每种谓语建立一张表，表中存放知识图谱中由该谓语连接的主语和宾语值。", "relation": [{"head": "RDF知识图谱的划分方法", "head_type": "知识存储", "relation": "被定义为", "tail": "为每种谓语建立一张表，表中存放知识图谱中由该谓语连接的主语和宾语值", "tail_type": "文本"}]}
{"text": "对于图3-5中的SPARQL查询，在垂直划分存储方案中等价的SQL查询如图3-11所示；该查询涉及3张谓语表born、died和founder的连接操作。", "relation": [{"head": "SPARQL查询", "head_type": "知识存储", "relation": "包含", "tail": "垂直划分存储方案", "tail_type": "知识存储"}]}
{"text": "由于谓语表中的行都是按照主语列进行排序的，可以快速执行这种以“主语-主语”作为连接条件的查询操作，而这种连接操作又是常用的。", "relation": [{"head": "谓语表", "head_type": "知识存储", "relation": "实现", "tail": "查询操作", "tail_type": "知识存储"}]}
{"text": "图3-10垂直划分存储方案图3-11垂直划分方案中等价的SQL查询不过，垂直划分存储方案依然存在几个缺点：需要创建的表的数目与知识图谱中不同谓语数目相等，而大规模的真实知识图谱（如DBpedia、YAGO、Wikidata等）中谓语数目可能超过几千个，在关系数据库中维护如此规模的表需要很大的开销；越是复杂的知识图谱查询操作，需要执行的表连接操作数量越多，而对于未指定谓语的三元组查询，将发生需要连接全部谓语表进行查询的极端情况；谓语表的数量越多，数据更新维护代价越大，对于一个主语的更新将涉及多张表，产生很高的更新时I/O开销。", "relation": [{"head": "垂直划分存储方案", "head_type": "知识存储", "relation": "英文名", "tail": "vertical partitioning storage", "tail_type": "文本"}]}
{"text": "采用垂直划分存储方案的代表数据库是SW-Store[28]。", "relation": [{"head": "SW-Store", "head_type": "知识图谱项目", "relation": "属于", "tail": "采用垂直划分存储方案的代表数据库", "tail_type": "知识存储"}]}
{"text": "不难看出，其中spo表就是原来的三元组表。", "relation": [{"head": "spo表", "head_type": "知识存储", "relation": "属于", "tail": "三元组表", "tail_type": "知识存储"}]}
{"text": "六重索引通过6张表的连接操作不仅缓解了三元组表的单表自连接问题，而且加速了某些典型知识图谱查询的效率。", "relation": [{"head": "六重索引", "head_type": "知识存储", "relation": "目标", "tail": "缓解三元组表的单表自连接问题以及加速某些典型知识图谱查询的效率", "tail_type": "文本"}]}
{"text": "使用六重索引方法的典型系统有RDF-3X[28]和Hexastore[29]。", "relation": [{"head": "RDF-3X", "head_type": "知识图谱项目", "relation": "属于", "tail": "六重索引方法", "tail_type": "知识存储"}, {"head": "六重索引方法的典型系统", "head_type": "知识存储", "relation": "包含", "tail": "RDF-3X", "tail_type": "知识图谱项目"}, {"head": "六重索引方法的典型系统", "head_type": "知识存储", "relation": "包含", "tail": "Hexastore", "tail_type": "知识图谱项目"}]}
{"text": "6.DB2RDFDB2RDF是由IBM研究中心于2013年提出的一种面向实体的RDF知识图谱存储方案[30]，该方案是以往RDF关系存储方案的一种权衡折中，既具备了三元组表、属性表和垂直划分方案的部分优点，又克服了这些方案的部分缺点。", "relation": [{"head": "DB2RDF", "head_type": "知识图谱项目", "relation": "属于", "tail": "面向实体的RDF知识图谱存储方案", "tail_type": "知识存储"}]}
{"text": "三元组表的优势在于“行维度”上的灵活性，即存储模式不会随行的增加而变化；DB2RDF方案将这种灵活性扩展到“列维度”上，即将表的列作为谓语和宾语的存储位置，而不将列与谓语进行绑定。", "relation": [{"head": "DB2RDF", "head_type": "知识图谱项目", "relation": "内容", "tail": "将表的列作为谓语和宾语的存储位置", "tail_type": "文本"}]}
{"text": "dph（direct_primary_hash）是存储方案的主表，该表中一行存储一个主语（主语列）及其全部谓语（predi列）和宾语（vali列）,0≤i≤k,k为图着色结果值或某个给定值。", "relation": [{"head": "dph", "head_type": "知识图谱项目", "relation": "属于", "tail": "存储方案的主表", "tail_type": "知识存储"}, {"head": "dph", "head_type": "知识图谱项目", "relation": "等价", "tail": "direct_primary_hash", "tail_type": "知识图谱项目"}]}
{"text": "spill列是溢出标志，即对于一行能存储下的实体，该行spill列为0，对于溢出的实体，该实体所有行的spill列为1。", "relation": [{"head": "spill列", "head_type": "知识存储", "relation": "属于", "tail": "溢出标志", "tail_type": "知识存储"}]}
{"text": "对于多值谓语的处理，引入ds（direct_secondary_hash）表。", "relation": [{"head": "ds表", "head_type": "知识存储", "relation": "实现", "tail": "多值谓语的处理", "tail_type": "知识存储"}]}
{"text": "当dph表中遇到一个多值谓语时，则在相应的宾语处生成一个唯一的id值；将该id值和每个对应的宾语存储为ds表的一行。", "relation": [{"head": "dph表", "head_type": "知识存储", "relation": "内容", "tail": "在相应的宾语处生成一个唯一的id值", "tail_type": "文本"}]}
{"text": "实际上，dph表实现了列的共享：一方面，不同实体的相同谓语总是会被分配到相同的列上；另一方面，同一列中可以存储多个不同的谓语。", "relation": [{"head": "dph表", "head_type": "知识存储", "relation": "实现", "tail": "列的共享", "tail_type": "知识存储"}]}
{"text": "正是由于DB2RDF方案具备“列共享”机制，才使得在关系表中最大列数目上限的情况下可以存储远超出该上限的谓语数目，也能够有效地解决水平表方案中存在的谓语稀疏性空值问题。", "relation": [{"head": "DB2RDF方案", "head_type": "知识图谱项目", "relation": "实现", "tail": "“列共享”机制", "tail_type": "知识存储"}]}
{"text": "图3-13DB2RDF方案从图数据模型的角度来看，dph表和ds表实际上存储了实体节点（主语）的出边信息（从主语经谓语到宾语）；为了提高查询处理效率，还需要存储实体节点的入边信息（从宾语经谓语到主语）。", "relation": [{"head": "dph表", "head_type": "知识存储", "relation": "包含", "tail": "图数据模型中存储实体节点出边信息", "tail_type": "知识存储"}, {"head": "dph表", "head_type": "知识存储", "relation": "包含", "tail": "出边信息", "tail_type": "知识存储"}, {"head": "ds表", "head_type": "知识存储", "relation": "包含", "tail": "出边信息", "tail_type": "知识存储"}, {"head": "dph表", "head_type": "知识存储", "relation": "包含", "tail": "入边信息", "tail_type": "知识存储"}, {"head": "ds表", "head_type": "知识存储", "relation": "包含", "tail": "入边信息", "tail_type": "知识存储"}]}
{"text": "为此，DB2RDF方案提供了rph（reverse_primary_hash）表和rs（reverse_secondary_hash）表，如图3-13所示。", "relation": [{"head": "rph表", "head_type": "知识存储", "relation": "属于", "tail": "DB2RDF方案", "tail_type": "知识图谱项目"}]}
{"text": "从中可以看出，对于知识图谱的星型查询，DB2RDF存储方案只需要查询dph表即可完成，无须进行连接操作。", "relation": [{"head": "DB2RDF存储方案", "head_type": "知识图谱项目", "relation": "属于", "tail": "星型查询", "tail_type": "知识存储"}, {"head": "DB2RDF存储方案", "head_type": "知识图谱项目", "relation": "实现", "tail": "等价查询dph表", "tail_type": "知识存储"}]}
{"text": "因为关系表中最大列的数目是固定的，该映射的两个优化目标是：使用的列的数目不要超过某个值m；尽量减少将同一主语的两个不同谓语分配到同一列的情况，从而减少溢出现象，因为溢出会导致查询时发生自连接。", "relation": [{"head": "映射的两个优化目标", "head_type": "知识存储", "relation": "目标", "tail": "使用的列数目不要超过某个值m", "tail_type": "文本"}, {"head": "映射的两个优化目标", "head_type": "知识存储", "relation": "作用", "tail": "尽量减少将同一主语的两个不同谓语分配到同一列的情况", "tail_type": "文本"}, {"head": "映射的两个优化目标", "head_type": "知识存储", "relation": "目标", "tail": "尽量减少将同一主语的两个不同谓语分配到同一列的情况", "tail_type": "文本"}]}
{"text": "谓语到列映射的一种方法是使用一组散列函数，将谓语映射到一组列编号，并将谓语及其宾语存储到这组列中的第一个空列上；在一个主语对应的一行中，如果存储某谓语（及其宾语）时，散列函数计算得出的这组列中的所有列都被之前存储的该主语的谓语占用了，则产生溢出，到下一行存储该谓语。", "relation": [{"head": "散列函数", "head_type": "知识存储", "relation": "被定义为", "tail": "将谓语映射到一组列编号，并将谓语及其宾语存储到这组列中的第一个空列上", "tail_type": "文本"}]}
{"text": "方法是将谓语到列的映射转化为图着色（Graph_Coloring）问题[31]。", "relation": [{"head": "将谓语到列的映射", "head_type": "知识存储", "relation": "等价", "tail": "图着色（Graph_Coloring）问题", "tail_type": "知识存储"}, {"head": "图着色", "head_type": "知识存储", "relation": "英文名", "tail": "Graph_Coloring", "tail_type": "文本"}]}
{"text": "将一个主语上出现的不同谓语称为共现谓语（Co-occurrence_Predicates），目标是让共现谓语着上不同颜色（映射到不同列中），非共现谓语可以着上相同颜色（映射到同一列中）。", "relation": [{"head": "共现谓语", "head_type": "知识存储", "relation": "被定义为", "tail": "将一个主语上出现的不同谓语称为", "tail_type": "文本"}, {"head": "共现谓语", "head_type": "知识存储", "relation": "英文名", "tail": "Co-occurrence_Predicates", "tail_type": "文本呢"}]}
{"text": "图着色问题的要求是为冲突图中的节点着上颜色，使得每个节点的颜色不同于其任一邻接节点的颜色，并使所用颜色数最少；对应到谓语映射问题，即为冲突图中的谓语节点分配列，使得每个谓语映射到的列不同于其任一共现谓语映射到的列，并使所用的列数目最少。", "relation": [{"head": "图着色问题", "head_type": "知识存储", "relation": "等价", "tail": "谓语映射问题", "tail_type": "知识存储"}, {"head": "图着色问题", "head_type": "知识存储", "relation": "来源", "tail": "图着色", "tail_type": "知识存储"}]}
{"text": "需要指出的是，图着色是经典的NP难问题，对于规模较大的冲突图可用贪心算法（如Welsh-Powell算法）[32]求得近似解。", "relation": [{"head": "贪心算法", "head_type": "知识存储", "relation": "包含", "tail": "Welsh-Powell算法", "tail_type": "知识存储"}]}
{"text": "3.2.2面向RDF的三元组数据库由于RDF是W3C推荐的表示语义网上关联数据（Linked_Data）的标准格式，RDF也是表示和发布Web上知识图谱的最主要数据格式之一。", "relation": [{"head": "RDF", "head_type": "知识存储", "relation": "属于", "tail": "三元组数据库", "tail_type": "知识存储"}, {"head": "三元组数据库", "head_type": "知识存储", "relation": "包含", "tail": "TRIP", "tail_type": "知识存储"}]}
{"text": "面向RDF的三元组数据库是专门为存储大规模RDF数据而开发的知识图谱数据库，其支持RDF的标准查询语言SPARQL。", "relation": [{"head": "面向RDF的三元组数据库", "head_type": "知识存储", "relation": "属于", "tail": "知识图谱数据库", "tail_type": "知识存储"}, {"head": "面向RDF的三元组数据库", "head_type": "知识存储", "relation": "实现", "tail": "SPARQL", "tail_type": "知识图谱项目"}]}
{"text": "主要的开源RDF三元组数据库包括：Apache旗下的Jena、Eclipse旗下的RDF4J以及源自学术界的RDF-3X和gStore；主要的商业RDF三元组数据库包括：Virtuoso、AllegroGraph、GraphDB和BlazeGraph。", "relation": [{"head": "RDF三元组数据库", "head_type": "知识存储", "relation": "包含", "tail": "Apache旗下的Jena", "tail_type": "知识存储"}, {"head": "RDF三元组数据库", "head_type": "知识存储", "relation": "包含", "tail": "Eclipse旗下的RDF4J", "tail_type": "知识存储"}, {"head": "RDF三元组数据库", "head_type": "知识存储", "relation": "包含", "tail": "RDF-3X", "tail_type": "知识图谱项目"}, {"head": "RDF三元组数据库", "head_type": "知识存储", "relation": "包含", "tail": "gStore", "tail_type": "知识图谱项目"}, {"head": "主要的商业RDF三元组数据库", "head_type": "知识存储", "relation": "包含", "tail": "Virtuoso", "tail_type": "知识图谱项目"}, {"head": "主要的商业RDF三元组数据库", "head_type": "知识存储", "relation": "包含", "tail": "AllegroGraph", "tail_type": "知识图谱项目"}, {"head": "主要的商业RDF三元组数据库", "head_type": "知识存储", "relation": "包含", "tail": "GraphDB", "tail_type": "知识图谱项目"}, {"head": "主要的商业RDF三元组数据库", "head_type": "知识存储", "relation": "包含", "tail": "BlazeGraph", "tail_type": "知识图谱项目"}, {"head": "Apache旗下的Jena", "head_type": "知识存储", "relation": "包含", "tail": "Jena", "tail_type": "知识图谱项目"}, {"head": "Eclipse旗下的RDF4J", "head_type": "知识存储", "relation": "包含", "tail": "RDF4J", "tail_type": "知识图谱项目"}, {"head": "源自学术界的RDF-3X", "head_type": "知识存储", "relation": "包含", "tail": "RDF-3X", "tail_type": "知识图谱项目"}, {"head": "源自学术界的gStore", "head_type": "知识存储", "relation": "包含", "tail": "gStore", "tail_type": "知识图谱项目"}, {"head": "Virtuoso", "head_type": "知识存储", "relation": "包含", "tail": "Virtuoso", "tail_type": "知识图谱项目"}, {"head": "AllegroGraph", "head_type": "知识存储", "relation": "包含", "tail": "AllegroGraph", "tail_type": "知识图谱项目"}, {"head": "GraphDB", "head_type": "知识存储", "relation": "包含", "tail": "GraphDB", "tail_type": "知识图谱项目"}, {"head": "BlazeGraph", "head_type": "知识存储", "relation": "包含", "tail": "BlazeGraph", "tail_type": "知识图谱项目"}]}
{"text": "ApacheJena将以实践形式进行详细介绍；下面分别介绍RDF4J、RDF-3X、gStore、Virtuoso、AllegroGraph、GraphDB和BlazeGraph。", "relation": [{"head": "ApacheJena", "head_type": "知识存储", "relation": "包含", "tail": "Apache Jena", "tail_type": "知识图谱项目"}]}
{"text": "1.开源RDF三元组数据库RDF4JRDF4J目前是Eclipse基金会旗下的开源孵化项目，其前身是荷兰软件公司Aduna开发的Sesame框架。", "relation": [{"head": "RDF4J", "head_type": "知识存储", "relation": "属于", "tail": "Eclipse基金会旗下的开源孵化项目", "tail_type": "知识图谱项目"}]}
{"text": "RDF4J框架的重要特点是其模块化的软件架构设计。", "relation": [{"head": "RDF4J", "head_type": "知识存储", "relation": "特点", "tail": "模块化的软件架构设计", "tail_type": "文本"}]}
{"text": "图3-16RDF4J的高层架构图（1）底层的RDF模型定义了URI、空节点（Blank_Node）、字面值（Literal）和语句（Statement）等RDF基本元素。", "relation": [{"head": "RDF模型", "head_type": "知识存储", "relation": "包含", "tail": "底层的RDF元素", "tail_type": "知识存储"}, {"head": "RDF模型", "head_type": "知识存储", "relation": "包含", "tail": "RDF基本元素", "tail_type": "知识存储"}]}
{"text": "（2）Rio代表“RDF_I/O”，即RDF输入/输出，包括各种RDF文件格式的解析器（Parser）和编写器（Writer），解析器负责将RDF文件解析为RDF模型中的三元组语句，编写器负责将三元组语句写为RDF文件。", "relation": [{"head": "Rio", "head_type": "知识存储", "relation": "包含", "tail": "RDF_I/O", "tail_type": "知识存储"}]}
{"text": "（4）存储库API（Repository_API）是用户使用的RDF管理和处理高层API，提供RDF的存储、查询和推理等服务，面向终端用户，简单易用；存储库API的一种实现是基于本地SAIL实现的SailRepository，另一种是基于远程HTTP服务器实现的HttpRepository。", "relation": [{"head": "存储库API", "head_type": "知识存储", "relation": "等价", "tail": "RDF管理和处理高层API", "tail_type": "知识存储"}, {"head": "存储库API", "head_type": "知识存储", "relation": "英文名", "tail": "Repository_API", "tail_type": "文本"}]}
{"text": "（5）架构图的顶层是用户开发的应用程序和HTTP服务器，用户应用程序直接调用存储库API;HTTP服务器实现了通过HTTP访问存储库API的Web服务，可通过HttpClient库与HTTP服务器进行远程通信，从而访问远程RDF4J存储库。", "relation": [{"head": "架构图的顶层", "head_type": "知识存储", "relation": "内容", "tail": "用户开发的应用程序和HTTP服务器", "tail_type": "文本"}, {"head": "用户应用程序", "head_type": "知识存储", "relation": "由组成", "tail": "直接调用存储库API", "tail_type": "知识存储"}, {"head": "HTTP服务器", "head_type": "知识存储", "relation": "目标", "tail": "通过HTTP访问存储库API的Web服务", "tail_type": "文本"}, {"head": "HTTP服务器", "head_type": "知识存储", "relation": "特点", "tail": "可通过HttpClient库与HTTP服务器进行远程通信", "tail_type": "文本"}, {"head": "HTTP服务器", "head_type": "知识存储", "relation": "方法", "tail": "访问远程RDF4J存储库", "tail_type": "文本"}]}
{"text": "目前，RDF-3X只支持Linux系统。", "relation": [{"head": "Linux系统", "head_type": "知识存储", "relation": "实现", "tail": "RDF-3X", "tail_type": "知识图谱项目"}]}
{"text": "RDF-3X的最大特点在于其为RDF数据精心打造的压缩物理存储方案、查询处理和查询优化技术。", "relation": [{"head": "RDF-3X", "head_type": "知识图谱项目", "relation": "目标", "tail": "为RDF数据精心打造的压缩物理存储方案、查询处理和查询优化技术", "tail_type": "文本"}]}
{"text": "在逻辑存储上，虽然以简单的三元组表为基础，但首次提出全索引方案：建立6种三元组索引spo、sop、osp、ops、pso和pos；建立6种二元聚合索引sp、ps、so、os、po和op；建立3种一元聚合索引s、p、o。", "relation": [{"head": "spo", "head_type": "知识存储", "relation": "属于", "tail": "全索引方案", "tail_type": "知识存储"}]}
{"text": "借助巧妙设计的三元组压缩技术，全索引方案的空间开销是可以接受的，全索引为查询处理和优化带来了巨大便利。", "relation": [{"head": "全索引", "head_type": "知识存储", "relation": "作用", "tail": "查询处理和优化带来便利", "tail_type": "文本"}]}
{"text": "对于利用全索引方案的查找，仅以spo索引为例进行举例。", "relation": [{"head": "全索引方案的查找", "head_type": "知识存储", "relation": "包含", "tail": "spo索引", "tail_type": "知识存储"}]}
{"text": "如图3-18所示，利用spo索引查找三元组模式(Albert_Einstein,invented,?x),spo索引中存储的是已经进行字典编码之后的由整数id值组成的(s,p,o)三元组，并且已按照s、p、o值由小到大的顺序进行了排序。", "relation": [{"head": "spo索引", "head_type": "知识存储", "relation": "属于", "tail": "查找三元组模式", "tail_type": "知识存储"}]}
{"text": "图3-18使用spo索引进行三元组模式查找RDF-3X的查询处理器首先对SPARQL查询进行转化，生成若干查询执行计划；对于仅包含一个三元组模式的查询，可以通过一次相应索引查找操作完成；对于由多个三元组模式组成的查询，需要对多个连接的顺序进行优化。", "relation": [{"head": "查询处理器", "head_type": "知识存储", "relation": "实现", "tail": "查询执行计划生成", "tail_type": "知识存储"}]}
{"text": "同时，RDF-3X还开发了基于代价模型的选择度评估（Selectivity_Estimates）机制，采用选择度直方图和频繁连接路径相结合的方法进行查询执行计划的选择度评估。", "relation": [{"head": "RDF-3X", "head_type": "知识图谱项目", "relation": "来源", "tail": "基于代价模型的选择度评估（Selectivity_Estimates）机制", "tail_type": "知识存储"}, {"head": "基于代价模型的选择度评估", "head_type": "知识存储", "relation": "英文名", "tail": "Selectivity_Estimates", "tail_type": "文本"}]}
{"text": "RDF-3X是命令行程序，使用RDF-3X装载RDF文件music_1000_triples.nt的命令如图3-19所示，其中的rdf3xload是命令名称，testds是数据库名称；进行SPARQL查询的命令如图3-20所示，rdf3query是命令名称，sparql.rq是SPARQL查询文件名称。", "relation": [{"head": "RDF-3X", "head_type": "知识图谱项目", "relation": "包含", "tail": "命令行程序", "tail_type": "知识存储"}]}
{"text": "图3-19使用RDF-3X装载RDF文件图3-20使用RDF-3X进行SPARQL查询3.开源RDF三元组数据库gStoregStore是基于图的RDF三元组数据库。", "relation": [{"head": "gStore", "head_type": "知识图谱项目", "relation": "属于", "tail": "基于图的RDF三元组数据库", "tail_type": "知识存储"}]}
{"text": "gStore将RDF图G中的每个实体节点及其邻居属性和属性值编码成一个二进制位串，由这些位串作为节点组成一张与RDF图G对应的标签图G*。", "relation": [{"head": "gStore", "head_type": "知识图谱项目", "relation": "内容", "tail": "将RDF图G中的每个实体节点及其邻居属性和属性值编码成一个二进制位串，由这些位串作为节点组成一张与RDF图G对应的标签图G*", "tail_type": "文本"}]}
{"text": "目前，gStore已经作为开源项目发布，源代码和文档可以从其GitHub项目网站下载。", "relation": [{"head": "gStore", "head_type": "知识图谱项目", "relation": "属于", "tail": "开源项目", "tail_type": "知识存储"}]}
{"text": "与RDF-3X一样，gStore只能在Linux系统上运行。", "relation": [{"head": "gStore", "head_type": "知识图谱项目", "relation": "属于", "tail": "Linux系统上的应用", "tail_type": "知识存储"}]}
{"text": "4.商业RDF三元组数据库VirtuosoVirtuoso虽然是可以支持多种数据模型的混合数据库管理系统，但其基础源自开发了多年的传统关系数据库管理系统，因此具备较为完善的事务管理、并发控制和完整性机制。", "relation": [{"head": "Virtuoso", "head_type": "知识图谱项目", "relation": "属于", "tail": "商业RDF三元组数据库", "tail_type": "知识存储"}]}
{"text": "Virtuoso同时发布了商业版本VirtuosoUniversalServer（Virtuoso统一服务器）和开源版本OpenLinkVirtuoso。", "relation": [{"head": "Virtuoso", "head_type": "知识图谱项目", "relation": "包含", "tail": "VirtuosoUniversalServer", "tail_type": "知识图谱项目"}, {"head": "Virtuoso", "head_type": "知识图谱项目", "relation": "包含", "tail": "OpenLinkVirtuoso", "tail_type": "知识图谱项目"}]}
{"text": "图3-21使用Virtuoso进行SPARQL查询5.商业RDF三元组数据库AllegroGraphAllegroGraph是Franz公司开发的RDF三元组数据库。", "relation": [{"head": "AllegroGraph", "head_type": "知识图谱项目", "relation": "属于", "tail": "商业RDF三元组数据库", "tail_type": "知识存储"}, {"head": "AllegroGraph", "head_type": "知识图谱项目", "relation": "属于", "tail": "Franz公司开发的RDF三元组数据库", "tail_type": "知识存储"}]}
{"text": "由于Franz公司有着深厚的人工智能背景，早期一直开发Common_Lisp和Prolog语言的实现工具，这使得AllegroGraph对语义推理功能具有较为完善的支持。", "relation": [{"head": "AllegroGraph", "head_type": "知识图谱项目", "relation": "属于", "tail": "知识图谱", "tail_type": "知识图谱"}]}
{"text": "AllegroGraph除了三元组数据库的基本功能外，还支持动态物化的RDFS++推理机、OWL2_RL推理机、Prolog规则推理系统、时空推理机制、社会网络分析库、可视化RDF图浏览器等。", "relation": [{"head": "AllegroGraph", "head_type": "知识图谱项目", "relation": "包含", "tail": "三元组数据库", "tail_type": "知识存储"}]}
{"text": "同时，AllegroGraph支持Java、Python、C#、Ruby、Clojure/Scala、Lisp等多种语言的编程访问接口。", "relation": [{"head": "AllegroGraph", "head_type": "知识图谱项目", "relation": "包含", "tail": "编程访问接口", "tail_type": "知识存储"}]}
{"text": "6.商业RDF三元组数据库GraphDBGraphDB是RDF三元组数据库，其前身OWLIM一直是支持W3C语义Web标准的主流产品。", "relation": [{"head": "GraphDB", "head_type": "知识图谱项目", "relation": "属于", "tail": "RDF三元组数据库", "tail_type": "知识存储"}]}
{"text": "GraphDB目前有社区免费版、标准版和企业版，其中企业版支持多台机器的集群分布式部署。", "relation": [{"head": "GraphDB", "head_type": "知识图谱项目", "relation": "包含", "tail": "社区免费版", "tail_type": "知识存储"}, {"head": "GraphDB", "head_type": "知识图谱项目", "relation": "包含", "tail": "标准版", "tail_type": "知识存储"}, {"head": "GraphDB", "head_type": "知识图谱项目", "relation": "包含", "tail": "企业版", "tail_type": "知识存储"}]}
{"text": "GraphDB的高层架构如图3-26所示。", "relation": [{"head": "GraphDB", "head_type": "知识图谱项目", "relation": " 包含", "tail": "高层架构", "tail_type": "知识存储"}]}
{"text": "（3）Connectors是GraphDB连接外部工具的桥梁，包括用于建立快速关键字查找功能的Lucene和用于建立搜索引擎的Solr和Elasticsearch。", "relation": [{"head": "Connectors", "head_type": "知识图谱项目", "relation": "属于", "tail": "GraphDB连接外部工具的桥梁", "tail_type": "知识图谱项目"}]}
{"text": "知识抽取和知识挖掘对于知识图谱的构建及应用具有重要的意义。", "relation": [{"head": "知识抽取", "head_type": "知识抽取", "relation": "属于", "tail": "知识图谱", "tail_type": "知识图谱"}]}
{"text": "本章将首先介绍知识抽取的技术和方法，然后介绍知识内容挖掘和知识结构挖掘。", "relation": [{"head": "知识抽取", "head_type": "知识抽取", "relation": "包含", "tail": "知识抽取的技术和方法", "tail_type": "知识抽取"}, {"head": "知识抽取", "head_type": "知识抽取", "relation": "包含", "tail": "知识内容挖掘", "tail_type": "知识抽取"}, {"head": "知识抽取", "head_type": "知识抽取", "relation": "包含", "tail": "知识结构挖掘", "tail_type": "知识抽取"}]}
{"text": "知识抽取的数据源可以是结构化数据（如链接数据、数据库）、半结构化数据（如网页中的表格、列表）或者非结构化数据（即纯文本数据）。", "relation": [{"head": "知识抽取数据源", "head_type": "知识抽取", "relation": "包含", "tail": "结构化数据", "tail_type": "知识抽取"}, {"head": "知识抽取数据源", "head_type": "知识抽取", "relation": "包含", "tail": "半结构化数据", "tail_type": "知识抽取"}, {"head": "知识抽取数据源", "head_type": "知识抽取", "relation": "包含", "tail": "非结构化数据", "tail_type": "知识抽取"}, {"head": "结构化数据", "head_type": "知识抽取", "relation": "内容", "tail": "链接数据、数据库", "tail_type": "文本"}, {"head": "半结构化数据", "head_type": "知识抽取", "relation": "内容", "tail": "网页中的表格、列表", "tail_type": "文本"}, {"head": "非结构化数据", "head_type": "知识抽取", "relation": "内容", "tail": "纯文本数据", "tail_type": "文本"}]}
{"text": "知识抽取的概念最早在20世纪70年代后期出现于NLP研究领域，是指自动化地从文本中发现和抽取相关信息，并将多个文本碎片中的信息进行合并，将非结构化数据转换为结构化数据，包括某一特定领域的模式、实体关系或RDF三元组。", "relation": [{"head": "知识抽取", "head_type": "知识抽取", "relation": "被定义为", "tail": "自动化地从文本中发现和抽取相关信息，并将多个文本碎片中的信息进行合并，将非结构化数据转换为结构化数据，包括某一特定领域的模式、实体关系或RDF三元组。", "tail_type": "文本"}]}
{"text": "图4-1知识抽取的典型例子具体地，知识抽取包括以下子任务：1.命名实体识别从文本中检测出命名实体，并将其分类到预定义的类别中，例如人物、组织、地点、时间等。", "relation": [{"head": "知识抽取", "head_type": "知识抽取", "relation": "包含", "tail": "命名实体识别", "tail_type": "知识抽取"}]}
{"text": "图4-1知识抽取的典型例子具体地，知识抽取包括以下子任务：2.命名实体识别从文本中检测出命名实体，并将其分类到预定义的类别中，例如人物、组织、地点、时间等。", "relation": [{"head": "命名实体识别", "head_type": "知识抽取", "relation": "被定义为", "tail": "从文本中检测出命名实体，并将其分类到预定义的类别中，例如人物、组织、地点、时间等", "tail_type": "文本"}]}
{"text": "2.关系抽取从文本中识别抽取实体及实体之间的关系。", "relation": [{"head": "知识抽取", "head_type": "知识抽取", "relation": "包含", "tail": "关系抽取", "tail_type": "知识抽取"}, {"head": "关系抽取", "head_type": "知识抽取", "relation": "被定义为", "tail": "从文本中识别抽取实体及实体之间的关系", "tail_type": "文本"}]}
{"text": "3.事件抽取识别文本中关于事件的信息，并以结构化的形式呈现。", "relation": [{"head": "知识抽取", "head_type": "知识抽取", "relation": "包含", "tail": "事件抽取", "tail_type": "知识抽取"}, {"head": "事件抽取", "head_type": "知识抽取", "relation": "被定义为", "tail": "识别文本中关于事件的信息，并以结构化的形式呈现。", "tail_type": "文本"}]}
{"text": "4.1.2知识抽取相关竞赛一些重要的竞赛对知识抽取技术的发展起到了巨大的推动作用。", "relation": [{"head": "知识抽取", "head_type": "知识抽取", "relation": "包含", "tail": "知识抽取相关竞赛", "tail_type": "知识抽取"}]}
{"text": "1.消息理解会议（Message_Understanding_Conference,MUC）MUC由美国国防部高级研究计划局（DARPA）启动并资助，目的是鼓励和开发更好的信息抽取方法。", "relation": [{"head": "消息理解会议", "head_type": "知识抽取", "relation": "属于", "tail": "知识抽取相关竞赛", "tail_type": "知识抽取"}, {"head": "消息理解会议", "head_type": "知识抽取", "relation": "英文名", "tail": "Message_Understanding_Conference,MUC", "tail_type": "文本"}, {"head": "消息理解会议", "head_type": "知识抽取", "relation": "创建者", "tail": "美国国防部高级研究计划局启动并资助", "tail_type": "人物/实验室"}, {"head": "消息理解会议", "head_type": "知识抽取", "relation": "目标", "tail": "鼓励和开发更好的信息抽取方法", "tail_type": "文本"}]}
{"text": "2.自动内容抽取（Automatic_Content_Extraction,ACE）ACE是一项由美国国家标准技术研究所（NIST）组织的评测会议，该会议从1999年至2008年共举办了八次评测。", "relation": [{"head": "自动内容抽取", "head_type": "知识抽取", "relation": "属于", "tail": "知识抽取相关竞赛", "tail_type": "知识抽取"}, {"head": "自动内容抽取", "head_type": "知识抽取", "relation": "英文名", "tail": "Automatic_Content_Extraction,ACE", "tail_type": "文本"}, {"head": "自动内容抽取", "head_type": "知识抽取", "relation": "创建者", "tail": "美国国家标准技术研究所", "tail_type": "人物/实验室"}]}
{"text": "3.知识库填充（Knowledge_Base_Population,KBP）KBP评测由文本分析会议（Text_Analysis_Conference,TAC）主办，其目标是开发和评估从非结构化文本中获取知识填充知识库的技术。", "relation": [{"head": "知识库填充", "head_type": "知识抽取", "relation": "属于", "tail": "知识抽取相关竞赛", "tail_type": "知识抽取"}, {"head": "知识库填充", "head_type": "知识抽取", "relation": "创建者", "tail": "文本分析会议", "tail_type": "人物/实验室"}, {"head": "知识库填充", "head_type": "知识抽取", "relation": "英文名", "tail": "Knowledge_Base_Population,KBP", "tail_type": "文本"}, {"head": "知识库填充", "head_type": "知识抽取", "relation": "目标", "tail": "开发和评估从非结构化文本中获取知识填充知识库的技术", "tail_type": "文本"}]}
{"text": "4.语义评测（Semantic_Evaluation,SemEval）SemEval是由ACL-SIGLEX组织的国际权威的词义消歧评测，目标是增进人们对词SenseEval，于1998年举办第一届。", "relation": [{"head": "语义评测", "head_type": "知识抽取", "relation": "属于", "tail": "知识抽取相关竞赛", "tail_type": "知识抽取"}, {"head": "语义评测", "head_type": "知识抽取", "relation": "英文名", "tail": "Semantic_Evaluation,SemEval", "tail_type": "文本"}, {"head": "语义评测", "head_type": "知识抽取", "relation": "创建者", "tail": "ACL-SIGLEX", "tail_type": "人物/实验室"}]}
{"text": "4.语义评测（Semantic_Evaluation,SemEval）SemEval是由ACL-SIGLEX组织的国际权威的词义消歧评测，目标是增进人们对词义与多义现象的理解，于1998年举办第一届。", "relation": [{"head": "语义评测", "head_type": "知识抽取", "relation": "目标", "tail": "增进人们对词义与多义现象的理解", "tail_type": "文本"}]}
{"text": "本节将对这一类面向非结构化数据的知识抽取技术和方法进行概要介绍，具体包括面向文本数据的实体抽取、关系抽取和事件抽取。", "relation": [{"head": "非结构化数据的知识抽取", "head_type": "知识抽取", "relation": "包含", "tail": "实体抽取", "tail_type": "知识抽取"}, {"head": "非结构化数据的知识抽取", "head_type": "知识抽取", "relation": "包含", "tail": "关系抽取", "tail_type": "知识抽取"}, {"head": "非结构化数据的知识抽取", "head_type": "知识抽取", "relation": "包含", "tail": "事件抽取", "tail_type": "知识抽取"}]}
{"text": "4.2.1实体抽取实体抽取又称命名实体识别，其目的是从文本中抽取实体信息元素，包括人名、组织机构名、地理位置、时间、日期、字符值和金额值等。", "relation": [{"head": "实体抽取", "head_type": "知识抽取", "relation": "等价", "tail": "命名实体识别", "tail_type": "知识抽取"}, {"head": "实体抽取", "head_type": "知识抽取", "relation": "目的", "tail": "是从文本中抽取实体信息元素，包括人名、组织机构名、地理位置、时间、日期、字符值和金额值等。", "tail_type": "文本"}]}
{"text": "总体上，可以将已有的实体抽取方法分为基于规则的方法、基于统计模型的方法和基于深度学习的方法。", "relation": [{"head": "实体抽取", "head_type": "知识抽取", "relation": "包含", "tail": "基于规则的方法", "tail_type": "知识抽取"}, {"head": "实体抽取", "head_type": "知识抽取", "relation": "包含", "tail": "基于统计模型的方法", "tail_type": "知识抽取"}, {"head": "实体抽取", "head_type": "知识抽取", "relation": "包含", "tail": "基于深度学习的方法", "tail_type": "知识抽取"}]}
{"text": "图4-2实体抽取举例1.基于规则的方法早期的命名实体识别方法主要采用人工编写规则的方式进行实体抽取。这类方法首先构建大量的实体抽取规则，一般由具有一定领域知识的专家手工构建。然后，将规则与文本字符串进行匹配，识别命名实体。", "relation": [{"head": "基于规则的方法", "head_type": "知识抽取", "relation": "内容", "tail": "采用人工编写规则的方式，首先构建大量的实体抽取规则，一般由具有一定领域知识的专家手工构建，将规则与文本字符串进行匹配，识别命名实体。", "tail_type": "文本"}]}
{"text": "2.基于统计模型的方法基于统计模型的方法利用完全标注或部分标注的语料进行模型训练，主要采用的模型包括隐马尔可夫模型（Hidden_Markov_Model）、条件马尔可夫模型（Conditional_MarkovModel）、最大熵模型（Maximum_Entropy_Model）以及条件随机场模型（ConditionalRandom_Fields）。", "relation": [{"head": "基于统计模型的方法 ", "head_type": "知识抽取", "relation": "内容", "tail": "利用完全标注或部分标注的语料进行模型训练", "tail_type": "文本"}, {"head": "基于统计模型的方法 ", "head_type": "知识抽取", "relation": "包含", "tail": "隐马尔可夫模型", "tail_type": "知识抽取"}, {"head": "基于统计模型的方法 ", "head_type": "知识抽取", "relation": "包含", "tail": "条件马尔可夫模型", "tail_type": "知识抽取"}, {"head": "基于统计模型的方法 ", "head_type": "知识抽取", "relation": "包含", "tail": "最大熵模型", "tail_type": "知识抽取"}, {"head": "基于统计模型的方法 ", "head_type": "知识抽取", "relation": "包含", "tail": "条件随机场模型", "tail_type": "知识抽取"}]}
{"text": "基于统计模型构建命名实体识别方法主要涉及训练语料标注、特征定义和模型训练三个方面。", "relation": [{"head": "基于统计模型的方法的实体识别", "head_type": "知识抽取", "relation": "包含", "tail": "训练语料标注", "tail_type": "知识抽取"}, {"head": "基于统计模型的方法的实体识别", "head_type": "知识抽取", "relation": "包含", "tail": "特征定义", "tail_type": "知识抽取"}, {"head": "基于统计模型的方法的实体识别", "head_type": "知识抽取", "relation": "包含", "tail": "模型训练", "tail_type": "知识抽取"}]}
{"text": "为了构建统计模型的训练语料，人们一般采用Inside–Outside–Beginning（IOB）或Inside–Outside（IO）标注体系对文本进行人工标注。", "relation": [{"head": "训练语料标注", "head_type": "知识抽取", "relation": "方法", "tail": "IOB标注体系", "tail_type": "知识抽取"}, {"head": "Inside–Outside（IO）", "head_type": "知识抽取", "relation": "方法", "tail": "IO标注体系", "tail_type": "知识抽取"}, {"head": "IOB标注体系", "head_type": "知识抽取", "relation": "英文名", "tail": "Inside–Outside–Beginning", "tail_type": "文本"}, {"head": "IO标注体系", "head_type": "知识抽取", "relation": "英文名", "tail": "Inside–Outside", "tail_type": "文本"}]}
{"text": "在IOB标注体系中，文本中的每个词被标记为实体名称的起始词（B）、实体名称的后续词（I）或实体名称的外部词（D）。", "relation": [{"head": "IOB标注体系", "head_type": "知识抽取", "relation": "内容", "tail": "词被标记为实体名称的起始词（B）、实体名称的后续词（I）或实体名称的外部词（D）", "tail_type": "文本"}]}
{"text": "而在IO标注体系中，文本中的词被标记为实体名称内部词（I）或实体名称外部词（D）。", "relation": [{"head": "IO标注体系", "head_type": "知识抽取", "relation": "内容", "tail": "词被标记为实体名称内部词（I）或实体名称外部词（D）", "tail_type": "文本"}]}
{"text": "特征定义。在训练模型之前，统计模型需要计算每个词的一组特征作为模型的输入。", "relation": [{"head": "特征定义", "head_type": "知识抽取", "relation": "被定义为", "tail": "计算每个词的一组特征作为模型的输入", "tail_type": "文本"}]}
{"text": "这些特征具体包括单词级别特征、词典特征和文档级特征等。", "relation": [{"head": "特征定义", "head_type": "知识抽取", "relation": "包含", "tail": "单词级别特征", "tail_type": "知识抽取"}, {"head": "特征定义", "head_type": "知识抽取", "relation": "包含", "tail": "词典特征", "tail_type": "知识抽取"}, {"head": "特征定义", "head_type": "知识抽取", "relation": "包含", "tail": "文档级特征", "tail_type": "知识抽取"}]}
{"text": "单词级别特征包括是否首字母大写、是否以句点结尾、是否包含数字、词性、词的n-gram等。", "relation": [{"head": "单词级别特征", "head_type": "知识抽取", "relation": "内容", "tail": "是否首字母大写、是否以句点结尾、是否包含数字、词性、词的n-gram", "tail_type": "文本"}]}
{"text": "词典特征依赖外部词典定义，例如预定义的词表、地名列表等。", "relation": [{"head": "词典特征", "head_type": "知识抽取", "relation": "内容", "tail": "外部词典定义", "tail_type": "文本"}]}
{"text": "文档级特征基于整个语料文档集计算，例如文档集中的词频、同现词等。", "relation": [{"head": "文档级特征", "head_type": "知识抽取", "relation": "内容", "tail": "整个语料文档集计算", "tail_type": "文本"}]}
{"text": "隐马尔可夫模型是一种有向图概率模型，模型中包含了隐藏的状态序列和可观察的观测序列。", "relation": [{"head": "隐马尔可夫模型", "head_type": "知识抽取", "relation": "被定义为", "tail": "一种有向图概率模型，模型中包含了隐藏的状态序列和可观察的观测序列", "tail_type": "文本"}]}
{"text": "条件随机场模型是给定一组输入随机变量条件下另一组输出随机变量的条件概率分布模型。", "relation": [{"head": "条件随机场模型", "head_type": "知识抽取", "relation": "被定义为", "tail": "给定一组输入随机变量条件下另一组输出随机变量的条件概率分布模型", "tail_type": "文本"}]}
{"text": "与传统统计模型相比，基于深度学习的方法直接以文本中词的向量为输入，通过神经网络实现端到端的命名实体识别，不再依赖人工定义的特征。", "relation": [{"head": "基于深度学习的方法", "head_type": "知识抽取", "relation": "被定义为", "tail": "直接以文本中词的向量为输入，通过神经网络实现端到端的命名实体识别", "tail_type": "文本"}]}
{"text": "目前，基于深度学习的方法用于命名实体识别的神经网络主要有卷积神经网络（Convolutional_NeuralNetwork,CNN）、循环神经网络（Recurrent_Neural_Network,RNN）以及引入注意力机制（Attention_Mechanism）的神经网络。", "relation": [{"head": "基于深度学习的方法", "head_type": "知识抽取", "relation": "包含", "tail": "卷积神经网络", "tail_type": "知识抽取"}, {"head": "基于深度学习的方法", "head_type": "知识抽取", "relation": "包含", "tail": "循环神经网络", "tail_type": "知识抽取"}, {"head": "基于深度学习的方法", "head_type": "知识抽取", "relation": "包含", "tail": "基于注意力机制的神经网络模型", "tail_type": "知识抽取"}, {"head": "命名实体识别", "head_type": "知识抽取", "relation": "方法", "tail": "卷积神经网络", "tail_type": "知识抽取"}, {"head": "命名实体识别", "head_type": "知识抽取", "relation": "方法", "tail": "循环神经网络", "tail_type": "知识抽取"}, {"head": "命名实体识别", "head_type": "知识抽取", "relation": "方法", "tail": "基于注意力机制的神经网络模型", "tail_type": "知识抽取"}]}
{"text": "目前，用于命名实体识别的神经网络主要有卷积神经网络（Convolutional_NeuralNetwork,CNN）、循环神经网络（Recurrent_Neural_Network,RNN）以及引入注意力机制（Attention_Mechanism）的神经网络。", "relation": [{"head": "卷积神经网络", "head_type": "知识抽取", "relation": "英文名", "tail": "Convolutional_NeuralNetwork", "tail_type": "文本"}, {"head": "循环神经网络", "head_type": "知识抽取", "relation": "英文名", "tail": "Recurrent_Neural_Network", "tail_type": "文本"}]}
{"text": "（1）基于深度学习的方法的LSTM-CRF模型。该模型使用了长短时记忆神经网络（Long_Shot-Term_Memory_Neural_Network,LSTM）与CRF相结合进行命名实体识别。", "relation": [{"head": "基于深度学习的方法", "head_type": "知识抽取", "relation": "包含", "tail": "LSTM-CRF模型", "tail_type": "知识抽取"}]}
{"text": "（2）基于深度学习的方法的LSTM-CRF模型。该模型使用了长短时记忆神经网络（Long_Shot-Term_Memory_Neural_Network,LSTM）与CRF相结合进行命名实体识别。", "relation": [{"head": "LSTM-CRF模型", "head_type": "知识抽取", "relation": "方法", "tail": "使用了长短时记忆神经网络（Long_Shot-Term_Memory_Neural_Network,LSTM）与CRF相结合进行命名实体识别", "tail_type": "文本"}]}
{"text": "（2）基于深度学习的方法的LSTM-CNNs-CRF模型。MA_Xuezhe等人发表于ACL2016的论文提出了将双向LSTM、CNN和CRF相结合的序列标注模型[5]，并成功地应用于命名实体识别问题中。", "relation": [{"head": "基于深度学习的方法", "head_type": "知识抽取", "relation": "包含", "tail": "LSTM-CNNs-CRF模型", "tail_type": "知识抽取"}]}
{"text": "该模型与LSTM-CRF模型十分相似，不同之处是在Embedding层中加入了每个词的字符级向量表示。", "relation": [{"head": "LSTM-CNNs-CRF模型", "head_type": "知识抽取", "relation": "方法", "tail": "与LSTM-CRF模型十分相似，但Embedding层中加入了每个词的字符级向量表示", "tail_type": "文本"}]}
{"text": "（3）基于注意力机制的神经网络模型。在自然语言处理领域，基于注意力机制的神经网络模型最早应用于解决机器翻译问题，注意力机制可以帮助扩展基本的编码器-解码器模型结构，让模型能够获取输入序列中与下一个目标词相关的信息。", "relation": [{"head": "基于注意力机制的神经网络模型", "head_type": "知识抽取", "relation": "特点", "tail": "注意力机制可以帮助扩展基本的编码器-解码器模型结构，让模型能够获取输入序列中与下一个目标词相关的信息", "tail_type": "文本"}]}
{"text": "4.2.2关系抽取关系抽取是知识抽取的重要子任务之一，面向非结构化文本数据，关系抽取是从文本中抽取出两个或者多个实体之间的语义关系。", "relation": [{"head": "关系抽取", "head_type": "知识抽取", "relation": "属于", "tail": "知识抽取", "tail_type": "知识抽取"}]}
{"text": "4.2.3关系抽取关系抽取是知识抽取的重要子任务之一，面向非结构化文本数据，关系抽取是从文本中抽取出两个或者多个实体之间的语义关系。", "relation": [{"head": "关系抽取", "head_type": "知识抽取", "relation": "被定义为", "tail": "从文本中抽取出两个或者多个实体之间的语义关系", "tail_type": "文本"}]}
{"text": "目前，关系抽取方法可以分为基于模板的关系抽取方法、基于监督学习的关系抽取方法和基于弱监督学习的关系抽取方法。", "relation": [{"head": "关系抽取", "head_type": "知识抽取", "relation": "包含", "tail": "基于模板的关系抽取方法", "tail_type": "知识抽取"}, {"head": "关系抽取", "head_type": "知识抽取", "relation": "包含", "tail": "基于监督学习的关系抽取方法", "tail_type": "知识抽取"}, {"head": "关系抽取", "head_type": "知识抽取", "relation": "包含", "tail": "基于弱监督学习的关系抽取方法", "tail_type": "知识抽取"}]}
{"text": "基于模板的关系抽取方法基于语言学知识，结合语料的特点，由领域专家手工编写模板，从文本中匹配具有特定关系的实体。", "relation": [{"head": "基于模板的关系抽取方法", "head_type": "知识抽取", "relation": "被定义为", "tail": "基于语言学知识，结合语料的特点，由领域专家手工编写模板，从文本中匹配具有特定关系的实体", "tail_type": "文本"}]}
{"text": "基于模板的关系抽取方法的优点是模板构建简单，可以比较快地在小规模数据集上实现关系抽取系统。", "relation": [{"head": "基于模板的关系抽取方法", "head_type": "知识抽取", "relation": "特点", "tail": "模板构建简单，可以比较快地在小规模数据集上实现关系抽取系统", "tail_type": "文本"}]}
{"text": "但是，当数据规模较大时，手工构建模板需要耗费领域专家大量的时间。此外，基于模板的关系抽取系统可移植性较差，当面临另一个领域的关系抽取问题时，需要重新构建模板。最后，由于手工构建的模板数量有限，模板覆盖的范围不够，基于模板的关系抽取系统召回率普遍不高。", "relation": [{"head": "基于模板的关系抽取方法", "head_type": "知识抽取", "relation": "缺点", "tail": "当数据规模较大时，手工构建模板需要耗费领域专家大量的时间；可移植性较差，当面临另一个领域的关系抽取问题时，需要重新构建模板；召回率普遍不高", "tail_type": "文本"}]}
{"text": "2.基于监督学习的关系抽取方法基于监督学习的关系抽取方法将关系抽取转化为分类问题，在大量标注数据的基础上，训练有监督学习模型进行关系抽取。", "relation": [{"head": "基于监督学习的关系抽取方法", "head_type": "知识抽取", "relation": "被定义为", "tail": "将关系抽取转化为分类问题，在大量标注数据的基础上，训练有监督学习模型进行关系抽取", "tail_type": "文本"}]}
{"text": "在上述步骤中，关系抽取特征的定义对于抽取的结果具有较大的影响，因此大量的研究工作围绕关系抽取特征的设计展开。根据计算特征的复杂性，可以将常用的特征分为轻量级、中等量级和重量级三大类。", "relation": [{"head": "关系抽取特征", "head_type": "知识抽取", "relation": "包含", "tail": "轻量级特征", "tail_type": "知识抽取"}, {"head": "关系抽取特征", "head_type": "知识抽取", "relation": "包含", "tail": "中等量级特征", "tail_type": "知识抽取"}, {"head": "关系抽取特征", "head_type": "知识抽取", "relation": "包含", "tail": "重量级特征", "tail_type": "知识抽取"}]}
{"text": "轻量级特征主要是基于实体和词的特征，例如句子中实体前后的词、实体的类型以及实体之间的距离等。", "relation": [{"head": "轻量级特征", "head_type": "知识抽取", "relation": "被定为", "tail": "基于实体和词的特征", "tail_type": "文本"}]}
{"text": "中等量级特征主要是基于句子中语块序列的特征。", "relation": [{"head": "中等量级特征", "head_type": "知识抽取", "relation": "被定为", "tail": "基于句子中语块序列的特征", "tail_type": "文本"}]}
{"text": "重量级特征一般包括实体间的依存关系路径、实体间依存树结构的距离以及其他特定的结构信息。", "relation": [{"head": "重量级特征", "head_type": "知识抽取", "relation": "被定为", "tail": "实体间的依存关系路径、实体间依存树结构的距离以及其他特定的结构信息", "tail_type": "文本"}]}
{"text": "基于监督学习的关系抽取是一种依赖特征工程的方法，近年来有多个基于深度学习的关系抽取模型被研究者们提出。", "relation": [{"head": "基于监督学习的关系抽取", "head_type": "知识抽取", "relation": "包含", "tail": "基于深度学习的关系抽取模型", "tail_type": "知识抽取"}]}
{"text": "目前，已有的基于深度学习的关系抽取方法主要包括流水线方法和联合抽取方法两大类。", "relation": [{"head": "基于深度学习的关系抽取模型", "head_type": "知识抽取", "relation": "包含", "tail": "流水线方法", "tail_type": "知识抽取"}, {"head": "基于深度学习的关系抽取模型", "head_type": "知识抽取", "relation": "包含", "tail": "联合抽取方法", "tail_type": "知识抽取"}]}
{"text": "（1）基于深度学习的流水线关系抽取方法●CR-CNN模型[7]。●Attention_CNNs模型[8]。●Attention_BLSTM模型[9]。", "relation": [{"head": "流水线方法", "head_type": "知识抽取", "relation": "包含", "tail": "CR-CNN", "tail_type": "知识抽取"}]}
{"text": "（1）基于深度学习的流水线关系抽取方法●CR-CNN模型[7]。●Attention_CNNs模型[8]。●Attention_BLSTM模型[10]。", "relation": [{"head": "流水线方法", "head_type": "知识抽取", "relation": "包含", "tail": "Attention_CNNs", "tail_type": "知识抽取"}]}
{"text": "（1）基于深度学习的流水线关系抽取方法●CR-CNN模型[7]。●Attention_CNNs模型[8]。●Attention_BLSTM模型[11]。", "relation": [{"head": "流水线方法", "head_type": "知识抽取", "relation": "包含", "tail": "Attention_BLSTM", "tail_type": "知识抽取"}]}
{"text": "在流水线关系抽取方法中，实体抽取和关系抽取两个过程是分离的。", "relation": [{"head": "流水线方法", "head_type": "知识抽取", "relation": "被定义为", "tail": "实体抽取和关系抽取两个过程是分离的", "tail_type": "文本"}]}
{"text": "联合关系抽取方法则是将实体抽取和关系抽取相结合，图4-13展示的是一个实体抽取和关系抽取的联合模型[13]。", "relation": [{"head": "流水线方法", "head_type": "知识抽取", "relation": "被定义为", "tail": "将实体抽取和关系抽取相结合", "tail_type": "文本"}]}
{"text": "第5章知识图谱融合汪鹏东南大学5.1什么是知识图谱融合知识图谱包含描述抽象知识的本体层和描述具体事实的实例层。", "relation": [{"head": "知识图谱", "head_type": "知识图谱", "relation": "包含", "tail": "本体层", "tail_type": "知识图谱"}, {"head": "知识图谱", "head_type": "知识图谱", "relation": "包含", "tail": "实例层", "tail_type": "知识图谱"}]}
{"text": "本体层用于描述特定领域中的抽象概念、属性、公理；实例层用于描述具体的实体对象、实体间的关系，包含大量的事实和数据。", "relation": [{"head": "本体层", "head_type": "知识图谱", "relation": "被定义为", "tail": "描述特定领域中的抽象概念、属性、公理", "tail_type": "文本"}, {"head": "实例层", "head_type": "知识图谱", "relation": "被定义为", "tail": "描述具体的实体对象、实体间的关系，包含大量的事实和数据", "tail_type": "文本"}]}
{"text": "这些本体描述的内容在语义上往往重叠或关联，但使用的本体在表示语言和表示模型上却具有差异，这便造成了本体异构。", "relation": [{"head": "本体异构", "head_type": "知识融合", "relation": "被定义为", "tail": "本体描述的内容在语义上往往重叠或关联，但使用的本体在表示语言和表示模型上却具有差异", "tail_type": "文本"}]}
{"text": "知识融合建立异构本体或异构实例之间的联系，从而使异构的知识图谱能相互沟通，实现它们之间的互操作。", "relation": [{"head": "知识融合", "head_type": "知识融合", "relation": "被定义为", "tail": "建立异构本体或异构实例之间的联系，从而使异构的知识图谱能相互沟通，实现它们之间的互操作", "tail_type": "文本"}]}
{"text": "下面分别阐述这两种层次上的异构。5.2.1语言层不匹配在知识工程发展的过程中出现了多种知识表示语言。", "relation": [{"head": "知识图谱中的异构", "head_type": "知识融合", "relation": "包含", "tail": "语言层不匹配", "tail_type": "知识融合"}]}
{"text": "不同的时期都存在着几种流行的语言，如早期有Ontolingua和Loom等本体语言，近年则有DAML+OIL、RDF(S)、OWL和OWL2等。", "relation": [{"head": "知识表示语言", "head_type": "知识融合", "relation": "包含", "tail": "Ontolingua", "tail_type": "知识融合"}, {"head": "知识表示语言", "head_type": "知识融合", "relation": "包含", "tail": "Loom", "tail_type": "知识融合"}, {"head": "知识表示语言", "head_type": "知识融合", "relation": "包含", "tail": "DAML+OIL", "tail_type": "知识融合"}, {"head": "知识表示语言", "head_type": "知识融合", "relation": "包含", "tail": "RDF(S)", "tail_type": "知识融合"}, {"head": "知识表示语言", "head_type": "知识融合", "relation": "包含", "tail": "OWL", "tail_type": "知识融合"}, {"head": "知识表示语言", "head_type": "知识融合", "relation": "包含", "tail": "OWL2", "tail_type": "知识融合"}]}
{"text": "这类语言层次上不匹配的情形分为语法不匹配、逻辑表示不匹配、原语的语义不匹配和语言表达能力不匹配四类。", "relation": [{"head": "语言层不匹配", "head_type": "知识融合", "relation": "包含", "tail": "语法不匹配", "tail_type": "知识融合"}, {"head": "语言层不匹配", "head_type": "知识融合", "relation": "包含", "tail": "逻辑表示不匹配", "tail_type": "知识融合"}, {"head": "语言层不匹配", "head_type": "知识融合", "relation": "包含", "tail": "原语的语义不匹配", "tail_type": "知识融合"}, {"head": "语言层不匹配", "head_type": "知识融合", "relation": "包含", "tail": "语言表达能力不匹配", "tail_type": "知识融合"}]}
{"text": "1.语法不匹配不同的知识描述语言常采用不同的语法。", "relation": [{"head": "语法不匹配", "head_type": "知识融合", "relation": "被定义为", "tail": "不同的语法", "tail_type": "文本"}]}
{"text": "因此，尽量将不同的语言转化为同样的语法格式能方便解决其他本体不匹配问题。", "relation": [{"head": "语法不匹配", "head_type": "知识融合", "relation": "方法", "tail": "将不同的语言转化为同样的语法格式", "tail_type": "文本"}]}
{"text": "2.逻辑表示不匹配不同语言的逻辑表示也可能存在着不匹配。这就是说，不同的语言可能采用不同的形式来表示逻辑意义上的等价结果。", "relation": [{"head": "逻辑表示不匹配", "head_type": "知识融合", "relation": "被定义为", "tail": "不同语言的逻辑表示，不同的语言可能采用不同的形式来表示逻辑意义上的等价结果", "tail_type": "文本"}]}
{"text": "相对而言，这类不匹配也容易解决，例如，通过定义从语言L1逻辑表示到语言L2的逻辑表示的转换规则。", "relation": [{"head": "逻辑表示不匹配", "head_type": "知识融合", "relation": "方法", "tail": "定义从语言L1逻辑表示到语言L2的逻辑表示的转换规则", "tail_type": "文本"}]}
{"text": "3.原语的语义不匹配在语言层的另一个不匹配是语言原语的语义。", "relation": [{"head": "原语的语义不匹配", "head_type": "知识融合", "relation": "被定义为", "tail": "语言原语的语义", "tail_type": "文本"}]}
{"text": "4.语言表达能力不匹配最后一种语言层的不匹配是指不同本体语言表达能力上的差异。", "relation": [{"head": "语言表达能力不匹配", "head_type": "知识融合", "relation": "被定义为", "tail": "不同本体语言表达能力上的差异", "tail_type": "文本"}]}
{"text": "一般来说，当本体语言的表达能力不同时，为了方便解决本体之间的异构，需要将表达能力弱的语言向表达能力强的语言转换；但是，如果表达能力强的语言并不完全兼容表达能力弱的语言，这样的转换可能会造成信息的损失。", "relation": [{"head": "语言表达能力不匹配", "head_type": "知识融合", "relation": "方法", "tail": "将表达能力弱的语言向表达能力强的语言转换", "tail_type": "文本"}]}
{"text": "Visser_P_R_S等人将本体模型层上的不匹配区分为概念化不匹配和解释不匹配两种情况[3]。", "relation": [{"head": "模型层不匹配", "head_type": "知识融合", "relation": "包含", "tail": "概念化不匹配", "tail_type": "知识融合"}, {"head": "本体模型层上的不匹配", "head_type": "知识融合", "relation": "包含", "tail": "解释不匹配", "tail_type": "知识融合"}]}
{"text": "概念化不匹配是由于对同样的建模领域进行抽象的方式不同造成的；解释不匹配则是由于对概念化说明的方式不同造成的，这包括概念定义和使用术语上的不匹配。", "relation": [{"head": "概念化不匹配", "head_type": "知识融合", "relation": "被定义为", "tail": "对同样的建模领域进行抽象的方式不同", "tail_type": "文本"}, {"head": "解释不匹配", "head_type": "知识融合", "relation": "被定义为", "tail": "对概念化说明的方式不同", "tail_type": "文本"}]}
{"text": "1.概念化不匹配概念化不匹配又可分为概念范围的不匹配和模型覆盖的不匹配两类。", "relation": [{"head": "概念化不匹配", "head_type": "知识融合", "relation": "包含", "tail": "概念范围的不匹配", "tail_type": "知识融合"}, {"head": "概念化不匹配", "head_type": "知识融合", "relation": "包含", "tail": "模型覆盖的不匹配", "tail_type": "知识融合"}]}
{"text": "（1）概念范围的不匹配。同样名称的概念在不同的领域内表示的含义往往有差异；同时，不同的建模者出于对领域需求或主观认识上的不同，在建模过程中对概念的划分往往也有差异，这些都统称为概念范围的不匹配。", "relation": [{"head": "概念范围的不匹配", "head_type": "知识融合", "relation": "被定义为", "tail": "同样名称的概念在不同的领域内表示的含义往往有差异；同时，不同的建模者出于对领域需求或主观认识上的不同，在建模过程中对概念的划分往往也有差异", "tail_type": "文本"}]}
{"text": "（2）模型覆盖的不匹配。不同本体对于描述的领域往往在覆盖的知识范围上有差异，而且对于所覆盖的范围，它们之间描述的详细程度也有差异，这就是模型覆盖的不匹配。", "relation": [{"head": "模型覆盖的不匹配", "head_type": "知识融合", "relation": "被定义为", "tail": "描述的领域在覆盖的知识范围上有差异，而且对于所覆盖的范围，它们之间描述的详细程度也有差异", "tail_type": "文本"}]}
{"text": "一般来说，有三种不同维度的模型覆盖。①模型的广度，即本体模型描述的领域范围，也就是哪些领域内的事物是包含在本体内的，哪些领域内的事物不是当前本体所关心的。", "relation": [{"head": "模型覆盖", "head_type": "知识融合", "relation": "包含", "tail": "模型的广度", "tail_type": "知识融合"}, {"head": "模型的广度", "head_type": "知识融合", "relation": "被定义为", "tail": "本体模型描述的领域范围，哪些领域内的事物是包含在本体内的，哪些领域内的事物不是当前本体所关心的。", "tail_type": "文本"}]}
{"text": "一般来说，有三种不同维度的模型覆盖。②模型的粒度，即本体对所建模的领域进行描述的详细程度，如有的本体仅仅列出概念，有的本体则进一步列出概念的属性，甚至概念之间所具有的各种关系等。", "relation": [{"head": "模型覆盖", "head_type": "知识融合", "relation": "包含", "tail": "本体的粒度", "tail_type": "知识融合"}, {"head": "模型的粒度", "head_type": "知识融合", "relation": "被定义为", "tail": "本体对所建模的领域进行描述的详细程度", "tail_type": "文本"}]}
{"text": "一般来说，有三种不同维度的模型覆盖。③本体建模的观点，这决定了本体从什么认识角度来描述领域内的知识。", "relation": [{"head": "模型覆盖", "head_type": "知识融合", "relation": "包含", "tail": "本体建模的观点", "tail_type": "知识融合"}, {"head": "本体建模的观点", "head_type": "知识融合", "relation": "被定义为", "tail": "从什么认识角度来描述领域内的知识", "tail_type": "文本"}]}
{"text": "2.解释不匹配本体模型层上的另一类不匹配现象是解释不匹配，它又包含了模型风格的不匹配和建模术语上的不匹配。", "relation": [{"head": "解释不匹配", "head_type": "知识融合", "relation": "包含", "tail": "模型风格不匹配", "tail_type": "知识融合"}, {"head": "解释不匹配", "head_type": "知识融合", "relation": "包含", "tail": "建模术语不匹配", "tail_type": "知识融合"}]}
{"text": "（1）模型风格的不匹配①范例不匹配。不同的范例可用来表示相同的概念，这也就出现了不匹配。", "relation": [{"head": "模型风格不匹配", "head_type": "知识融合", "relation": "包含", "tail": "范例不匹配", "tail_type": "知识融合"}, {"head": "范例不匹配", "head_type": "知识融合", "relation": "被定义为", "tail": "不同的范例可用来表示相同的概念，这也就出现了不匹配。", "tail_type": "文本"}]}
{"text": "（1）模型风格的不匹配②概念描述不匹配。在本体建模中，对同一个概念的建模可以有几种选择。", "relation": [{"head": "模型风格不匹配", "head_type": "知识融合", "relation": "包含", "tail": "概念描述不匹配", "tail_type": "知识融合"}, {"head": "概念描述不匹配", "head_type": "知识融合", "relation": "被定义为", "tail": "对同一个概念的建模可以选择", "tail_type": "文本"}]}
{"text": "（2）建模术语上的不匹配①同义术语。不同本体中含义上相同的概念常常由于建模者的习惯而被使用不同的名字表示。", "relation": [{"head": "建模术语不匹配", "head_type": "知识融合", "relation": "包含", "tail": "同义术语", "tail_type": "知识融合"}, {"head": "同义术语", "head_type": "知识融合", "relation": "被定义为", "tail": "不同本体中含义上相同的概念常常由于建模者的习惯而被使用不同的名字表示", "tail_type": "文本"}]}
{"text": "（2）建模术语上的不匹配②同形异义术语。", "relation": [{"head": "建模术语不匹配", "head_type": "知识融合", "relation": "包含", "tail": "同形异义术语", "tail_type": "知识融合"}]}
{"text": "（2）建模术语上的不匹配③编码格式。最后的一种不匹配是由于本体表示中采用不同的编码格式造成的。", "relation": [{"head": "建模术语不匹配", "head_type": "知识融合", "relation": "包含", "tail": "编码格式", "tail_type": "知识融合"}, {"head": "编码格式", "head_type": "知识融合", "relation": "被定义为", "tail": "不同编码格式造成的匹配", "tail_type": "文本"}]}
{"text": "5.3本体概念层的融合方法与技术5.3.1本体映射与本体集成解决本体异构的通用方法是本体集成与本体映射[6-9]。", "relation": [{"head": "解决本体异构方法", "head_type": "知识融合", "relation": "包含", "tail": "本体集成", "tail_type": "知识融合"}, {"head": "解决本体异构方法", "head_type": "知识融合", "relation": "包含", "tail": "本体映射", "tail_type": "知识融合"}]}
{"text": "本体集成直接将多个本体合并为一个大本体，本体映射则寻找本体间的映射规则，这两种方法最终都是为了消除本体异构，达到异构本体间的互操作。", "relation": [{"head": "本体集成", "head_type": "知识融合", "relation": "被定义为", "tail": "将多个本体合并为一个大本体", "tail_type": "文本"}, {"head": "本体映射", "head_type": "知识融合", "relation": "被定义为", "tail": "寻找本体间的映射规则", "tail_type": "文本"}]}
{"text": "对于本体集成，根据实施过程的不同，又可以将其分为单本体的集成和全局本体-局部本体的集成两种形式。", "relation": [{"head": "本体集成", "head_type": "知识融合", "relation": "包含", "tail": "单本体的集成", "tail_type": "知识融合"}, {"head": "本体集成", "head_type": "知识融合", "relation": "包含", "tail": "全局本体-局部本体的集成", "tail_type": "知识融合"}]}
{"text": "1.基于单本体的集成这种本体集成方法是直接将多个异构本体集成为一个统一的本体，该本体提供统一的语义规范和共享词汇。", "relation": [{"head": "单本体的集成", "head_type": "知识融合", "relation": "被定义为", "tail": "直接将多个异构本体集成为一个统一的本体，该本体提供统一的语义规范和共享词汇", "tail_type": "文本"}]}
{"text": "这样的集成方法虽然看起来很有效，但在实际应用中往往存在明显的缺点。所以，从这些方面能看出单本体的集成缺乏灵活性。", "relation": [{"head": "单本体的集成", "head_type": "知识融合", "relation": "缺点", "tail": "缺乏灵活性", "tail_type": "文本"}]}
{"text": "2.基于全局本体-局部本体的集成为了克服单本体的本体集成方法的缺陷，另一种途径是采用全局本体-局部本体来达到本体集成。这种方法首先抽取异构本体之间的共同知识，根据它建立一个全局本体。全局本体述了不同系统之间一致认可的知识。同时，各个系统可以拥有自己的本体，称为局部本体。", "relation": [{"head": "基于全局本体-局部本体的集成", "head_type": "知识融合", "relation": "被定义为", "tail": "首先抽取异构本体之间的共同知识，根据它建立一个全局本体，同时，各个系统可以拥有自己的本体", "tail_type": "文本"}]}
{"text": "这种方法既避免了局部本体存在过多的冗余，本体规模不会过于庞大，同时也达到了解决本体间异构的目的。", "relation": [{"head": "基于全局本体-局部本体的集成", "head_type": "知识融合", "relation": "优点", "tail": "避免局部本体存在过多的冗余，本体规模不会过于庞大，同时也达到了解决本体间异构的目的", "tail_type": "文本"}]}
{"text": "然而，集成本体的工作耗时费力，而且缺乏自动方法支持；随着多本体的变化，集成过程需要不断地重复进行，代价过高。此外，集成的本体对于不同的应用不具有通用性， 缺乏灵活性。", "relation": [{"head": "本体集成", "head_type": "知识融合", "relation": "缺点", "tail": "工作耗时费力，而且缺乏自动方法支持；随着多本体的变化，集成过程需要不断地重复进行，代价过高；不具有通用性， 缺乏灵活性", "tail_type": "文本"}]}
{"text": "5.3.2本体映射分类明确本体映射的分类是建立异构本体间映射的基础。", "relation": [{"head": "本体映射", "head_type": "知识融合", "relation": "作用", "tail": "建立异构本体间映射的基础", "tail_type": "文本"}]}
{"text": "这里在总结前人研究的基础上，从三个角度来探讨本体映射的分类问题，即映射的对象、映射的功能以及映射的复杂程度。", "relation": [{"head": "本体映射分类", "head_type": "知识融合", "relation": "包含", "tail": "映射的对象", "tail_type": "知识融合"}, {"head": "本体映射分类", "head_type": "知识融合", "relation": "包含", "tail": "映射的功能", "tail_type": "知识融合"}, {"head": "本体映射分类", "head_type": "知识融合", "relation": "包含", "tail": "映射的复杂程度", "tail_type": "知识融合"}]}
{"text": "1.映射的对象角度通过这个角度的分类，明确映射应该建立在异构本体的哪些成分之间。", "relation": [{"head": "映射的对象", "head_type": "知识融合", "relation": "被定义为", "tail": "明确映射应该建立在异构本体的哪些成分之间。", "tail_type": "文本"}]}
{"text": "综上所述，从映射的对象来看，可将本体映射分为概念之间的映射和关系之间的映射两类，其中概念之间的映射是最基本的映射。", "relation": [{"head": "映射的对象中本体映射", "head_type": "知识融合", "relation": "包含", "tail": "概念之间的映射", "tail_type": "知识融合"}, {"head": "映射的对象中本体映射", "head_type": "知识融合", "relation": "包含", "tail": "关系之间的映射", "tail_type": "知识融合"}]}
{"text": "2.映射的功能角度通过这个角度的分类，进一步明确应该建立具有何种功能的本体映射。", "relation": [{"head": "映射的功能", "head_type": "知识融合", "relation": "被定义为", "tail": "明确应该建立具有何种功能的本体映射。", "tail_type": "文本"}]}
{"text": "映射的功能最基本的映射功能是等价映射，是为了建立不同本体的成分之间的等价关系。", "relation": [{"head": "映射的功能", "head_type": "知识融合", "relation": "包含", "tail": "等价映射", "tail_type": "知识融合"}, {"head": "等价映射", "head_type": "知识融合", "relation": "被定义为", "tail": "建立不同本体的成分之间的等价关系", "tail_type": "文本"}]}
{"text": "映射的功能中同形异义的映射能够指出表示名称相同的本体成分实际上含义是不同的。", "relation": [{"head": "映射的功能", "head_type": "知识融合", "relation": "包含", "tail": "同形异义的映射", "tail_type": "知识融合"}, {"head": "同形异义的映射", "head_type": "知识融合", "relation": "被定义为", "tail": "指出表示名称相同的本体成分实际上含义是不同的", "tail_type": "文本"}]}
{"text": "映射的功能中上义和下义映射则说明了概念之间和属性之间的继承关系，关系间的包含映射对于关系来说也具有同样的功能。", "relation": [{"head": "映射的功能", "head_type": "知识融合", "relation": "包含", "tail": "上义和下义映射", "tail_type": "知识融合"}]}
{"text": "上义和下义映射则说明了概念之间和属性之间的继承关系，关系间的包含映射对于关系来说也具有同样的功能。", "relation": [{"head": "上义和下义映射", "head_type": "知识融合", "relation": "被定义为", "tail": "概念之间和属性之间的继承关系", "tail_type": "文本"}]}
{"text": "映射的功能中重叠映射表示概念之间的相似性。", "relation": [{"head": "映射的功能", "head_type": "知识融合", "relation": "包含", "tail": "重叠映射", "tail_type": "知识融合"}, {"head": "重叠映射", "head_type": "知识融合", "relation": "被定义为", "tail": "概念之间的相似性", "tail_type": "文本"}]}
{"text": "映射的功能中对立映射表示概念之间的对立。", "relation": [{"head": "映射的功能", "head_type": "知识融合", "relation": "包含", "tail": "对立映射", "tail_type": "知识融合"}, {"head": "对立映射", "head_type": "知识融合", "relation": "被定义为", "tail": "概念之间的对立", "tail_type": "文本"}]}
{"text": "同样，映射的功能中逆映射表示关系之间的互逆。", "relation": [{"head": "映射的功能", "head_type": "知识融合", "relation": "包含", "tail": "逆映射", "tail_type": "知识融合"}, {"head": "逆映射", "head_type": "知识融合", "relation": "被定义为", "tail": "关系之间的互逆", "tail_type": "文本"}]}
{"text": "映射的功能中概念上的部分映射则表示了来自不同概念间的个体具有整体—部分关系。", "relation": [{"head": "映射的功能", "head_type": "知识融合", "relation": "包含", "tail": "部分映射", "tail_type": "知识融合"}, {"head": "部分映射", "head_type": "知识融合", "relation": "被定义为", "tail": "来自不同概念间的个体具有整体—部分关系", "tail_type": "文本"}]}
{"text": "3.映射的复杂程度角度通过这个角度的分类，明确什么形式的映射是简单的，什么形式的映射是复杂的。", "relation": [{"head": "映射的复杂程度", "head_type": "知识融合", "relation": "被定义为", "tail": "通过这个角度的分类，明确什么形式的映射是简单的，什么形式的映射是复杂的。", "tail_type": "文本"}]}
{"text": "本体间的映射还具有复杂和简单之分，这需要同时考虑映射涉及的对象和映射具有的功能。", "relation": [{"head": "映射的复杂程度", "head_type": "知识融合", "relation": "包含", "tail": "复杂映射", "tail_type": "知识融合"}, {"head": "映射的复杂程度", "head_type": "知识融合", "relation": "包含", "tail": "简单映射", "tail_type": "知识融合"}]}
{"text": "通常，将那些基本的、必要的、组成简单的和发现过程相对容易的映射称作简单映射；将那些不直观的、组成复杂并且发现过程相对困难的映射称为复杂映射。", "relation": [{"head": "简单映射", "head_type": "知识融合", "relation": "被定义为", "tail": "基本的、必要的、组成简单的和发现过程相对容易的映射", "tail_type": "文本"}, {"head": "复杂映射", "head_type": "知识融合", "relation": "被定义为", "tail": "不直观的、组成复杂并且发现过程相对困难的映射", "tail_type": "文本"}]}
{"text": "总的来说，本体映射的过程可分为三步：①导入待映射的本体。待映射的本体不一定都要转换为统一的本体语言格式，但是要保证本体中需要进行映射的成分能够被方便获取。", "relation": [{"head": "本体映射过程", "head_type": "知识融合", "relation": "包含", "tail": "导入待映射的本体", "tail_type": "知识融合"}, {"head": "导入待映射的本体", "head_type": "知识融合", "relation": "内容", "tail": "保证本体中需要进行映射的成分能够被方便获取", "tail_type": "文本"}]}
{"text": "总的来说，本体映射的过程可分为三步：②发现映射。利用一定的算法，如计算概念间的相似度等，寻找异构本体间的联系，然后根据这些联系建立异构本体间的映射规则。", "relation": [{"head": "本体映射过程", "head_type": "知识融合", "relation": "包含", "tail": "发现映射", "tail_type": "知识融合"}, {"head": "发现映射", "head_type": "知识融合", "relation": "内容", "tail": "寻找异构本体间的联系，然后根据这些联系建立异构本体间的映射规则。", "tail_type": "文本"}]}
{"text": "总的来说，本体映射的过程可分为三步：③表示映射。在发现映射后，需要根据映射的类型，借助工具将发现的映射合理表示和组织。", "relation": [{"head": "本体映射过程", "head_type": "知识融合", "relation": "包含", "tail": "表示映射", "tail_type": "知识融合"}, {"head": "表示映射", "head_type": "知识融合", "relation": "内容", "tail": "借助工具将发现的映射合理表示和组织", "tail_type": "文本"}]}
{"text": "从已有的映射方法以及相关的工具来看，发现本体映射的方法可分为四种[19,20]:①基于术语的方法，即借助自然语言处理技术，比较映射对象之间的相似度，以发现异构本体间的联系；②基于结构的方法，即分析异构本体之间结构上的相似，寻找可能的映射规则；③基于实例的方法，即借助本体中的实例，利用机器学习等技术寻找本体间的映射；④综合方法，即在一个映射发现系统中同时采用多种寻找本体映射的方法，一方面能弥补不同方法的不足，另一方面还能提高映射结果的质量。", "relation": [{"head": "本体映射方法", "head_type": "知识融合", "relation": "包含", "tail": "基于术语的方法 ", "tail_type": "知识融合"}]}
{"text": "从已有的映射方法以及相关的工具来看，发现本体映射的方法可分为四种[19,21]:①基于术语的方法，即借助自然语言处理技术，比较映射对象之间的相似度，以发现异构本体间的联系；②基于结构的方法，即分析异构本体之间结构上的相似，寻找可能的映射规则；③基于实例的方法，即借助本体中的实例，利用机器学习等技术寻找本体间的映射；④综合方法，即在一个映射发现系统中同时采用多种寻找本体映射的方法，一方面能弥补不同方法的不足，另一方面还能提高映射结果的质量。", "relation": [{"head": "本体映射方法", "head_type": "知识融合", "relation": "包含", "tail": "基于结构的方法", "tail_type": "知识融合"}]}
{"text": "从已有的映射方法以及相关的工具来看，发现本体映射的方法可分为四种[19,22]:①基于术语的方法，即借助自然语言处理技术，比较映射对象之间的相似度，以发现异构本体间的联系；②基于结构的方法，即分析异构本体之间结构上的相似，寻找可能的映射规则；③基于实例的方法，即借助本体中的实例，利用机器学习等技术寻找本体间的映射；④综合方法，即在一个映射发现系统中同时采用多种寻找本体映射的方法，一方面能弥补不同方法的不足，另一方面还能提高映射结果的质量。", "relation": [{"head": "本体映射方法", "head_type": "知识融合", "relation": "包含", "tail": "基于实例的方法", "tail_type": "知识融合"}]}
{"text": "从已有的映射方法以及相关的工具来看，发现本体映射的方法可分为四种[19,23]:①基于术语的方法，即借助自然语言处理技术，比较映射对象之间的相似度，以发现异构本体间的联系；②基于结构的方法，即分析异构本体之间结构上的相似，寻找可能的映射规则；③基于实例的方法，即借助本体中的实例，利用机器学习等技术寻找本体间的映射；④综合方法，即在一个映射发现系统中同时采用多种寻找本体映射的方法，一方面能弥补不同方法的不足，另一方面还能提高映射结果的质量。", "relation": [{"head": "本体映射方法", "head_type": "知识融合", "relation": "包含", "tail": "综合方法", "tail_type": "知识融合"}, {"head": "基于术语的方法 ", "head_type": "知识融合", "relation": "被定义为", "tail": "借助自然语言处理技术，比较映射对象之间的相似度，以发现异构本体间的联系", "tail_type": "文本"}, {"head": "基于结构的方法", "head_type": "知识融合", "relation": "被定义为", "tail": "分析异构本体之间结构上的相似，寻找可能的映射规则", "tail_type": "文本"}, {"head": "基于实例的方法", "head_type": "知识融合", "relation": "被定义为", "tail": "借助本体中的实例，利用机器学习等技术寻找本体间的映", "tail_type": "文本"}, {"head": "综合方法", "head_type": "知识融合", "relation": "被定义为", "tail": "在一个映射发现系统中同时采用多种寻找本体映射的方法", "tail_type": "文本"}]}
{"text": "6.2节和6.3节主要介绍知识图谱中两种最重要的推理，即基于演绎的知识图谱推理和基于归纳的知识图谱推理，并分别介绍常用的方法和思路，同时对典型的实验工具以及实验结果进行分析和展示。", "relation": [{"head": "知识图谱推理", "head_type": "知识推理", "relation": "包含", "tail": "基于演绎的知识图谱推理", "tail_type": "知识推理"}, {"head": "知识图谱推理", "head_type": "知识推理", "relation": "包含", "tail": "基于归纳的知识图谱推理", "tail_type": "知识推理"}]}
{"text": "6.1推理概述6.1.1什么是推理推理在人类长期的社会发展和演变中扮演着重要的角色，包含了思考、认知和理解，是认知世界的重要途径。", "relation": [{"head": "推理", "head_type": "知识推理", "relation": "包含", "tail": "思考", "tail_type": "知识推理"}, {"head": "推理", "head_type": "知识推理", "relation": "包含", "tail": "认知", "tail_type": "知识推理"}, {"head": "推理", "head_type": "知识推理", "relation": "包含", "tail": "理解", "tail_type": "知识推理"}]}
{"text": "具体来说，推理是通过已有知识推断出未知知识的过程。", "relation": [{"head": "推理", "head_type": "知识推理", "relation": "被定义为", "tail": "已有知识推断出未知知识的过程", "tail_type": "文本"}]}
{"text": "推理的方法大致可以分为逻辑推理和非逻辑推理，其中逻辑推理的过程包含了严格的约束和推理过程，而非逻辑推理的过程相对模糊。", "relation": [{"head": "推理", "head_type": "知识推理", "relation": "包含", "tail": "逻辑推理", "tail_type": "知识推理"}, {"head": "推理", "head_type": "知识推理", "relation": "包含", "tail": "非逻辑推理", "tail_type": "知识推理"}]}
{"text": "逻辑推理按照推理方式的不同包含两大类：演绎推理（Deductive_Reasoning）和归纳推理（Inductive_Reasoning）。", "relation": [{"head": "逻辑推理", "head_type": "知识推理", "relation": "包含", "tail": "演绎推理", "tail_type": "知识推理"}, {"head": "逻辑推理", "head_type": "知识推理", "relation": "包含", "tail": "归纳推理", "tail_type": "知识推理"}, {"head": "演绎推理", "head_type": "知识推理", "relation": "英文名", "tail": "Deductive_Reasoning", "tail_type": "文本"}, {"head": "归纳推理", "head_type": "知识推理", "relation": "英文名", "tail": "Inductive_Reasoning", "tail_type": "文本"}]}
{"text": "其中，归纳推理又包含了溯因推理（Abductive_Reasoning）和类比推理（Analogy_Reasoning）等。", "relation": [{"head": "溯因推理", "head_type": "知识推理", "relation": "英文名", "tail": "Abductive_Reasoning", "tail_type": "文本"}, {"head": "归纳推理", "head_type": "知识推理", "relation": "包含", "tail": "溯因推理", "tail_type": "知识推理"}, {"head": "归纳推理", "head_type": "知识推理", "relation": "包含", "tail": "类比推理", "tail_type": "知识推理"}]}
{"text": "演绎推理[1]是一种自上而下（top-down_logic）的逻辑推理，是指在给定的一个或多个前提的情况下，推断出一个必然成立的结论的过程。", "relation": [{"head": "演绎推理", "head_type": "知识推理", "relation": "属于", "tail": "自上而下（top-down_logic）的逻辑推理", "tail_type": "知识推理"}]}
{"text": "典型的演绎推理有肯定前件假言推理、否定后件假言推理（Modus_Tollens）以及三段论（Law_of_Syllogism）。", "relation": [{"head": "肯定前件假言推理", "head_type": "知识推理", "relation": "属于", "tail": "演绎推理", "tail_type": "知识推理"}, {"head": "否定后件假言推理", "head_type": "知识推理", "relation": "属于", "tail": "演绎推理", "tail_type": "知识推理"}, {"head": "三段论", "head_type": "知识推理", "relation": "属于", "tail": "演绎推理", "tail_type": "知识推理"}, {"head": "三段论", "head_type": "知识推理", "relation": "英文名", "tail": "Law_of_Syllogism", "tail_type": "文本"}]}
{"text": "从以上的例子可以看出，演绎推理是一种形式化的逻辑推理。", "relation": [{"head": "演绎推理", "head_type": "知识推理", "relation": "属于", "tail": "形式化的逻辑推理", "tail_type": "知识推理"}]}
{"text": "归纳推理[2]是一种自下而上的推理，是指基于已有的部分观察得出一般结论的过程。", "relation": [{"head": "归纳推理", "head_type": "知识推理", "relation": "属于", "tail": "自下而上的推理", "tail_type": "知识推理"}]}
{"text": "典型的归纳推理有归纳泛化（Inductive_Generalization）、统计推理（StatisticalSyllogism）。", "relation": [{"head": "归纳泛化", "head_type": "知识推理", "relation": "属于", "tail": "归纳推理", "tail_type": "知识推理"}, {"head": "归纳泛化", "head_type": "知识推理", "relation": "英文名", "tail": "Inductive_Generalization", "tail_type": "文本"}, {"head": "统计推理", "head_type": "知识推理", "relation": "英文名", "tail": "StatisticalSyllogism", "tail_type": "文本"}]}
{"text": "归纳泛化是指基于对个体的观察而得出可能适用于整体的结论，即在整体的一些样本中得到的结论可以泛化到整体上。", "relation": [{"head": "归纳泛化", "head_type": "知识推理", "relation": "被定义为", "tail": "基于对个体的观察而得出可能适用于整体的结论", "tail_type": "文本"}]}
{"text": "而统计推理是将整体的统计结论应用于个体。", "relation": [{"head": "统计推理", "head_type": "知识推理", "relation": "被定义为", "tail": "将整体的统计结论应用于个体", "tail_type": "文本"}]}
{"text": "归纳推理是一种非形式化的推理，是由具体到一般的推理过程。", "relation": [{"head": "归纳推理", "head_type": "知识推理", "relation": "属于", "tail": "非形式化的推理", "tail_type": "知识推理"}]}
{"text": "但在演绎推理中，如果前提均为真，那么一定可以推理得到结论也为真。", "relation": [{"head": "演绎推理", "head_type": "知识推理", "relation": "特点", "tail": "前提均为真，一定可以推理得到结论也为真", "tail_type": "文本"}]}
{"text": "溯因推理[3]也是一种逻辑推理，是在给定一个或多个已有观察事实O（Observation），并根据已有的知识T（Theory）推断出对已有观察最简单且最有可能的解释的过程。", "relation": [{"head": "溯因推理", "head_type": "知识推理", "relation": "属于", "tail": "逻辑推理", "tail_type": "知识推理"}]}
{"text": "溯因推理是归纳推理的一种，因为整个推理过程的前提和结论并没有必然的关系。", "relation": [{"head": "溯因推理", "head_type": "知识推理", "relation": "属于", "tail": "归纳推理", "tail_type": "知识推理"}]}
{"text": "类比推理[4]可以看作只基于对一个事物的观察而进行的对另一个事物的归纳推理，是通过寻找两者之间可以类比的信息，将已知事物上的结论迁移到新的事物上的过程。", "relation": [{"head": "类比推理", "head_type": "知识推理", "relation": "等价", "tail": "只基于对一个事物的观察而进行的对另一个事物的归纳推理", "tail_type": "知识推理"}, {"head": "类比推理", "head_type": "知识推理", "relation": "被定义为", "tail": "通过寻找两者之间可以类比的信息，将已知事物上的结论迁移到新的事物上的过程", "tail_type": "文本"}]}
{"text": "从推理过程精确性来看，又可分为精确推理和模糊推理。", "relation": [{"head": "推理过程", "head_type": "知识推理", "relation": "包含", "tail": "精确推理", "tail_type": "知识推理"}, {"head": "推理过程", "head_type": "知识推理", "relation": "包含", "tail": "模糊推理", "tail_type": "知识推理"}]}
{"text": "在计算机视觉领域也有视觉推理（Visual_Reasoning），一般任务为根据给定的图片回答特定的需要推理的问题。", "relation": [{"head": "视觉推理", "head_type": "知识推理", "relation": "英文名", "tail": "Visual_Reasoning", "tail_type": "文本"}]}
{"text": "具体来说，知识图谱推理主要能够辅助推理出新的事实、新的关系、新的公理以及新的规则等。", "relation": [{"head": "知识图谱推理", "head_type": "知识推理", "relation": "特点", "tail": "辅助推理出新的事实、新的关系、新的公理以及新的规则等", "tail_type": "文本"}]}
{"text": "知识图谱中的三元组可以通过人工定义得到，也可以通过文本抽取得到。", "relation": [{"head": "知识图谱中的三元组", "head_type": "知识推理", "relation": "来源", "tail": "人工定义得到", "tail_type": "知识推理"}]}
{"text": "由于人工知识的局限性以及算法的不确定性，一个知识图谱中不可避免地会存在冲突的信息，所以不一致性检测也是知识图谱中重要的推理任务，即检测知识图谱中有冲突或不正确的事实。", "relation": [{"head": "不一致性检测", "head_type": "知识推理", "relation": "作用", "tail": "知识图谱中重要的推理任务", "tail_type": "文本"}]}
{"text": "存储了众多知识的知识图谱的一个重要作用是提供知识服务，为相关的查询返回正确的相关知识信息，但查询的模糊以及知识图谱本身的语义丰富性容易造成查询困难，而推理有利于查询重写，有效地提升查询结果的质量。", "relation": [{"head": "知识图谱", "head_type": "知识推理", "relation": "作用", "tail": "知识服务", "tail_type": "文本"}]}
{"text": "知识图谱的推理的主要技术手段主要可以分为两大类：基于演绎的知识图谱推理，如基于描述逻辑[9]、Datalog、产生式规则等；基于归纳的知识图谱推理，如图6-1所示的路径推理[10]、表示学习[11]、规则学习[12]、基于强化学习的推理[13]等。", "relation": [{"head": "知识图谱推理", "head_type": "知识推理", "relation": "包含", "tail": "基于演绎的知识图谱推理", "tail_type": "知识推理"}, {"head": "知识图谱推理", "head_type": "知识推理", "relation": "包含", "tail": "基于归纳的知识图谱推理", "tail_type": "知识推理"}]}
{"text": "本体的一般定义为概念化的显示规约，它给不同的领域提供共享的词汇。", "relation": [{"head": "本体", "head_type": "知识推理", "relation": "被定义为", "tail": "概念化的显示规约", "tail_type": "文本"}]}
{"text": "因为共享的词汇需要赋予一定的语义，所以基于演绎的推理一般都在具有逻辑描述基础的知识图谱上展开。", "relation": [{"head": "基于演绎的推理", "head_type": "知识推理", "relation": "特点", "tail": "知识图谱上展开", "tail_type": "文本"}]}
{"text": "OWL按表达能力从低到高划分成OWL_Lite、OWL_DL和OWL_Full。", "relation": [{"head": "OWL", "head_type": "知识推理", "relation": "包含", "tail": "OWL_Lite", "tail_type": "知识推理"}, {"head": "OWL", "head_type": "知识推理", "relation": "包含", "tail": "OWL_DL", "tail_type": "知识推理"}, {"head": "OWL", "head_type": "知识推理", "relation": "包含", "tail": "OWL_Full", "tail_type": "知识推理"}]}
{"text": "OWL_Lite和OWL_DL在语义上等价于某些描述逻辑（Description_Logics,DLs）[14,15]，而OWL_Full没有对应的描述逻辑。", "relation": [{"head": "OWL_Lite", "head_type": "知识推理", "relation": "等价", "tail": "描述逻辑", "tail_type": "知识推理"}, {"head": "OWL_DL", "head_type": "知识推理", "relation": "等价", "tail": "描述逻辑", "tail_type": "知识推理"}]}
{"text": "与OWL不同，OWL_2仅有对应的Full和DL层次。", "relation": [{"head": "OWL_2", "head_type": "知识推理", "relation": "特点", "tail": "Full和DL层次", "tail_type": "文本"}]}
{"text": "OWL_2_Full比OWL_Full的表达能力更强，同样没有对应的描述逻辑。", "relation": [{"head": "OWL_2_Full", "head_type": "知识推理", "relation": "特点", "tail": "OWL_Full的表达能力更强", "tail_type": "文本"}]}
{"text": "而OWL_2_DL比OWL_DL的表达能力更强，仍有对应的描述逻辑[16]。", "relation": [{"head": "OWL_2_DL", "head_type": "知识推理", "relation": "特点", "tail": "OWL_DL的表达能力更强", "tail_type": "文本"}]}
{"text": "目前，OWL是知识图谱语言中最规范、最严谨、表达能力最强的语言，而且OWL基于RDF语法，使表示出来的文档具有语义理解的结构基础，OWL的另外一个作用是促进了统一词汇表的使用，定义了丰富的语义词汇。", "relation": [{"head": "OWL", "head_type": "知识推理", "relation": "属于", "tail": "知识图谱语言", "tail_type": "知识推理"}]}
{"text": "判定给定知识库的TBox是否一致，需要判定TBox中的所有原子概念是否都满足。", "relation": [{"head": "判定给定知识库的TBox是否一致", "head_type": "知识推理", "relation": "内容", "tail": "判定TBox中的所有原子概念是否都满足", "tail_type": "文本"}]}
{"text": "2.基于Tableaux的本体推理方法基于表运算（Tableaux）的本体推理方法[20]是描述逻辑知识库一致性检测的最常用方法。", "relation": [{"head": "基于Tableaux的本体推理方法", "head_type": "知识推理", "relation": "来源", "tail": "基于表运算（Tableaux）的本体推理方法", "tail_type": "知识推理"}]}
{"text": "基于表运算的推理方法通过一系列规则构建Abox，以检测可满足性，或者检测某一实例是否存在某概念，基本思想类似于一阶逻辑的归结反驳。", "relation": [{"head": "基于表运算的推理方法", "head_type": "知识推理", "relation": "方法", "tail": "构建Abox", "tail_type": "文本"}]}
{"text": "表是表达知识库逻辑结论的一种结构化方法。", "relation": [{"head": "表", "head_type": "知识推理", "relation": "被定义为", "tail": "表达知识库逻辑结论的一种结构化方法", "tail_type": "文本"}]}
{"text": "FaCT++是曼彻斯特大学开发的描述逻辑推理机，使用C++实现，且能与Protégé集成。", "relation": [{"head": "FaCT++", "head_type": "知识推理", "relation": "属于", "tail": "描述逻辑推理机", "tail_type": "知识推理"}]}
{"text": "Racer是美国Franz_Inc.公司开发的以描述逻辑为基础的本体推理机，也可以用作语义知识库，支持OWL_DL，支持部分OWL_2_DL并且支持单机和客户端/服务器两种模式，用Allegro_Common_Lisp实现。", "relation": [{"head": "Racer", "head_type": "知识推理", "relation": "属于", "tail": "本体推理机", "tail_type": "知识推理"}, {"head": "Racer", "head_type": "知识推理", "relation": "属于", "tail": "语义知识库", "tail_type": "知识推理"}]}
{"text": "Pellet是马里兰大学开发的本体推理机，支持OWL_DL的所有特性，包括枚举类和XML数据类型的推理，并支持OWL_API以及Jena的接口。", "relation": [{"head": "Pellet", "head_type": "知识推理", "relation": "属于", "tail": "本体推理机", "tail_type": "知识推理"}]}
{"text": "HermiT是牛津大学开发的本体推理机，基于Hypertableaux运算，比其他推理机更加高效，支持OWL_2规则。", "relation": [{"head": "HermiT", "head_type": "知识推理", "relation": "属于", "tail": "本体推理机", "tail_type": "知识推理"}]}
{"text": "本体推理通常仅支持预定义的本体公理上的推理，而规则推理可以根据特定的场景定制规则，以实现用户自定义的推理过程。", "relation": [{"head": "本体推理", "head_type": "知识推理", "relation": "特点", "tail": "预定义的本体公理上的推理", "tail_type": "文本"}, {"head": "规则推理", "head_type": "知识推理", "relation": "特点", "tail": "根据特定的场景定制规则", "tail_type": "文本"}]}
{"text": "逻辑编程的研究始于Prolog语言[24,25]，后来由ISO标准化。", "relation": [{"head": "逻辑编程", "head_type": "知识推理", "relation": "来源", "tail": "Prolog语言", "tail_type": "知识推理"}]}
{"text": "在通常情况下，Prolog程序是通过SLD消解和回溯来执行的[25]。", "relation": [{"head": "Prolog程序", "head_type": "知识推理", "relation": "内容", "tail": "通过SLD消解和回溯来执行", "tail_type": "文本"}]}
{"text": "它们的主要区别是在语义层面，Datalog基于完全声明式的模型论的语义，并保证可终止性。", "relation": [{"head": "Datalog", "head_type": "知识推理", "relation": "特点", "tail": "基于完全声明式的模型论的语义，并保证可终止性", "tail_type": "文本"}]}
{"text": "2.Datalog语言Datalog语言是一种面向知识库和数据库设计的逻辑语言。", "relation": [{"head": "Datalog语言", "head_type": "知识推理", "relation": "属于", "tail": "面向知识库和数据库设计的逻辑语言", "tail_type": "知识推理"}]}
{"text": "规则的直观含义为：当体部原子都成真时，头部原子也应成真。", "relation": [{"head": "规则的直观含义", "head_type": "知识推理", "relation": "内容", "tail": "当体部原子都成真时，头部原子也应成真", "tail_type": "文本"}]}
{"text": "Datalog程序是规则的集合。", "relation": [{"head": "Datalog程序", "head_type": "知识推理", "relation": "被定义为", "tail": "规则的集合", "tail_type": "文本"}]}
{"text": "一个知识图谱可以自然地被看作一个事实集。", "relation": [{"head": "知识图谱", "head_type": "知识推理", "relation": "等价", "tail": "事实集", "tail_type": "知识推理"}]}
{"text": "SWRL是2004年提出的一个完全基于Datalog的规则语言。", "relation": [{"head": "SWRL", "head_type": "知识推理", "relation": "属于", "tail": "基于Datalog的规则语言", "tail_type": "知识推理"}]}
{"text": "OWL_RL是W3C定义的OWL_2的一个子语言，其设计目标为可以直接转换成Datalog程序，从而使用现有的Datalog推理机推理。", "relation": [{"head": "OWL_RL", "head_type": "知识推理", "relation": "属于", "tail": "W3C定义的OWL_2的一个子语言", "tail_type": "知识推理"}]}
{"text": "RDFS是W3C定义的一个基于RDF的轻量级的本体语言。", "relation": [{"head": "RDFS", "head_type": "知识推理", "relation": "属于", "tail": "基于RDF的轻量级的本体语言", "tail_type": "知识推理"}]}
{"text": "RDFS的表达能力大体是OWL_RL的一个子集。", "relation": [{"head": "RDFS的表达能力", "head_type": "知识推理", "relation": "属于", "tail": "OWL_RL的一个子集。", "tail_type": "知识推理"}]}
{"text": "RDFox的输入包括本体（TBox）、数据（ABox）和一个自定规则集。", "relation": [{"head": "RDFox的输入", "head_type": "知识推理", "relation": "内容", "tail": "本体、数据、自定规则集", "tail_type": "文本"}, {"head": "本体", "head_type": "知识推理", "relation": "英文名", "tail": "TBox", "tail_type": "文本"}, {"head": "数据", "head_type": "知识推理", "relation": "英文名", "tail": "ABox", "tail_type": "文本"}]}
{"text": "第一种情况直接在知识图谱之上的查询称为本体介导的查询回答（Ontology-MediatedQuery_Answering,OMQ）[27]。", "relation": [{"head": "本体介导的查询回答", "head_type": "知识推理", "relation": "英文名", "tail": "Ontology-MediatedQuery_Answering,OMQ", "tail_type": "文本"}]}
{"text": "第二种情况称为基于本体的数据访问（Ontology-Based_Data_Access,OBDA）[28,29]。", "relation": [{"head": "基于本体的数据访问", "head_type": "知识推理", "relation": "英文名", "tail": "Ontology-Based_Data_Access,OBDA", "tail_type": "文本"}]}
{"text": "1.OBDA框架OBDA框架包含外延（extensional）和内涵（intensional）两个部分。", "relation": [{"head": "OBDA框架", "head_type": "知识推理", "relation": "包含", "tail": "外延（extensional）", "tail_type": "知识推理"}, {"head": "OBDA框架", "head_type": "知识推理", "relation": "包含", "tail": "内涵（intensional）", "tail_type": "知识推理"}]}
{"text": "外延层为符合某个数据库架构（schema）S的一个源数据库D,S通常包括数据库表的定义和完整性约束。", "relation": [{"head": "外延层", "head_type": "知识推理", "relation": "特点", "tail": "符合某个数据库架构（schema）S的一个源数据库D", "tail_type": "文本"}]}
{"text": "内涵层为一个OBDA规范P=（T,M,S），其中T是本体，S是数据源模式，M是从S到T的映射。", "relation": [{"head": "内涵层", "head_type": "知识推理", "relation": "等价", "tail": "OBDA规范P", "tail_type": "知识推理"}]}
{"text": "OBDA的主要推理任务为查询。", "relation": [{"head": "OBDA的主要推理任务", "head_type": "知识推理", "relation": "内容", "tail": "查询", "tail_type": "文本"}]}
{"text": "OBDA有多种实现方式，最直接的方式是生成映射得到的知识图谱M(D)，然后保存到一个三元组存储库中，这种方式也称作ETL（Extract_Transform_Load)，优点是实现简单直接。", "relation": [{"head": "OBDA实现方式", "head_type": "知识推理", "relation": "方法", "tail": "生成映射得到的知识图谱M(D)然后保存到一个三元组存储库中这种方式也称作ETL（Extract_Transform_Load)优点是实现简单直接", "tail_type": "文本"}]}
{"text": "在此，我们更感兴趣的是虚拟OBDA的方式，此方式下的三元组并不需要被真正生成，而通过查询重写的方式来实现，OBDA将在本体层面的SPARQL查询重写为在原始数据库上的SQL查询。", "relation": [{"head": "虚拟OBDA", "head_type": "知识推理", "relation": "方法", "tail": "三元组并不需要被真正生成，而通过查询重写的方式来实现。", "tail_type": "文本"}]}
{"text": "4.相关工具介绍基于查询重写的推理机有多个，例如Ontop[12]Mastro[13]、Stardog[14]、Ultrawrap[15]、Morph[16]。", "relation": [{"head": "基于查询重写的推理机", "head_type": "知识推理", "relation": "包含", "tail": "Ontop", "tail_type": "知识推理"}, {"head": "基于查询重写的推理机", "head_type": "知识推理", "relation": "包含", "tail": "Mastro", "tail_type": "知识推理"}, {"head": "基于查询重写的推理机", "head_type": "知识推理", "relation": "包含", "tail": "Stardog", "tail_type": "知识推理"}, {"head": "基于查询重写的推理机", "head_type": "知识推理", "relation": "包含", "tail": "Ultrawrap", "tail_type": "知识推理"}, {"head": "基于查询重写的推理机", "head_type": "知识推理", "relation": "包含", "tail": "Morph", "tail_type": "知识推理"}]}
{"text": "Ontop兼容RDFS、OWL_2_QL、R2RML、SPARQL标准，并支持主流关系数据库，如Oracle、MySQL、SQL_Server、PostgreSQL。", "relation": [{"head": "Ontop", "head_type": "知识推理", "relation": "特点", "tail": "兼容RDFS、OWL_2_QL、R2RML、SPARQL标准", "tail_type": "文本"}, {"head": "Ontop", "head_type": "知识推理", "relation": "特点", "tail": "支持主流关系数据库", "tail_type": "文本"}]}
{"text": "Mastro最初是由意大利罗马大学开发的OBDA系统，现在由OBDA_Systems商业化运行。", "relation": [{"head": "Mastro", "head_type": "知识推理", "relation": "属于", "tail": "OBDA系统", "tail_type": "知识推理"}]}
{"text": "一个产生式系统由事实集合、产生式集合和推理引擎三部分组成。", "relation": [{"head": "产生式系统", "head_type": "知识推理", "relation": "包含", "tail": "事实集合", "tail_type": "知识推理"}, {"head": "产生式系统", "head_type": "知识推理", "relation": "包含", "tail": "产生式集合", "tail_type": "知识推理"}, {"head": "产生式系统", "head_type": "知识推理", "relation": "包含", "tail": "推理引擎", "tail_type": "知识推理"}]}
{"text": "事实集合是运行内存（Working_Memory,WM）为事实（WME）的集合，用于存储当前系统中的所有事实。", "relation": [{"head": "事实集合", "head_type": "知识推理", "relation": "被定义为", "tail": "运行内存（Working_Memory,WM）为事实（WME）的集合", "tail_type": "文本"}]}
{"text": "事实可描述对象，形如(typeattr_1:val_1attr_2:val_2…attr_n:val_n），其中type、attr_i、val_i均为原子（常量）。", "relation": [{"head": "事实对象", "head_type": "知识推理", "relation": "特点", "tail": "形如(typeattr_1:val_1attr_2:val_2…attr_n:val_n），其中type、attr_i、val_i均为原子（常量）", "tail_type": "文本"}]}
{"text": "产生式集合（ProductionMemory,PM）由一系列的产生式组成。", "relation": [{"head": "产生式集合", "head_type": "知识推理", "relation": "由组成", "tail": "一系列的产生式", "tail_type": "知识推理"}]}
{"text": "产生式形如：●IFconditionsTHENactions其中，conditions是由条件组成的集合，又称为LHS;actions是由动作组成的序列，又称为RHS。", "relation": [{"head": "产生式", "head_type": "知识推理", "relation": "特点", "tail": "IFconditionsTHENactions", "tail_type": "文本"}, {"head": "产生式", "head_type": "知识推理", "relation": "特点", "tail": "IFconditionsTHENactions", "tail_type": "文本"}]}
{"text": "推理引擎用于控制系统的执行。", "relation": [{"head": "推理引擎", "head_type": "知识推理", "relation": "作用", "tail": "控制系统的执行", "tail_type": "文本"}]}
{"text": "模式匹配用每条规则的条件部分匹配当前的WM，如图6-8所示为匹配规则过程。", "relation": [{"head": "模式匹配", "head_type": "知识推理", "relation": "方法", "tail": "每条规则的条件部分匹配当前的WM", "tail_type": "文本"}]}
{"text": "按照推理要素的不同，基于归纳的知识图谱推理可以分为以下几类：基于图结构的推理、基于规则学习的推理和基于表示学习的推理。", "relation": [{"head": "基于归纳的知识图谱推理", "head_type": "知识推理", "relation": "包含", "tail": "基于图结构的推理", "tail_type": "知识推理"}, {"head": "基于归纳的知识图谱推理", "head_type": "知识推理", "relation": "包含", "tail": "基于规则学习的推理", "tail_type": "知识推理"}, {"head": "基于归纳的知识图谱推理", "head_type": "知识推理", "relation": "包含", "tail": "基于表示学习的推理", "tail_type": "知识推理"}]}
{"text": "这说明了路径是一种重要的进行关系推理的信息，也是一种重要的图结构。", "relation": [{"head": "路径", "head_type": "知识推理", "relation": "等价", "tail": "进行关系推理的信息", "tail_type": "知识推理"}, {"head": "路径", "head_type": "知识推理", "relation": "等价", "tail": "图结构", "tail_type": "知识推理"}]}
{"text": "2.常见算法简介典型的基于图结构的推理方法有PRA（Path_Ranking_Algorithm）[10]利用了实体节点之间的路径当作特征从而进行链接预测推理。", "relation": [{"head": "PRA", "head_type": "知识推理", "relation": "属于", "tail": "基于图结构的推理方法", "tail_type": "知识推理"}]}
{"text": "PRA处理的推理问题是关系推理，其中包含了两个任务，一个是给定关系r和头实体h预测可能的尾实体t是什么，即在给定h,r的情况下，预测哪个三元组（h,r,t）成立的可能性比较大，叫作尾实体链接预测；另一个是在给定r,t的情况下，预测可能的头实体h是什么，叫作头实体链接预测。", "relation": [{"head": "尾实体链接预测", "head_type": "知识推理", "relation": "被定义为", "tail": "给定关系r和头实体h预测可能的尾实体t是什么", "tail_type": "文本"}]}
{"text": "在路径特征搜索的过程中，PRA增加了对有效路径特征的约束，来有效减小搜索空间：路径在图谱中的支持度（support）应大于某设定的比例α；路径的长度小于或等于某设定的长度；每条路径至少有一个正样本在训练集中。", "relation": [{"head": "PRA", "head_type": "知识推理", "relation": "作用", "tail": "增加了对有效路径特征的约束，来有效减小搜索空间", "tail_type": "文本"}]}
{"text": "采集路径随机游走过程采用了LVS（Low-Variance_Sampling）的方法。", "relation": [{"head": "采集路径随机游走过程", "head_type": "知识推理", "relation": "方法", "tail": "LVS（Low-Variance_Sampling）", "tail_type": "文本"}]}
{"text": "在PRA中的路径是连续的且在路径中的关系是同向的，这种路径特征可以理解为一种简单的霍恩规则（Hornrule），但是在知识图谱中，有很多种路径是含有常量的：由这个路径可以推理出三元组小明，这种有明显语义的含有常量的且不是收尾闭合的路径特征是不能被PRA捕捉到的，又例如由t=NFL直接推理ex，即将NFL直接设置为关系“服役于运动队”的值域，这种很明显的推理特征也是PRA无法捕捉的。", "relation": [{"head": "PRA中的路径", "head_type": "知识推理", "relation": "特点", "tail": "连续的且在路径中的关系是同向的", "tail_type": "文本"}]}
{"text": "但路径相关的特征还不能覆盖知识图谱中包含的所有语义信息，因而由相关工作通过引入带有实例的路径来丰富图特征所包含的语义信息的类型。", "relation": [{"head": "带有实例的路径", "head_type": "知识推理", "relation": "作用", "tail": "带有实例的路径", "tail_type": "文本"}]}
{"text": "规则是基于规则推理的核心，所以规则获取是一个重要的任务。", "relation": [{"head": "规则", "head_type": "知识推理", "relation": "特点", "tail": "基于规则推理的核心", "tail_type": "文本"}]}
{"text": "所以，自动化的规则学习方法应运而生，旨在快速有效地从大规模知识图谱上学习置信度较高的规则，并服务于关系推理任务。", "relation": [{"head": "自动化的规则学习方法", "head_type": "知识推理", "relation": "目标", "tail": "快速有效地从大规模知识图谱上学习置信度较高的规则", "tail_type": "文本"}]}
{"text": "规则一般包含了两个部分，分别为规则头（head）和规则主体（body），其一般形式为rule:head←body.解读为有规则主体的信息可推出规则头的信息。", "relation": [{"head": "规则", "head_type": "知识推理", "relation": "包含", "tail": "规则头", "tail_type": "知识推理"}, {"head": "规则", "head_type": "知识推理", "relation": "包含", "tail": "规则主体", "tail_type": "知识推理"}]}
{"text": "原子（atom）是指包含了变量的元组，例如isLocation(X)是一个一元原子表示实体变量X是一个位置实体；hasWife(X,Y)是一个二元原子，表示实体变量X的妻子是实体变量Y。", "relation": [{"head": "原子", "head_type": "知识推理", "relation": "被定义为", "tail": "包含了变量的元组", "tail_type": "文本"}]}
{"text": "在规则主体中，不同的原子是通过逻辑合取组合在一起的，且规则主体中的原子可以以肯定或否定的形式出现，例如如下规则：这里的规则示例说明了如果任意实体X的妻子是实体Y，且实体Y的孩子有Z且X和Y都不曾离婚，那么可以推出X的孩子也有Z。", "relation": [{"head": "规则主体中的原子", "head_type": "知识推理", "relation": "特点", "tail": "以肯定或否定的形式出现", "tail_type": "文本"}]}
{"text": "在规则学习过程中，对于学习到的规则一般有三种评估方法，分别是支持度（support）、置信度（confidence）、规则头覆盖度（headcoverage）。", "relation": [{"head": "支持度", "head_type": "知识推理", "relation": "属于", "tail": "评估方法", "tail_type": "知识推理"}, {"head": "置信度", "head_type": "知识推理", "relation": "属于", "tail": "评估方法", "tail_type": "知识推理"}, {"head": "规则头覆盖度", "head_type": "知识推理", "relation": "属于", "tail": "评估方法", "tail_type": "知识推理"}, {"head": "支持度", "head_type": "知识推理", "relation": "英文名", "tail": "support", "tail_type": "文本"}, {"head": "置信度", "head_type": "知识推理", "relation": "英文名", "tail": "confidence", "tail_type": "文本"}, {"head": "规则头覆盖度", "head_type": "知识推理", "relation": "英文名", "tail": "headcoverage", "tail_type": "文本"}]}
{"text": "规则的置信度（confidence）的计算方式为：即规则支持度和满足规则主体的实例个数的比值，即在满足规则主体的实例中，同时也能满足规则头的实例比例。", "relation": [{"head": "规则的置信度（confidence）的计算方式", "head_type": "知识推理", "relation": "方法", "tail": "规则支持度和满足规则主体的实例个数的比值，即在满足规则主体的实例中，同时也能满足规则头的实例比例。", "tail_type": "文本"}]}
{"text": "由于知识图谱往往具有明显的不完整性，而前文介绍的规则置信度计算方法间接假设了不存在知识图谱中的三元组是错误的，这显然是不合理的。", "relation": [{"head": "规则置信度计算方法", "head_type": "知识推理", "relation": "缺点", "tail": "间接假设了不存在知识图谱中的三元组是错误的", "tail_type": "文本"}, {"head": "知识图谱", "head_type": "知识推理", "relation": "缺点", "tail": "具有明显的不完整性", "tail_type": "文本"}]}
{"text": "所以，基于部分完全假设（PartialCompleteness_Assumption,PCA）的置信度（PCA_Confidence）也是一个衡量规则质量的方法，且考虑了知识图谱的不完整性。", "relation": [{"head": "衡量规则质量的方法", "head_type": "知识推理", "relation": "方法", "tail": "基于部分完全假设（PartialCompleteness_Assumption,PCA）的置信度（PCA_Confidence）", "tail_type": "文本"}]}
{"text": "规则头覆盖度（Head_Coverage）的计算方法为即规则支持度和满足规则头的实例个数的比值，即在满足规则头的实例中，同时也满足规则主体的实例比例。", "relation": [{"head": "规则头覆盖度（Head_Coverage）", "head_type": "知识推理", "relation": "方法", "tail": "支持度和满足规则头的实例个数的比值", "tail_type": "文本"}]}
{"text": "规则的支持度、置信度以及头覆盖度从不同的角度反映了规则的质量，但三者之间没有必然的关联关系。", "relation": [{"head": "支持度", "head_type": "知识推理", "relation": "作用", "tail": "反映规则的质量", "tail_type": "文本"}]}
{"text": "表示学习让算法在学习向量表示的过程中自动捕捉、推理所需的特征，通过训练学习，将知识图谱中离散符号表示的信息编码在不同的向量空间表示中，使得知识图谱的推理能够通过预设的向量空间表示之间的计算自动实现，不需要显式的推理步骤。", "relation": [{"head": "表示学习", "head_type": "知识推理", "relation": "作用", "tail": "让算法在学习向量表示的过程中自动捕捉、推理所需的特征", "tail_type": "文本"}, {"head": "表示学习", "head_type": "知识推理", "relation": "英文名", "tail": "representational learning", "tail_type": "文本"}]}
{"text": "TransE假设在任意一个知识图谱中的三元组（h,r,t），头实体的向量表示h加上关系的向量表示r应该等于尾实体的向量表示t。", "relation": [{"head": "TransE", "head_type": "知识推理", "relation": "内容", "tail": "假设在任意一个知识图谱中的三元组（h,r,t），头实体的向量表示h加上关系的向量表示r应该等于尾实体的向量表示t", "tail_type": "文本"}]}
{"text": "图6-18TransE和TransH对比向量空间假设对比TransH为每个关系r都设计了一个投影平面，并用投影平面的法向量wr表示这个平面，h和t的投影向量的计算方法如下：然后，利用投影向量进行三元组得分的计算，即TransH通过设计关系投影平面提升了TransE表达非一对一关系的能力，TransR[8]则通过拆分实体向量表示空间和关系表示向量空间来提升TransE的表达能力。", "relation": [{"head": "TransH", "head_type": "知识推理", "relation": "特点", "tail": "为每个关系r都设计了一个投影平面", "tail_type": "文本"}]}
{"text": "所以，训练目标是对正确的三元组让hMr与t尽可能接近，而错误的三元组尽可能远离。", "relation": [{"head": "训练目标", "head_type": "知识推理", "relation": "内容", "tail": "正确的三元组让hMr与t尽可能接近，而错误的三元组尽可能远离", "tail_type": "文本"}]}
{"text": "从语义的角度分析，知识图谱中的关系既包含了对称关系如“配偶是”，也包含了不对称关系如“出生地”，而且非对称关系一般还多于对称关系。", "relation": [{"head": "知识图谱中的关系", "head_type": "知识推理", "relation": "包含", "tail": "对称关系", "tail_type": "知识推理"}, {"head": "知识图谱中的关系", "head_type": "知识推理", "relation": "内容", "tail": "非对称关系", "tail_type": "知识推理"}]}
{"text": "本体流可以看成随时间变化的本体，也就是语义增强的数据流。", "relation": [{"head": "本体流", "head_type": "知识推理", "relation": "等价", "tail": "随时间变化的本体", "tail_type": "知识推理"}]}
{"text": "在描述逻辑中，本体流包含TBox（术语成分）和ABox（断言公理）。", "relation": [{"head": "本体流", "head_type": "知识推理", "relation": "包含", "tail": "TBox", "tail_type": "知识推理"}, {"head": "本体流", "head_type": "知识推理", "relation": "包含", "tail": "ABox", "tail_type": "知识推理"}, {"head": "本体流", "head_type": "知识推理", "relation": "包含", "tail": "ontology stream", "tail_type": "知识推理"}]}
{"text": "蕴涵的滑动窗口之间基于规则的一致性度量和预测可以表示和推断这些本体流中的语义概念漂移。", "relation": [{"head": "蕴涵的滑动窗口之间基于规则的一致性度量和预测", "head_type": "知识推理", "relation": "作用", "tail": "表示和推断这些本体流中的语义概念漂移", "tail_type": "文本"}]}
{"text": "具体而言，强化学习中智能体的状态被定义为当前节点实体和目标节点实体的联合表示st=（et,etarget−et）.智能体的动作则是在当前节点实体的出边（Outgoing_edge）中选择一个适当的边作为组成路径的关系。", "relation": [{"head": "强化学习中智能体的状态", "head_type": "知识推理", "relation": "被定义为", "tail": "当前节点实体和目标节点实体的联合表示st=（et,etarget−et）", "tail_type": "文本"}]}
{"text": "元学习的目的是解决“学习如何学习”（Learning_to_Learn），旨在通过少量样本迅速完成学习，其相对主要的应用是少样本学习（Few-Shot_Learning）。", "relation": [{"head": "元学习", "head_type": "知识推理", "relation": "目标", "tail": "解决“学习如何学习”（Learning_to_Learn）", "tail_type": "文本"}]}
{"text": "当前主要的元学习方法分为三类，基于度量（Metric-Based）、基于模型（Model-Based）和基于优化（Optimization-Based）的方法。", "relation": [{"head": "元学习方法", "head_type": "知识推理", "relation": "包含", "tail": "Metric-Based方法", "tail_type": "知识推理"}, {"head": "元学习方法", "head_type": "知识推理", "relation": "包含", "tail": "Model-Based方法", "tail_type": "知识推理"}, {"head": "元学习方法", "head_type": "知识推理", "relation": "包含", "tail": "Optimization-Based方法", "tail_type": "知识推理"}]}
{"text": "而文中将知识库补全的任务定义为：基于知识库中已存在的三元组和当前出现的包含新实体的三元组，推理当前新实体与知识库中其他实体之间的关系。", "relation": [{"head": "知识库补全", "head_type": "知识推理", "relation": "被定义为", "tail": "基于知识库中已存在的三元组和当前出现的包含新实体的三元组，推理当前新实体与知识库中其他实体之间的关系", "tail_type": "文本"}]}
{"text": "本章旨在全面系统地介绍以RDF为数据模型的知识图谱语义搜索基础技术以及面临的挑战。", "relation": [{"head": "知识图谱", "head_type": "知识图谱", "relation": "包含", "tail": "语义搜索", "tail_type": "语义搜索"}]}
{"text": "7.1语义搜索简介搜索也称信息检索（Information_Retrieval），是从信息资源集合获得与信息需求相关的信息资源的活动[1]。", "relation": [{"head": "语义搜索", "head_type": "语义搜索", "relation": "等价", "tail": "信息检索", "tail_type": "语义搜索"}, {"head": "语义搜索", "head_type": "语义搜索", "relation": "被定义为", "tail": "从信息资源集合获得与信息需求相关的信息资源的活动", "tail_type": "文本"}]}
{"text": "其中，最广泛的信息检索主要是面向文档为单位的检索（Document_Retrieval）。", "relation": [{"head": "信息检索", "head_type": "语义搜索", "relation": "包含", "tail": "面向文档为单位的检索", "tail_type": "语义搜索"}]}
{"text": "此外，面向数据的检索（Data_Retrieval）也受到越来越多的关注，主要包括基于数据库的检索和基于知识库的检索，其特点是能够提供更精确的答案[5]。", "relation": [{"head": "信息检索", "head_type": "语义搜索", "relation": "包含", "tail": "面向数据的检索", "tail_type": "语义搜索"}, {"head": "面向数据的检索", "head_type": "语义搜索", "relation": "包含", "tail": "基于知识库的检索", "tail_type": "语义搜索"}, {"head": "面向数据的检索", "head_type": "语义搜索", "relation": "特点", "tail": "能够提供更精确的答案", "tail_type": "文本"}]}
{"text": "此外，面向数据的检索（Data_Retrieval）也受到越来越多的关注，主要包括基于数据库的检索和基于知识库的检索，其特点是能够提供更精确的答案[4]。", "relation": [{"head": "面向数据的检索", "head_type": "语义搜索", "relation": "包含", "tail": "基于数据库的检索", "tail_type": "语义搜索"}]}
{"text": "面向文档的信息检索主要通过轻量级的语法模型（Lightweight_Syntax-Centric_Model）表示用户的检索需求和资源的内容，即目前占主导地位的关键词模式——词袋模型（Bag-of-Words）。", "relation": [{"head": "面向文档的信息检索", "head_type": "语义搜索", "relation": "方法", "tail": "轻量级的语法模型", "tail_type": "语义搜索"}, {"head": "轻量级的语法模型", "head_type": "语义搜索", "relation": "包含", "tail": "词袋模型", "tail_type": "语义搜索"}, {"head": "轻量级的语法模型", "head_type": "语义搜索", "relation": "英文名", "tail": "Lightweight_Syntax-Centric_Model", "tail_type": "文本"}, {"head": "词袋模型", "head_type": "语义搜索", "relation": "英文名", "tail": "Bag-of-Words", "tail_type": "文本"}]}
{"text": "这种技术对主题搜索（Topic_Search）的效果很好，即给定一个主题检索相关的文档，但不能应对更加复杂的信息检索需求。", "relation": [{"head": "轻量级的语法模型", "head_type": "语义搜索", "relation": "特点", "tail": "对主题搜索的效果很好，但不能应对更加复杂的信息检索需求", "tail_type": "文本"}]}
{"text": "显然，基于数据库和基于知识库的检索系统属于重量级语义搜索系统，因为它们采用显式的和形式化的模型，例如关系数据库中的E-R图、RDF和OWL中的知识模型。", "relation": [{"head": "基于数据库的检索系统", "head_type": "语义搜索", "relation": "属于", "tail": "重量级语义搜索系统", "tail_type": "语义搜索"}, {"head": "基于知识库的检索系统", "head_type": "语义搜索", "relation": "属于", "tail": "重量级语义搜索系统", "tail_type": "语义搜索"}]}
{"text": "如图7-1所示，一个语义搜索系统的基本框架包括查询构建、查询处理、结果展示、查询优化、语义模型、资源及文档等。", "relation": [{"head": "语义搜索系统框架", "head_type": "语义搜索", "relation": "包含", "tail": "查询构建", "tail_type": "语义搜索"}, {"head": "语义搜索系统框架", "head_type": "语义搜索", "relation": "包含", "tail": "查询处理", "tail_type": "语义搜索"}, {"head": "语义搜索系统框架", "head_type": "语义搜索", "relation": "包含", "tail": "结果展示", "tail_type": "语义搜索"}, {"head": "语义搜索系统框架", "head_type": "语义搜索", "relation": "包含", "tail": "查询优化", "tail_type": "语义搜索"}, {"head": "语义搜索系统框架", "head_type": "语义搜索", "relation": "包含", "tail": "语义模型", "tail_type": "语义搜索"}, {"head": "语义搜索系统框架", "head_type": "语义搜索", "relation": "包含", "tail": "资源及文档", "tail_type": "语义搜索"}]}
{"text": "SPARQL查询语言是面向RDF图的结构化查询语言，目前已被W3C推荐为RDF数据的标准查询语言[2]，其地位和查询形式都类似于关系数据库的SQL语言。", "relation": [{"head": "SPARQL查询语言", "head_type": "语义搜索", "relation": "被定义为", "tail": "面向RDF图的结构化查询语言", "tail_type": "文本"}]}
{"text": "SPARQL查询的核心处理单元是类似RDF三元组形式的三元组模式（TriplePattern），不同之处在于SPARQL的三元组模式中，主语、谓语或宾语可以是变量（以“?”开头标识）。", "relation": [{"head": "SPARQL查询语言", "head_type": "语义搜索", "relation": "特点", "tail": "核心处理单元是类似RDF三元组形式的三元组模式，但主语、谓语或宾语可以是变量", "tail_type": "文本"}]}
{"text": "除此之外，SPARQL查询还定义了多个基本图模式之间进行的运算操作，以及基本图模式与RDF图匹配完成后的结果过滤操作（Filter_Operator），如可以用？date大于1990（?date>1990）对前面一个查询例子中的电影日期进行限制。", "relation": [{"head": "SPARQL查询语言", "head_type": "语义搜索", "relation": "实现", "tail": "基本图模式之间进行的运算操作", "tail_type": "语义搜索"}, {"head": "SPARQL查询语言", "head_type": "语义搜索", "relation": "实现", "tail": "基本图模式与RDF图匹配完成后的结果过滤操作", "tail_type": "语义搜索"}]}
{"text": "最后，在SPARQL1.1版本中，还增加了联合查询功能，即支持通过FROM和嵌套查询的方式，进>行多个数据源联合查询。", "relation": [{"head": "SPARQL查询语言", "head_type": "语义搜索", "relation": "实现", "tail": "联合查询功能", "tail_type": "语义搜索"}]}
{"text": "下面将以图7-2中的样例知识图谱和对应的SPARQL查询实例，分别介绍如何使用SPARQL对知识图谱进行数据查询、数据插入以及数据删除操作。", "relation": [{"head": "SPARQL查询语言", "head_type": "语义搜索", "relation": "包含", "tail": "数据查询", "tail_type": "语义搜索"}, {"head": "SPARQL查询语言", "head_type": "语义搜索", "relation": "包含", "tail": "数据插入", "tail_type": "语义搜索"}, {"head": "SPARQL查询语言", "head_type": "语义搜索", "relation": "包含", "tail": "数据删除", "tail_type": "语义搜索"}]}
{"text": "7.2.1数据查询SPARQL官方标准定义了四种最终返回给用户查询结果的形式，代表着四种基本的查询功能，即SELECT、ASK、CONSTRUCT和DESCRIBE。", "relation": [{"head": "数据查询", "head_type": "语义搜索", "relation": "包含", "tail": "SELECT", "tail_type": "语义搜索"}, {"head": "数据查询", "head_type": "语义搜索", "relation": "包含", "tail": "ASK", "tail_type": "语义搜索"}]}
{"text": "7.2.2数据查询SPARQL官方标准定义了四种最终返回给用户查询结果的形式，代表着四种基本的查询功能，即SELECT、ASK、CONSTRUCT和DESCRIBE。", "relation": [{"head": "数据查询", "head_type": "语义搜索", "relation": "包含", "tail": "CONSTRUCT", "tail_type": "语义搜索"}]}
{"text": "7.2.3数据查询SPARQL官方标准定义了四种最终返回给用户查询结果的形式，代表着四种基本的查询功能，即SELECT、ASK、CONSTRUCT和DESCRIBE。", "relation": [{"head": "数据查询", "head_type": "语义搜索", "relation": "包含", "tail": "DESCRIBE", "tail_type": "语义搜索"}]}
{"text": "其中，SELECT是唯一可以返回知识图谱中图模式匹配具体结果给用户的形式，也是最常用的查询语句；ASK查询语句主要用于测试知识图谱中是否存在满足给定查询约束条件的数据，结果以Yes或No的形式返回，除此之外没有额外的信息返回；CONSTRUCT查询语句主要用于将图模式匹配结果生成新的RDF图；DESCRIBE查询语句用于查询与指定IRI相关的数据，注意和SELECT有区别。", "relation": [{"head": "SELECT", "head_type": "语义搜索", "relation": "被定义为", "tail": "返回知识图谱中图模式匹配具体结果给用户的形式", "tail_type": "文本"}, {"head": "ASK", "head_type": "语义搜索", "relation": "被定义为", "tail": "测试知识图谱中是否存在满足给定查询约束条件的数据，结果以Yes或No的形式返回", "tail_type": "文本"}, {"head": "CONSTRUCT", "head_type": "语义搜索", "relation": "被定义为", "tail": "将图模式匹配结果生成新的RDF图", "tail_type": "文本"}, {"head": "DESCRIBE", "head_type": "语义搜索", "relation": "被定义为", "tail": "查询与指定IRI相关的数据", "tail_type": "文本"}]}
{"text": "1.SELECT的基本语法其中，“SELECT”指明了查询的形式。“SELECT”后面的“变量1变量2…”表示图匹配后想要查询的具体目标。“FROM”指明了数据源，在通常情况下，在单个知识图谱中查询时，默认不指明数据集的名称，即可以省略SPARQL查询中的FROM字段（后续其他形式的查询语句介绍中将不再提及FROM部分）。“WHERE”语句后面的大括号中就是具体的基本图模式和约束条件（FILTER字段给出）。值得注意的是，“WHERE”语句后面至少应该包含一个基本图模式（在查询语法中，不同的三元组模式在大括号中用英文句点“.”间隔），而约束条件为可选项。最后的修饰符[5]（Modifier）同样是可选项，主要用于对查询的结果进行一些处理，常见的有排序操作ORDER、限制结果数量操作LIMIT等。", "relation": [{"head": "SELECT", "head_type": "语义搜索", "relation": "语法", "tail": "SELECT变量1变量2…FROM 数据源WHERE{基本图模式[过滤条件]} [修饰符]。其中“SELECT”指明了查询的形式。SELECT后面的变量1变量2…表示图匹配后想要查询的具体目标。FROM指明了数据源。WHERE语句后面的大括号中就是具体的基本图模式和约束条件（FILTER字段给出）。最后的修饰符同样是可选项，主要用于对查询的结果进行一些处理，常见的有排序操作ORDER、限制结果数量操作LIMIT等。", "tail_type": "文本"}]}
{"text": "图7-3典型的SELECT查询2.ASK的基本语法其中，“ASK”指明了查询的形式。“ASK”后面的内容和SELECT中的“WHERE”部分类似。", "relation": [{"head": "ASK", "head_type": "语义搜索", "relation": "语法", "tail": "ASK{基本图模式[条件约束]}。ASK指明了查询的形式，ASK后面的内容和SELECT中的WHERE部分类似", "tail_type": "文本"}]}
{"text": "3.CONSTRUCT的基本语法其中，“CONSTRUCT”指明了查询的形式。“CONSTRUCT”后面的“图模板”类似于基本图模式，指明了生成的RDF应该具有的基本三元组内容。而“WHERE”语句后面的基本图模式和SELECT语句中的类似，用于图模式匹配和约束。而“WHERE”语句后面的基本图模式和SELECT语句中的类似，用于图模式匹配和约束。", "relation": [{"head": "CONSTRUCT", "head_type": "语义搜索", "relation": "语法", "tail": "CONSTRUCT{图模版}WHERE{基本图模式{条件约束}}。“CONSTRUCT”指明了查询的形式。“CONSTRUCT”后面的“图模板”类似于基本图模式，指明了生成的RDF应该具有的基本三元组内容。", "tail_type": "文本"}]}
{"text": "SPARQL支持通过INSERT_DATA语句，将新的RDF三元组插入已有的RDF图中。", "relation": [{"head": "数据插入", "head_type": "语义搜索", "relation": "包含", "tail": "INSERT_DATA", "tail_type": "语义搜索"}, {"head": "INSERT_DATA", "head_type": "语义搜索", "relation": "被定义为", "tail": "将新的RDF三元组插入已有的RDF图中", "tail_type": "文本"}]}
{"text": "具体的基本语法为：其中，INSERT_DATA指明了查询的形式。在INSERT_DATA后面可以是单条三元组，也可以是多条三元组构成的RDF图。在查询语法中，英文分号“;”可以用来连续插入头实体相同的三元组。", "relation": [{"head": "INSERT_DATA", "head_type": "语义搜索", "relation": "语法", "tail": "INSERT_DATA{RDF三元组(RDF图)}。INSERT_DATA指明了查询的形式。在INSERT_DATA后面可以是单条三元组，也可以是多条三元组构成的RDF图。在查询语法中，英文分号“;”可以用来连续插入头实体相同的三元组。", "tail_type": "文本"}]}
{"text": "7.2.3数据删除SPARQL的删除语句支持通过DELETE_DATA语句将RDF图中已有的某些三元组删除。", "relation": [{"head": "数据删除", "head_type": "语义搜索", "relation": "包含", "tail": "DELETE_DATA", "tail_type": "语义搜索"}]}
{"text": "具体的基本语法为：其中，DELETE_DATA指明了查询的形式。与插入语句类似，在DELETE_DATA后可以是单条三元组，也可以是多条三元组构成的RDF图。", "relation": [{"head": "DELETE_DATA", "head_type": "语义搜索", "relation": "语法", "tail": "DELETE_DATA{RDF三元组(RDF图)}。其中，DELETE_DATA指明了查询的形式。在DELETE_DATA后可以是单条三元组，也可以是多条三元组构成的RDF图。", "tail_type": "文本"}]}
{"text": "7.3语义数据搜索目前，得益于W3C完成RDF语言和协议的标准化，互联网上的不同RDF数据能够以RDF链接的形式链接在一起，形成一个完整的语义链接数据网络，也称作数据Web。", "relation": [{"head": "数据Web", "head_type": "语义搜索", "relation": "被定义为", "tail": "互联网上的不同RDF数据能够以RDF链接的形式链接在一起，形成一个完整的语义链接数据网络", "tail_type": "文本"}]}
{"text": "当前，链接数据比较成熟的语义搜索主要包括：面向本体的搜索引擎，如Swoogle[8]、Watson[9]；面向实体的搜索引擎，如Sigma_on_Sindice[10]、FalconS[11]；以及面向细粒度数据Web的搜索引擎，如SWSE[12]、Hermes（SearchWebDB）[13]。", "relation": [{"head": "语义搜索", "head_type": "语义搜索", "relation": "包含", "tail": "面向本体的搜索引擎", "tail_type": "语义搜索"}]}
{"text": "当前，链接数据比较成熟的语义搜索主要包括：面向本体的搜索引擎，如Swoogle[8]、Watson[9]；面向实体的搜索引擎，如Sigma_on_Sindice[10]、FalconS[11]；以及面向细粒度数据Web的搜索引擎，如SWSE[12]、Hermes（SearchWebDB）[14]。", "relation": [{"head": "语义搜索", "head_type": "语义搜索", "relation": "包含", "tail": "面向实体的搜索引擎", "tail_type": "语义搜索"}]}
{"text": "当前，链接数据比较成熟的语义搜索主要包括：面向本体的搜索引擎，如Swoogle[8]、Watson[9]；面向实体的搜索引擎，如Sigma_on_Sindice[10]、FalconS[11]；以及面向细粒度数据Web的搜索引擎，如SWSE[12]、Hermes（SearchWebDB）[15]。", "relation": [{"head": "语义搜索", "head_type": "语义搜索", "relation": "包含", "tail": "面向细粒度数据Web的搜索引擎", "tail_type": "语义搜索"}]}
{"text": "这些搜索引擎的基本组成都包括三元组存储、索引构建、查询处理及排序等，具体内容如下：1.三元组存储基于IR的存储方式，即单一的数据结构和查询算法，针对文本数据进行排序检索来优化。", "relation": [{"head": "语义搜索引擎", "head_type": "语义搜索", "relation": "由组成", "tail": "三元组存储", "tail_type": "语义搜索"}, {"head": "语义搜索引擎", "head_type": "语义搜索", "relation": "由组成", "tail": "索引构建", "tail_type": "语义搜索"}]}
{"text": "这些搜索引擎的基本组成都包括三元组存储、索引构建、查询处理及排序等，具体内容如下：2.三元组存储基于IR的存储方式，即单一的数据结构和查询算法，针对文本数据进行排序检索来优化。", "relation": [{"head": "语义搜索引擎", "head_type": "语义搜索", "relation": "由组成", "tail": "查询处理及排序", "tail_type": "语义搜索"}]}
{"text": "1.三元组存储基于IR的存储方式，即单一的数据结构和查询算法，针对文本数据进行排序检索来优化。", "relation": [{"head": "三元组存储", "head_type": "语义搜索", "relation": "包含", "tail": "基于IR的存储方式", "tail_type": "语义搜索"}, {"head": "基于IR的存储方式", "head_type": "语义搜索", "relation": "被定义为", "tail": "单一的数据结构和查询算法，针对文本数据进行排序检索来优化", "tail_type": "文本"}]}
{"text": "其优点是高度可压缩、可访问，且排序是整个存储索引的组成部分，缺点是不能处理结构化查询中简单的选择、联结等操作。", "relation": [{"head": "基于IR的存储方式", "head_type": "语义搜索", "relation": "特点", "tail": "高度可压缩、可访问，且排序是整个存储索引的组成部分", "tail_type": "文本"}, {"head": "基于IR的存储方式", "head_type": "语义搜索", "relation": "缺点", "tail": "不能处理结构化查询中简单的选择、联结等操作", "tail_type": "文本"}]}
{"text": "1.三元组存储基于DB的存储方式", "relation": [{"head": "三元组存储", "head_type": "语义搜索", "relation": "包含", "tail": "基于DB的存储方式", "tail_type": "语义搜索"}]}
{"text": "基于DB的存储方式，即多种索引和查询算法，以适应各种结构化数据的复杂查询需求。", "relation": [{"head": "基于DB的存储方式", "head_type": "语义搜索", "relation": "被定义为", "tail": "多种索引和查询算法，以适应各种结构化数据的复杂查询需求", "tail_type": "文本"}]}
{"text": "其优点是能够完成复杂的选择、联结等操作，进而支持SPARQL结构化查询，并且能应对高动态场景（许多插入或删除），缺点是空间开销增大和访问有一定的局限性，并且无法集成对检索结果的排序。", "relation": [{"head": "基于DB的存储方式", "head_type": "语义搜索", "relation": "特点", "tail": "能够完成复杂的选择、联结等操作，进而支持SPARQL结构化查询，并且能应对高动态场景", "tail_type": "文本"}, {"head": "基于DB的存储方式", "head_type": "语义搜索", "relation": "缺点", "tail": "空间开销增大和访问有一定的局限性，并且无法集成对检索结果的排序", "tail_type": "文本"}]}
{"text": "1.三元组存储原生存储", "relation": [{"head": "三元组存储", "head_type": "语义搜索", "relation": "包含", "tail": "原生存储", "tail_type": "语义搜索"}]}
{"text": "原生存储（Native_Stores）即直接以RDF图形式的存储方式。", "relation": [{"head": "原生存储", "head_type": "语义搜索", "relation": "被定义为", "tail": "直接以RDF图形式的存储方式", "tail_type": "文本"}]}
{"text": "其优点是高度可压缩，可访问类似IR的检索排序，支持选择、联结等操作，并且可在亚秒级时间内在单台机器上完成对TB级数据的查询，以及支持高动态场景，缺点是没有事务、恢复等功能。", "relation": [{"head": "原生存储", "head_type": "语义搜索", "relation": "特点", "tail": "高度可压缩，可访问类似IR的检索排序，支持选择、联结等操作，并且可在亚秒级时间内在单台机器上完成对TB级数据的查询，以及支持高动态场景", "tail_type": "文本"}, {"head": "原生存储", "head_type": "语义搜索", "relation": "缺点", "tail": "没有事务、恢复等功能", "tail_type": "文本"}]}
{"text": "2.索引构建目前主要的方式都是重用IR索引来索引RDF语义数据。", "relation": [{"head": "索引构建", "head_type": "语义搜索", "relation": "包含", "tail": "IR索引", "tail_type": "语义搜索"}]}
{"text": "IR索引主要包括以下几个核心概念：文档、字段（例如，标题、摘要、正文……）、词语、Posting_list和Positionlist[6]。", "relation": [{"head": "IR索引", "head_type": "语义搜索", "relation": "内容", "tail": "文档、词语、Posting_list、Position_list", "tail_type": "文本"}]}
{"text": "而利用IR索引来索引RDF数据的核心思想是将RDF转换成具有fields和terms的虚拟文档，如图7-6所示。", "relation": [{"head": "IR索引", "head_type": "语义搜索", "relation": "方法", "tail": "将RDF转换成具有fields和terms的虚拟文档", "tail_type": "文本"}]}
{"text": "3.查询处理和排序首先，查询处理的核心步骤是给定查询输入，将其构建成复杂的结构化查询。", "relation": [{"head": "查询处理及排序", "head_type": "语义搜索", "relation": "内容", "tail": "给定查询输入，将其构建成复杂的结构化查询", "tail_type": "文本"}]}
{"text": "此类常见的交互范式主要包括：关键词查询、自然语言查询、分面查询、表单查询、可视化查询以及混合方式查询等[15]。", "relation": [{"head": "语义搜索交互范式", "head_type": "语义搜索", "relation": "包含", "tail": "基于关键词查询", "tail_type": "语义搜索"}, {"head": "语义搜索交互范式", "head_type": "语义搜索", "relation": "包含", "tail": "基于自然语言查询", "tail_type": "语义搜索"}, {"head": "语义搜索交互范式", "head_type": "语义搜索", "relation": "包含", "tail": "基于分面查询", "tail_type": "语义搜索"}, {"head": "语义搜索交互范式", "head_type": "语义搜索", "relation": "包含", "tail": "基于表单查询", "tail_type": "语义搜索"}, {"head": "语义搜索交互范式", "head_type": "语义搜索", "relation": "包含", "tail": "基于可视化查询", "tail_type": "语义搜索"}, {"head": "语义搜索交互范式", "head_type": "语义搜索", "relation": "包含", "tail": "基于混合方式查询", "tail_type": "语义搜索"}]}
{"text": "知识图谱上的关键词查询主要可以分为两类[17]：基于关键词直接在知识图谱上搜索答案；基于关键词生成结构化的查询，进而提交给查询引擎得到结果。", "relation": [{"head": "基于关键词查询", "head_type": "语义搜索", "relation": "包含", "tail": "基于关键词直接在知识图谱上搜索答案", "tail_type": "语义搜索"}]}
{"text": "知识图谱上的关键词查询主要可以分为两类[18]：基于关键词直接在知识图谱上搜索答案；基于关键词生成结构化的查询，进而提交给查询引擎得到结果。", "relation": [{"head": "基于关键词查询", "head_type": "语义搜索", "relation": "包含", "tail": "基于关键词生成结构化的查询", "tail_type": "语义搜索"}]}
{"text": "1.基于关键词直接在知识图谱上搜索答案将关键词在知识图谱上直接进行搜索的方法，其核心思想是采用知识图谱子图定位的策略。", "relation": [{"head": "基于关键词直接在知识图谱上搜索答案", "head_type": "语义搜索", "relation": "被定义为", "tail": "采用知识图谱子图定位的策略", "tail_type": "文本"}]}
{"text": "基本流程是建立有效的关键词和知识图谱子图的索引，对于给定的关键字查询，首先在索引上匹配得到候选的知识图谱子图，进而实现对搜索空间的剪枝。", "relation": [{"head": "基于关键词直接在知识图谱上搜索答案", "head_type": "语义搜索", "relation": "内容", "tail": "建立有效的关键词和知识图谱子图的索引，对于给定的关键字查询，首先在索引上匹配得到候选的知识图谱子图，进而实现对搜索空间的剪枝。最后，在小范围的知识图谱子图上进行搜索，找到最终的查询答案。", "tail_type": "文本"}]}
{"text": "该类方法的核心在于索引的构建，其构建方式直接决定搜索的效率和结果的质量。", "relation": [{"head": "基于关键词直接在知识图谱上搜索答案", "head_type": "语义搜索", "relation": "包含", "tail": "索引的构建", "tail_type": "语义搜索"}]}
{"text": "常见的索引方式有：（1）关键词倒排索引。", "relation": [{"head": "索引的构建", "head_type": "语义搜索", "relation": "包含", "tail": "关键词倒排索引", "tail_type": "语义搜索"}]}
{"text": "通过构建索引，快速定位知识图谱中包含关键词的实体。", "relation": [{"head": "关键词倒排索引", "head_type": "语义搜索", "relation": "被定义为", "tail": "通过构建索引，快速定位知识图谱中包含关键词的实体。", "tail_type": "文本"}]}
{"text": "（2）摘要索引。", "relation": [{"head": "索引的构建", "head_type": "语义搜索", "relation": "包含", "tail": "摘要索引", "tail_type": "语义搜索"}]}
{"text": "主要是构建一些包含结构化查询实体和关系类别的索引，在线上处理时根据类别摘要进行扩充。", "relation": [{"head": "摘要索引", "head_type": "语义搜索", "relation": "被定义为", "tail": "构建一些包含结构化查询实体和关系类别的索引，在线上处理时根据类别摘要进行扩充", "tail_type": "文本"}]}
{"text": "（3）路径索引。", "relation": [{"head": "索引的构建", "head_type": "语义搜索", "relation": "包含", "tail": "路径索引", "tail_type": "语义搜索"}]}
{"text": "主要借助关键词中包含的查询起始和终止结点，在图上按路径搜索提高查询效率。", "relation": [{"head": "路径索引", "head_type": "语义搜索", "relation": "被定义为", "tail": "借助关键词中包含的查询起始和终止结点，在图上按路径搜索提高查询效率", "tail_type": "文本"}]}
{"text": "基于关键词直接在知识图谱上搜索答案主要可以解决简单的语义搜索，即查询答案仅仅出现在单条知识图谱三元组中，对于复杂的语义查询往往无法适用。", "relation": [{"head": "基于关键词直接在知识图谱上搜索答案", "head_type": "语义搜索", "relation": "特点", "tail": "可以解决简单的语义搜索", "tail_type": "文本"}]}
{"text": "2.基于关键词生成结构化的查询将关键词集合转化为结构化的查询方法主要包括三个步骤：（1）关键词映射。", "relation": [{"head": "基于关键词生成结构化的查询", "head_type": "语义搜索", "relation": "包含", "tail": "关键词映射", "tail_type": "语义搜索"}]}
{"text": "（2）候选结构化查询构建。", "relation": [{"head": "基于关键词生成结构化的查询", "head_type": "语义搜索", "relation": "包含", "tail": "候选结构化查询构建", "tail_type": "语义搜索"}]}
{"text": "（3）候选结构化查询排序。", "relation": [{"head": "基于关键词生成结构化的查询", "head_type": "语义搜索", "relation": "包含", "tail": "候选结构化查询排序", "tail_type": "语义搜索"}]}
{"text": "7.4.2基于分面的知识图谱语义搜索分面（Facet）概念最早是由“印度图书馆学之父”S.R.Ranganathan提出来的，用于表示图书文献的多维属性，并在此基础上提出了第一种图书分面分类法——冒号分类法（Colon_Classification)。", "relation": [{"head": "基于分面的知识图谱语义搜索", "head_type": "语义搜索", "relation": "包含", "tail": "分面", "tail_type": "语义搜索"}]}
{"text": "7.4.2基于分面的知识图谱语义搜索分面（Facet）概念最早是由“印度图书馆学之父”S.R.Ranganathan提出来的，用于表示图书文献的多维属性，并在此基础上提出了第一种图书分面分类法——冒号分类法（Colon_Classification)。典型的定义将分面描述为属性或一组分类体系（category），或将分面定义为某个主题的维度或侧面。", "relation": [{"head": "分面", "head_type": "语义搜索", "relation": "被定义为", "tail": "属性或一组分类体系或某个主题的维度或侧面", "tail_type": "文本"}]}
{"text": "值得一提的是，一些高级的分面搜索系统还需要具备以下特征：（1）考虑特定领域的分面、分面值和计数。", "relation": [{"head": "高级分面搜索系统", "head_type": "语义搜索", "relation": "特点", "tail": "考虑特定领域的分面、分面值和计数；支持全面的浏览；支持动态分面和值的聚类", "tail_type": "文本"}]}
{"text": "知识图谱表示学习旨在通过机器学习技术，将知识图谱中的实体和关系投射到连续低维的向量空间中，同时保持原有知识图谱的基本结构和性质[20]。", "relation": [{"head": "知识图谱表示学习", "head_type": "语义搜索", "relation": "目标", "tail": "将知识图谱中的实体和关系投射到连续低维的向量空间中，同时保持原有知识图谱的基本结构和性质", "tail_type": "文本"}]}
{"text": "通过知识图谱表示学习技术，将其投射到低维连续的向量空间中，对于语义搜索领域主要有两个好处。一是在连续向量空间中，可以直接进行数值型计算，对查询术语或者关键字进行扩展，效率极高。二是低维连续的知识图谱向量表示是通过机器学习技术学习得到的，其学习过程既考虑了知识图谱的局部特征，又考虑了全局特征，生成的实体和关系的向量在本质上是一种蕴涵语义更丰富的表示，可以进行高效率的简单查询推理。", "relation": [{"head": "知识图谱表示学习", "head_type": "语义搜索", "relation": "特点", "tail": "连续向量空间中，可以直接进行数值型计算，对查询术语或者关键字进行扩展，效率极高。生成的实体和关系的向量在本质上是一种蕴涵语义更丰富的表示，可以进行高效率的简单查询推理。", "tail_type": "文本"}]}
{"text": "下面从基于表示学习的结构化语义查询和基于表示学习的自然语言语义查询两个方面，介绍知识图谱表示学习技术可以带来哪些改进。", "relation": [{"head": "知识图谱表示学习", "head_type": "语义搜索", "relation": "包含", "tail": "基于表示学习的结构化语义查询", "tail_type": "语义搜索"}, {"head": "知识图谱表示学习", "head_type": "语义搜索", "relation": "包含", "tail": "基于表示学习的自然语言语义查询", "tail_type": "语义搜索"}]}
{"text": "1.基于表示学习的结构化语义查询表示学习在结构化语义查询的应用主要是可以有效、高速地进行近似语义搜索。", "relation": [{"head": "基于表示学习的结构化语义查询", "head_type": "语义搜索", "relation": "特点", "tail": "有效、高速地进行近似语义搜索", "tail_type": "文本"}]}
{"text": "2.基于表示学习的自然语言语义查询自然语言形式的语义查询的核心在于短语（phrase）到知识图谱上实体或边的映射，进而生成结构化的查询。", "relation": [{"head": "基于表示学习的自然语言语义查询", "head_type": "语义搜索", "relation": "特点", "tail": "短语到知识图谱上实体或边的映射，进而生成结构化的查询", "tail_type": "文本"}]}
{"text": "第8章知识问答丁力海知智能，杨成彪南京柯基数据科技有限公司知识问答通过自然语言对话的形式帮助人们从知识库中获取知识，它不但是知识图谱的核心应用之一，也是自然语言处理的重要研究方向。", "relation": [{"head": "知识问答", "head_type": "知识问答", "relation": "被定义为", "tail": "知识图谱的核心应用之一，也是自然语言处理的重要研究方向", "tail_type": "文本"}]}
{"text": "8.1知识问答概述知识问答系统是一个拟人化的智能系统，它接收使用自然语言表达的问题，理解用户的意图，获取相关的知识，最终通过推理计算形成自然语言表达的答案并反馈给用户。", "relation": [{"head": "知识问答系统", "head_type": "知识问答", "relation": "属于", "tail": "智能系统", "tail_type": "知识问答"}]}
{"text": "8.1.1知识问答的基本要素知识问答或问答（Question_Answering,QA）是对话的一种形态。", "relation": [{"head": "知识问答", "head_type": "知识问答", "relation": "英文名", "tail": "Question_Answering,QA", "tail_type": "文本"}]}
{"text": "它强调以自然语言问答为交互形式从智能体获取知识，不但要求智能体能够理解问题的语义，还要求基于自身掌握的知识和推理计算能力形成答案。", "relation": [{"head": "知识问答智能体", "head_type": "知识问答", "relation": "作用", "tail": "以自然语言问答为交互形式从智能体获取知识", "tail_type": "文本"}]}
{"text": "问答是一种典型的智能行为，例如著名的图灵测试就是考验能否通过自然语言对话的方式判定答题者是人还是机器。", "relation": [{"head": "问答", "head_type": "知识问答", "relation": "属于", "tail": "智能行为", "tail_type": "知识问答"}]}
{"text": "在采用对话方式与用户沟通时，众多问答系统都需要使用一定的知识来解答问题，所以说问答系统实质上就是知识问答，本文后续也不再区分问答系统和知识问答系统。", "relation": [{"head": "问答系统", "head_type": "知识问答", "relation": "属于", "tail": "知识问答", "tail_type": "知识问答"}]}
{"text": "图8-1问答系统的四大要素8.1.2知识问答的相关工作信息检索（Information_Retrieval,IR）或搜索以关键词搜索为代表，帮助用户发现包含搜索关键词的网页或文档。", "relation": [{"head": "信息检索", "head_type": "知识问答", "relation": "英文名", "tail": "Information_Retrieval,IR", "tail_type": "文本"}, {"head": "信息检索", "head_type": "知识问答", "relation": "被定义为", "tail": "以关键词搜索为代表，帮助用户发现包含搜索关键词的网页或文档", "tail_type": "文本"}]}
{"text": "近来的信息检索技术也在逐步利用语义信息，例如支持查询扩展[1]、语义相似度匹配[2]以及基于知识图谱的实体识别[3]。", "relation": [{"head": "信息检索技术", "head_type": "知识问答", "relation": "方法", "tail": "语义信息，例如支持查询扩展[1]、语义相似度匹配[2]以及基于知识图谱的实体识别", "tail_type": "文本"}]}
{"text": "数据库查询（Database_Query）同样可以帮助用户获取知识，但是知识问答和数据库查询仍然存在一定差异。", "relation": [{"head": "数据库查询", "head_type": "知识问答", "relation": "英文名", "tail": "Database_Query", "tail_type": "文本"}]}
{"text": "值得注意的是，自然语言查询需要处理歧义现象，例如“Listall_employees_in_the_company_with_a_driving_license”（“列举有驾照的公司的雇员”），可以是找“有驾照的公司”也可以是“有驾照的公司雇员”，从常识判断只有后者才是用户的真正意图。", "relation": [{"head": "自然语言查询", "head_type": "知识问答", "relation": "作用", "tail": "处理歧义现象", "tail_type": "文本"}]}
{"text": "第二，数据库对知识库有严格限制，要求数据必须结构化存储。", "relation": [{"head": "数据库", "head_type": "知识问答", "relation": "来源", "tail": "知识库", "tail_type": "知识问答"}]}
{"text": "案例1.知识问答可以直接嵌入搜索引擎的结果页面，将问答的答案与搜索的结果列表同时展示。", "relation": [{"head": "知识问答", "head_type": "知识问答", "relation": "作用", "tail": "直接嵌入搜索引擎的结果页面，将问答的答案与搜索的结果列表同时展示", "tail_type": "文本"}]}
{"text": "图8-2“沃森”在《危险边缘》中获得冠军图8-3问答展示界面案例2.知识问答技术可以应用于智能对话系统、智能客服或智能助理（IntelligentAgent）[7]。", "relation": [{"head": "智能助理", "head_type": "知识问答", "relation": "英文名", "tail": "IntelligentAgent", "tail_type": "文本"}]}
{"text": "除了帮助人们获取知识[8]，智能助理也可以跟人闲聊，帮助人执行任务（例如下订单、订酒店、叫外卖），将用户的问题转化为结构化查询，利用多轮对话补全用户的意图等[9]。", "relation": [{"head": "智能助理", "head_type": "知识问答", "relation": "作用", "tail": "帮助人们获取知识", "tail_type": "文本"}]}
{"text": "各种答题机器人和对话机器人也是知识问答的一个重要应用方向。", "relation": [{"head": "知识问答", "head_type": "知识问答", "relation": "包含", "tail": "答题机器人", "tail_type": "知识问答"}]}
{"text": "以阅读理解为代表的应用也可以被看作是知识问答的特例，它主要限制了知识库的边界（虽然阅读理解的主体知识是指定的章，但是实现理解仍然需要语法、常用词汇概念以及常识等辅助），而问题的形式可以是选择题（判断哪个答案正确）、填空题（直接填写答案）抑或是简答题。", "relation": [{"head": "知识问答", "head_type": "知识问答", "relation": "包含", "tail": "以阅读理解为代表的应用", "tail_type": "知识问答"}]}
{"text": "问答系统可以针对问题类型，选择对应的知识库、处理逻辑来生成答案[15]。", "relation": [{"head": "问答系统", "head_type": "知识问答", "relation": "目标", "tail": "针对问题类型，选择对应的知识库、处理逻辑来生成答案", "tail_type": "文本"}]}
{"text": "通过对问题的类型（也就是用户问题所期望的答案的类型）的分析，问答系统可以有针对性地选择有效的知识库和处理逻辑解答一类问题。", "relation": [{"head": "问答系统", "head_type": "知识问答", "relation": "目标", "tail": "选择有效的知识库和处理逻辑解答一类问题", "tail_type": "文本"}]}
{"text": "LI等人[15]通过观察TREC的1000个问题的数据，从答案类型出发建立了一个问题分类体系，包含6个大类和50个细分类，并对各类问题的占比进行了统计。", "relation": [{"head": "TREC", "head_type": "知识图谱项目", "relation": "创建者", "tail": "LI等人", "tail_type": "人物/实验室"}]}
{"text": "可见，在知识问答中，一个合理的分类体系能够体现出问题的类型分布，从而帮助开发者有针对性地设计问答解决方案，并形成良好的问答系统。", "relation": [{"head": "分类体系", "head_type": "知识问答", "relation": "作用", "tail": "帮助开发者有针对性地设计问答解决方案", "tail_type": "文本"}, {"head": "问答系统", "head_type": "知识问答", "relation": "来源", "tail": "分类体系", "tail_type": "知识问答"}]}
{"text": "图8-6ISI_QA问题类型分类体系及实例后续也出现了基于功能的问题分类体系。", "relation": [{"head": "ISI_QA问题类型分类体系及实例", "head_type": "知识图谱项目", "relation": "作用", "tail": "基于功能的问题分类体系", "tail_type": "文本"}]}
{"text": "表8-2BU等人提出的问题分类机制[18]图8-7基于功能的问题分类体系在百度知道中的占比[18]综合分类体系的探索工作，本文从问答的功能出发，面向知识图谱问答的构建（即假定知识库的主题为知识图谱）整理出两种问题类型：事实性客观问题和主观深层次问题。", "relation": [{"head": "问题类型", "head_type": "知识问答", "relation": "包含", "tail": "事实性客观问题", "tail_type": "知识问答"}, {"head": "问题类型", "head_type": "知识问答", "relation": "包含", "tail": "主观深层次问题", "tail_type": "知识问答"}]}
{"text": "事实型问题是知识问答中处理频度较高的一种问题类型，其中包含了谓词型问题（答案是一个单一的对象）、列表型问题（返回的不止一个答案，而是一列答案）。", "relation": [{"head": "事实型问题", "head_type": "知识问答", "relation": "属于", "tail": "问题类型", "tail_type": "知识问答"}, {"head": "事实型问题", "head_type": "知识问答", "relation": "包含", "tail": "谓词型问题", "tail_type": "知识问答"}, {"head": "事实型问题", "head_type": "知识问答", "relation": "包含", "tail": "列表型问题", "tail_type": "知识问答"}]}
{"text": "问题焦点（Focus）指的是问句中出现的与答案实体或属性相关的元素，例如问句“In_which_city_was_Barack_Obama_born?”中的city，以及“What_is_the_population_of_Galway?”中的population。", "relation": [{"head": "问题焦点", "head_type": "知识问答", "relation": "被定义为", "tail": "问句中出现的与答案实体或属性相关的元素", "tail_type": "文本"}, {"head": "问题焦点", "head_type": "知识问答", "relation": "英文名", "tail": "Focus", "tail_type": "文本"}]}
{"text": "问题主题（Topic）反映问题是关于哪些主题的，例如问句“What_is_the_height_of_Mount_Everest?”询问的是关于地理及山脉的信息，而“Which_organ_is_affected_by_the_Meniere's_disease?”的问题主题则是医疗方面的内容。", "relation": [{"head": "问题主题", "head_type": "知识问答", "relation": "被定义为", "tail": "反映问题是关于哪些主题的", "tail_type": "文本"}, {"head": "问题主题", "head_type": "知识问答", "relation": "英文名", "tail": "Topic", "tail_type": "文本"}]}
{"text": "一是领域相关的问答系统，只回答与选定领域相关的问题。", "relation": [{"head": "领域相关的问答系统", "head_type": "知识问答", "relation": "作用", "tail": "只回答与选定领域相关的问题", "tail_type": "文本"}]}
{"text": "近年来，企业的智能客服通常采用领域相关的问答系统，并且逐步转向基于知识图谱的解决方案。", "relation": [{"head": "智能客服", "head_type": "知识问答", "relation": "由组成", "tail": "领域相关的问答系统", "tail_type": "知识问答"}]}
{"text": "二是领域无关的问答系统，基于开放知识库回答任意问题。", "relation": [{"head": "领域无关的问答系统", "head_type": "知识问答", "relation": "来源", "tail": "开放知识库回答任意问题", "tail_type": "知识问答"}]}
{"text": "开放域问答系统经常使用万维网数据（尤其是百科网站、社区问答等）作为数据源解答用户的问题。", "relation": [{"head": "开放问答系统数据源", "head_type": "知识问答", "relation": "来源", "tail": "万维网数据", "tail_type": "知识问答"}]}
{"text": "从知识库的信息组织格式来看，知识库可以是基于文本表示，也可以采用其他组织形式。", "relation": [{"head": "知识库", "head_type": "知识问答", "relation": "特点", "tail": "基于文本表示", "tail_type": "文本"}]}
{"text": "第一，文本类知识库利用纯文本承载知识，也是最常见的知识组织形式。", "relation": [{"head": "文本类知识库", "head_type": "知识问答", "relation": "特点", "tail": "利用纯文本承载知识", "tail_type": "文本"}]}
{"text": "电子表格、二维表或者关系数据库是最常见的结构化知识，实体和属性通过简单的二维表表示，大多数事实性客观问题都可以被此类知识解答。", "relation": [{"head": "电子表格", "head_type": "知识问答", "relation": "属于", "tail": "结构化知识", "tail_type": "知识问答"}, {"head": "二维表", "head_type": "知识问答", "relation": "属于", "tail": "结构化知识", "tail_type": "知识问答"}]}
{"text": "图数据库，例如RDF、属性图、语义网络等，将通过节点、有向边来形成基于图的知识组织，并且利用节点和边的名称与上下文对接自然语言处理并支持语义相似度计算，同时还能支持复杂的结构化图查询机制。", "relation": [{"head": "图数据库", "head_type": "知识问答", "relation": "包含", "tail": "基于图的知识组织", "tail_type": "知识问答"}, {"head": "图数据库", "head_type": "知识问答", "relation": "包含", "tail": "RDF", "tail_type": "知识问答"}, {"head": "图数据库", "head_type": "知识问答", "relation": "包含", "tail": "属性图", "tail_type": "知识问答"}, {"head": "图数据库", "head_type": "知识问答", "relation": "包含", "tail": "语义网络", "tail_type": "知识问答"}]}
{"text": "第四，知识库并不限定于文本、符号系统或多媒体，也可以利用可计算的机器学习模型承载。", "relation": [{"head": "知识库", "head_type": "知识问答", "relation": "来源", "tail": "机器学习模型", "tail_type": "知识问答"}]}
{"text": "例如近年来出现的端到端的问答系统可以直接使用分布式表示模型记录习得的知识。", "relation": [{"head": "端到端的问答系统", "head_type": "知识问答", "relation": "特点", "tail": "分布式表示模型记录习得的知识", "tail_type": "文本"}]}
{"text": "知识问答的知识可以采用单一的集中数据存储（例如数据表、数据库），或者分布式存储（例如分布式数据、数据仓库），甚至是基于互联网的全网数据（例如Linked_Data）。", "relation": [{"head": "数据表", "head_type": "知识问答", "relation": "属于", "tail": "单一的集中数据存储", "tail_type": "知识问答"}, {"head": "数据库", "head_type": "知识问答", "relation": "属于", "tail": "单一的集中数据存储", "tail_type": "知识问答"}, {"head": "分布式数据", "head_type": "知识问答", "relation": "属于", "tail": "分布式存储", "tail_type": "知识问答"}, {"head": "数据仓库", "head_type": "知识问答", "relation": "属于", "tail": "分布式存储", "tail_type": "知识问答"}]}
{"text": "根据知识库表示形式的不同，目前的知识问答可以分为传统问答方法（符号表示）以及基于深度学习的问答方法（分布式表示）两种类型。", "relation": [{"head": "知识问答", "head_type": "知识问答", "relation": "包含", "tail": "传统问答方法", "tail_type": "知识问答"}, {"head": "知识问答", "head_type": "知识问答", "relation": "包含", "tail": "基于深度学习的问答方法", "tail_type": "知识问答"}]}
{"text": "传统问答方法使用的主要技术包括关键词检索、文本蕴涵推理以及逻辑表达式等，深度学习方法使用的技术主要是LSTM[19]、注意力模型[20]与记忆网络（Memory_Network）[21]等。", "relation": [{"head": "传统问答方法主要技术", "head_type": "知识问答", "relation": "包含", "tail": "关键词检索", "tail_type": "知识问答"}, {"head": "传统问答方法主要技术", "head_type": "知识问答", "relation": "包含", "tail": "文本蕴涵推理", "tail_type": "知识问答"}, {"head": "传统问答方法主要技术", "head_type": "知识问答", "relation": "包含", "tail": "逻辑表达式", "tail_type": "知识问答"}, {"head": "深度学习方法", "head_type": "知识问答", "relation": "包含", "tail": "LSTM", "tail_type": "知识问答"}, {"head": "深度学习方法", "head_type": "知识问答", "relation": "包含", "tail": "注意力模型", "tail_type": "知识问答"}, {"head": "深度学习方法", "head_type": "知识问答", "relation": "包含", "tail": "记忆网络（Memory_Network）", "tail_type": "知识问答"}, {"head": "记忆网络", "head_type": "知识问答", "relation": "英文名", "tail": "Memory_Network", "tail_type": "文本"}]}
{"text": "传统的知识库问答将问答过程切分为语义解析与查询两个步骤。", "relation": [{"head": "传统的知识问答过程", "head_type": "知识问答", "relation": "包含", "tail": "语义解析", "tail_type": "知识问答"}, {"head": "传统的知识问答过程", "head_type": "知识问答", "relation": "包含", "tail": "查询", "tail_type": "知识问答"}]}
{"text": "不同于传统方法，基于分布式表示的知识库问答利用深度神经网络模型，将问题与知识库中的信息转化为向量表示，通过相似度匹配的方式完成问题与答案的匹配。", "relation": [{"head": "基于分布式表示的知识库问答", "head_type": "知识问答", "relation": "由组成", "tail": "深度神经网络模型", "tail_type": "知识问答"}, {"head": "基于分布式表示的知识库问答", "head_type": "知识问答", "relation": "目标", "tail": "将问题与知识库中的信息转化为向量表示，通过相似度匹配的方式完成问题与答案的匹配", "tail_type": "文本"}]}
{"text": "依据文献[23]的介绍，NLIDB系统大多采用的模块包括：①实体识别（Named_EntityRecognition），通过查询领域词典识别命名实体；②语义理解（Question2Query），利用语法解析（例如词性分析，Part-Of-Speech）、动词分析（包括主动和被动）以及语义映射规则等技术，将问题解析成语义查询语句；③回答问题（Answer_Processing），通常通过简单查询和其他复杂操作（例如Count）获取答案。", "relation": [{"head": "实体识别", "head_type": "知识问答", "relation": "英文名", "tail": "Named_EntityRecognition", "tail_type": "文本"}, {"head": "语义理解", "head_type": "知识问答", "relation": "英文名", "tail": "Question2Query", "tail_type": "文本"}, {"head": "回答问题", "head_type": "知识问答", "relation": "英文名", "tail": "Answer_Processing", "tail_type": "文本"}, {"head": "实体识别", "head_type": "知识问答", "relation": "目标", "tail": "通过查询领域词典识别命名实体", "tail_type": "文本"}, {"head": "语义理解", "head_type": "知识问答", "relation": "目标", "tail": "利用语法解析（例如词性分析，Part-Of-Speech）、动词分析（包括主动和被动）以及语义映射规则等技术，将问题解析成语义查询语句", "tail_type": "文本"}, {"head": "回答问题", "head_type": "知识问答", "relation": "目标", "tail": "通常通过简单查询和其他复杂操作（例如Count）获取答案", "tail_type": "文本"}]}
{"text": "图8-10早期NLIDB型问答系统的设计思想（1）基于模式匹配（Pattern-Matching）。", "relation": [{"head": "早期NLIDB型问答系统的设计思想（", "head_type": "知识问答", "relation": "包含", "tail": "基于模式匹配", "tail_type": "知识问答"}]}
{"text": "图8-11基于模板匹配的NLIDB解决方案[23]（2）基于语法解析（Syntactic-Parsing）。", "relation": [{"head": "早期NLIDB型问答系统的设计思想（", "head_type": "知识问答", "relation": "包含", "tail": "基于语法解析", "tail_type": "知识问答"}]}
{"text": "基于语法解析的语义理解将自然语言的复杂语义转化为逻辑表达式。", "relation": [{"head": "基于语法解析的语义理解", "head_type": "知识问答", "relation": "作用", "tail": "将自然语言的复杂语义转化为逻辑表达式", "tail_type": "文本"}]}
{"text": "有些系统甚至还可以允许用户通过交互界面添加新词汇和映射规制，包括LUNAR系统后期提出的MRL语言[23]，将自然语言问题转化为一种基于中间表示语言的逻辑查询表达式。", "relation": [{"head": "MRL语言", "head_type": "知识图谱项目", "relation": "创建者", "tail": "LUNAR系统", "tail_type": "人物/实验室"}]}
{"text": "这一类方案后来演进为KBQA中基于语义解析（Semantic_Parsing）的语义理解方法。", "relation": [{"head": "语义解析", "head_type": "知识问答", "relation": "英文名", "tail": "Semantic_Parsing", "tail_type": "文本"}]}
{"text": "语法树分析为处理更为复杂的问题以及简单问题的语法变形提供了便利，但是这也同时依赖语法分析工具的正确性（包括词性分析、语法依存分析）。", "relation": [{"head": "语法分析工具", "head_type": "知识问答", "relation": "包含", "tail": "词性分析", "tail_type": "知识问答"}, {"head": "语法分析工具", "head_type": "知识问答", "relation": "包含", "tail": "语法依存分析", "tail_type": "知识问答"}]}
{"text": "图8-12LUNAR系统利用语法树解析初步解析问题[23]8.3.2IRQA：基于信息检索的问答系统基于信息检索的问答系统（Information_Retrieval_based_Question-Answering_System,IRQA）[6]的核心思想是根据用户输入的问题，结合自然语言处理以及信息检索技术，在给定文档集合或者互联网网页中筛选出相关的文档，从结果文档内容抽取关键文本作为候选答案，最后对候选答案进行排序返回最优答案。", "relation": [{"head": "基于信息检索的问答系统", "head_type": "知识问答", "relation": "目标", "tail": "是根据用户输入的问题，结合自然语言处理以及信息检索技术，在给定文档集合或者互联网网页中筛选出相关的文档，从结果文档内容抽取关键文本作为候选答案，最后对候选答案进行排序返回最优答案", "tail_type": "文本"}, {"head": "基于信息检索的问答系统", "head_type": "知识问答", "relation": "英文名", "tail": "Information_Retrieval_based_Question-Answering_System,IRQA", "tail_type": "文本"}]}
{"text": "（2）段落检索与排序（Passage_Retrieval_And_Ranking）。", "relation": [{"head": "段落检索与排序", "head_type": "知识问答", "relation": "英文名", "tail": "Passage_Retrieval_And_Ranking", "tail_type": "文本"}]}
{"text": "（3）答案处理（Answer_Processing）。", "relation": [{"head": "答案处理", "head_type": "知识问答", "relation": "英文名", "tail": "Answer_Processing", "tail_type": "文本"}]}
{"text": "KBQA实际上是20世纪七八十年代对NLIDB工作的延续，其中很多技术都借鉴和沿用了以前的研究成果。", "relation": [{"head": "KBQA", "head_type": "知识图谱项目", "relation": "来源", "tail": "NLIDB工作", "tail_type": "知识问答"}]}
{"text": "KBQA的核心问题Question2Query是找到从用户问题到知识图谱子图的最合理映射。", "relation": [{"head": "Question2Query", "head_type": "知识问答", "relation": "属于", "tail": "KBQA的核心问题", "tail_type": "知识问答"}]}
{"text": "文献[14]分析了参与QALD的数十个问答系统，并从问题解析、词汇关联、歧义消解、构建查询以及分布式知识库五个阶段做了对比，而前四个问题都是Question2Query的关键步骤。", "relation": [{"head": "Question2Query步骤", "head_type": "知识问答", "relation": "包含", "tail": "问题解析", "tail_type": "知识问答"}, {"head": "Question2Query步骤", "head_type": "知识问答", "relation": "包含", "tail": "词汇关联", "tail_type": "知识问答"}, {"head": "Question2Query步骤", "head_type": "知识问答", "relation": "包含", "tail": "歧义消解", "tail_type": "知识问答"}, {"head": "Question2Query步骤", "head_type": "知识问答", "relation": "包含", "tail": "构建查询", "tail_type": "知识问答"}, {"head": "Question2Query步骤", "head_type": "知识问答", "relation": "包含", "tail": "分布式知识库", "tail_type": "知识问答"}]}
{"text": "知识图谱通常可以为NLP工具提供领域词典，支持实体链接；同时，知识图谱的实体和关系也可以分别用于序列化标注和远程监督，支持对文本领域语料的结构化抽取，进一步增补领域知识图谱。", "relation": [{"head": "知识图谱", "head_type": "知识问答", "relation": "作用", "tail": "NLP工具提供领域词典，支持实体链接", "tail_type": "文本"}, {"head": "知识图谱的关系", "head_type": "知识问答", "relation": "作用", "tail": "支持对文本领域语料的结构化抽取", "tail_type": "文本"}, {"head": "知识图谱的实体", "head_type": "知识问答", "relation": "作用", "tail": "序列化标注和远程监督", "tail_type": "文本"}]}
{"text": "QALD的大多系统使用SPARQL表达查询。", "relation": [{"head": "QALD", "head_type": "知识问答", "relation": "来源", "tail": "SPARQL表达查询", "tail_type": "知识问答"}]}
{"text": "8.3.4CommunityQA/FAQ-QA：基于问答对匹配的问答系统基于常见问答对（Frequently_Asked_Question,FAQ-QA[24]）以及社区问答（Community_Question_Answering,CQA）[25]都依赖搜索问答FAQ库（许多问答对<Q,A>的集合）来发现以前问过的类似问题，并将找到的问答对的答案返回给用户。", "relation": [{"head": "基于常见问答对", "head_type": "知识问答", "relation": "英文名", "tail": "Frequently_Asked_Question,FAQ-QA", "tail_type": "文本"}, {"head": "社区问答", "head_type": "知识问答", "relation": "英文名", "tail": "Community_Question_Answering,CQA", "tail_type": "文本"}]}
{"text": "FAQ与CQA都是以问答对来组织知识，而且问答对的质量很高，不但已经是自然语言格式，而且受到领域专家或者社区的认可。", "relation": [{"head": "FAQ", "head_type": "知识问答", "relation": "由组成", "tail": "问答式知识问答", "tail_type": "知识问答"}, {"head": "CQA", "head_type": "知识问答", "relation": "由组成", "tail": "问答式知识问答", "tail_type": "知识问答"}]}
{"text": "重复问题发现（DuplicateQuestion_Detection,DQD）仅限于疑问句，这是短文本相似度计算的一个特例。", "relation": [{"head": "重复问题发现", "head_type": "知识问答", "relation": "特点", "tail": "短文本相似度计算的一个特例", "tail_type": "文本"}, {"head": "短文本相似度计算", "head_type": "知识问答", "relation": "英文名", "tail": "DuplicateQuestion_Detection", "tail_type": "文本"}]}
{"text": "事实上，语义相似性面临两个挑战：（1）“泛化”。", "relation": [{"head": "语义相似性面临两个挑战", "head_type": "知识问答", "relation": "包含", "tail": "语义相似性面临两个挑战", "tail_type": "知识问答"}]}
{"text": "一种类型的方法试图通过利用语义词典（例如WordNet）计算词汇相似度，这些语义相似网络来自语言学家的经验总结，受限于特定的语言；另一种方法将此任务作为统计机器翻译问题处理，并采用平行语料学习逐字或短语翻译概率，这种方法需要大量的平行问题集学习翻译概率，通常很难或成本高昂。", "relation": [{"head": "计算词汇相似度", "head_type": "知识问答", "relation": "来源", "tail": "语义词典", "tail_type": "知识问答"}]}
{"text": "Rodrigues_J_A等人[26]基于两个测试数据集（AskUbnuntu领域相关问题集，和Quora领域无关）对比了基于规则（JCRD_Jacard）、基于传统机器学习以及基于深度学习的方法。", "relation": [{"head": "AskUbnuntu领域相关问题集", "head_type": "知识图谱项目", "relation": "创建者", "tail": "Rodrigues_J_A等人", "tail_type": "文本"}]}
{"text": "1.DeepQA:IRQA主导的混合框架如图8-14所示的DeepQA[28]综合IRQA和KBQA形成混合问答系统的架构图，Watson系统的问题处理大致分成四阶段：图8-14DeepQA综合IRQA和KBQA形成混合问答系统的架构图[13]（1）问题处理（Question_Processing）。", "relation": [{"head": "Watson系统的问题处理", "head_type": "知识图谱项目", "relation": "包含", "tail": "问题处理", "tail_type": "知识问答"}, {"head": "问题处理", "head_type": "知识问答", "relation": "英文名", "tail": "Question_Processing", "tail_type": "文本"}]}
{"text": "（3）候选答案评分（Candidate_Answer_Scoring）。", "relation": [{"head": "候选答案评分", "head_type": "知识问答", "relation": "英文名", "tail": "Candidate_Answer_Scoring", "tail_type": "文本"}]}
{"text": "（4）答案融合及排序（Confidence_Merging_And_Ranking）。", "relation": [{"head": "答案融合及排序", "head_type": "知识问答", "relation": "英文名", "tail": "Confidence_Merging_And_Ranking", "tail_type": "文本"}]}
{"text": "首先把相同的答案进行融合（例如两个候选人名_J.F.K.和_John_F.Kemedy_会被合并成为一个候选答案），形成新的答案候选集，然后对新的答案候选集进行再排序，最终由训练好的逻辑回归分类器模型对每个候选答案计算置信度，并返回置信度最高的答案作为最终答案。", "relation": [{"head": "新的答案候选集", "head_type": "知识问答", "relation": "来源", "tail": "答案进行融合", "tail_type": "知识问答"}, {"head": "最终答案", "head_type": "知识问答", "relation": "来源", "tail": "候选答案计算置信度", "tail_type": "知识问答"}]}
{"text": "2.QALD-Hybrid-QA:KBQA主导的混合框架在QALD-6启动的Hybrid_QA要求KBQA可以同时利用知识图谱数据和文本数据。", "relation": [{"head": "KBQA", "head_type": "知识问答", "relation": "目标", "tail": "同时利用知识图谱数据和文本数据。", "tail_type": "文本"}]}
{"text": "自然语言先转化为SPARQL查询，但是并非所有SPARQL查询中的三元组特征（TriplePattern）都可以对应到知识图谱中的词汇，也并非所有知识都可以从掌握的知识图谱中查到，有一部分知识还需要从文档中抽取关系得到解答。", "relation": [{"head": "知识", "head_type": "知识问答", "relation": "来源", "tail": "文档中抽取关系", "tail_type": "知识问答"}, {"head": "三元组特征", "head_type": "知识问答", "relation": "英文名", "tail": "TriplePattern", "tail_type": "文本"}]}
{"text": "注意，在OpenIE抽取的三元组中，大量谓语predicate是没有经过归一融合的。", "relation": [{"head": "谓语predicate", "head_type": "知识问答", "relation": "目标", "tail": "归一融合", "tail_type": "文本"}]}
{"text": "然后利用平行语料模型将问句中的关系映射到抽取三元组的谓语上。", "relation": [{"head": "平行语料模型", "head_type": "知识问答", "relation": "目标", "tail": "将问句中的关系映射到抽取三元组的谓语上", "tail_type": "文本"}]}
{"text": "模块化的流水线设计有利于将复杂的QA系统分解为细粒度可优化的部分，而且形成了可插拔的体系，便于系统优化更新。", "relation": [{"head": "模块化的流水线", "head_type": "知识问答", "relation": "作用", "tail": "将复杂的QA系统分解为细粒度可优化的部分，而且形成了可插拔的体系，便于系统优化更新", "tail_type": "文本"}]}
{"text": "这个框架首先制定了一个可配置的流水线框架，并且分解出KBQA的四个主要模块：的知识库以及通用的RDF图8-16问答系统流水线的架构[32]（1）命名实体识别与消解歧义（Named_Entity_Disambiguation,NED）。", "relation": [{"head": "KBQA的四个主要模块", "head_type": "知识问答", "relation": "包含", "tail": "命名实体识别与消解歧义", "tail_type": "知识问答"}, {"head": "命名实体识别与消解歧义", "head_type": "知识问答", "relation": "英文名", "tail": "Named_Entity_Disambiguation,NED", "tail_type": "文本"}]}
{"text": "（2）实体关系映射（Relation_Linking,RL）。", "relation": [{"head": "实体关系映射", "head_type": "知识问答", "relation": "英文名", "tail": "Relation_Linking", "tail_type": "文本"}]}
{"text": "（3）实体分类映射（Class_Linking,CL）。", "relation": [{"head": "实体分类映射", "head_type": "知识问答", "relation": "英文名", "tail": "Class_Linking,CL", "tail_type": "文本"}]}
{"text": "（4）构建查询（Query_Building,QB）。", "relation": [{"head": "构建查询", "head_type": "知识问答", "relation": "英文名", "tail": "Query_Building,QB", "tail_type": "文本"}]}
{"text": "同时，框架也利用分类器技术（QA_Pipeline_Classifier）支持流水线自动配置，也就是说从29个不同的模块（18个NED、5个RL、2个CL、2个QB），针对每一个特定的KBQA问答系统选取最优的流水线组合。", "relation": [{"head": "分类器技术", "head_type": "知识问答", "relation": "作用", "tail": "支持流水线自动配置", "tail_type": "文本"}, {"head": "分类器技术", "head_type": "知识问答", "relation": "英文名", "tail": "QA_Pipeline_Classifier", "tail_type": "文本"}]}
{"text": "问答系统的功能评价重点关注返回的答案，正确的答案应当同时具备正确度及完备度，正确但内容不完整的答案被称为不准确答案，没有足够证据及论证表明答案与问题相关性的则是无支撑答案，当答案与问题完全无关时，意味着答案是错误的。", "relation": [{"head": "问答系统的功能评价", "head_type": "知识问答", "relation": "内容", "tail": "通过一组预定的测试问题集以及一组预定的维度来评价", "tail_type": "文本"}]}
{"text": "答案评价通常可以从如下角度考虑：（1）正确性。", "relation": [{"head": "答案评价", "head_type": "知识问答", "relation": "内容", "tail": "正确性", "tail_type": "文本"}]}
{"text": "答案质量由人工评分，很多非事实性问题并非一个唯一的答案，所以需要人工判定答案的质量。", "relation": [{"head": "非事实性问题", "head_type": "知识问答", "relation": "特点", "tail": "并非一个唯一的答案", "tail_type": "文本"}]}
{"text": "除了上述针对答案的评价，也有针对解答过程复杂程度的评价，例如Semantic_Tractability[33]，用于反映问答之间的词表差异性；AnswerLocality[34]，答案是否零碎地分布在不同的文本或数据集录中；Derivability34，问题的答案是否是某种确定性答案，还是含蓄的、不确定的描述；Semantic_Complexity，问题涉及的语义复杂程度。", "relation": [{"head": "Semantic_Tractability", "head_type": "知识问答", "relation": "作用", "tail": "问答之间的词表差异性", "tail_type": "文本"}, {"head": "AnswerLocality", "head_type": "知识问答", "relation": "作用", "tail": "答案是否零碎地分布在不同的文本或数据集录中", "tail_type": "文本"}, {"head": "Derivability", "head_type": "知识问答", "relation": "作用", "tail": "问题的答案是否是某种确定性答案", "tail_type": "文本"}, {"head": "Semantic_Complexity", "head_type": "知识问答", "relation": "作用", "tail": "问题涉及的语义复杂程度", "tail_type": "文本"}]}
{"text": "常用的问答指标采用F1（综合正确率和召回率）和P@1（第一个答案是否正确的比率）。", "relation": [{"head": "F1", "head_type": "知识问答", "relation": "内容", "tail": "综合正确率和召回率", "tail_type": "文本"}, {"head": "P@1", "head_type": "知识问答", "relation": "内容", "tail": "第一个答案是否正确的比率", "tail_type": "文本"}]}
{"text": "2.性能评价指标除了功能评价指标，参考UsbeckR等人[35]的评价体系，问答系统从性能角度可以考虑如下指标：（1）问答系统的响应时间（Response_Time）。", "relation": [{"head": "问答系统性能评价指标", "head_type": "知识问答", "relation": "包含", "tail": "问答系统的响应时间", "tail_type": "知识问答"}, {"head": "问答系统的响应时间", "head_type": "知识问答", "relation": "英文名", "tail": "Response_Time", "tail_type": "文本"}]}
{"text": "8.4.2问答系统的评价数据集1.TREC_QA：评价IRQATREC_QA[36]是美国标准计量局在1999—2007年针对问答系统设定的年度评价体系，本文关注其问答的核心任务（MAIN_TASK）。", "relation": [{"head": "TREC_QA", "head_type": "知识图谱项目", "relation": "内容", "tail": "美国标准计量局在1999—2007年针对问答系统设定的年度评价体系，本文关注其问答的核心任务（MAIN_TASK）", "tail_type": "文本"}]}
{"text": "评价方法主要是选取大约1000个测试问题，由1～3人标注评价答案的正确性（答案是否正确回答了问题）、精准度（答案中是否包含多余的内容）以及对应文章的支持度（对应的文章是否支持该答案）。", "relation": [{"head": "正确性", "head_type": "知识问答", "relation": "内容", "tail": "答案是否正确回答了问题", "tail_type": "文本"}, {"head": "精准度", "head_type": "知识问答", "relation": "内容", "tail": "答案中是否包含多余的内容", "tail_type": "文本"}, {"head": "支持度", "head_type": "知识问答", "relation": "内容", "tail": "对应的文章是否支持该答案", "tail_type": "文本"}]}
{"text": "2.TREC_LIVE_QA：评价CQA社区问答TREC_LIVE_QA也[37]是美国标准计量局在2015—2107年从更真实的网络问答出发，主要面向CQA社区问答解决方案的评价体系。", "relation": [{"head": "TREC_LIVE_QA", "head_type": "知识图谱项目", "relation": "创建者", "tail": "美国标准计量局", "tail_type": "文本"}]}
{"text": "3.QALD：评价KBQAQALD[38]是指2011—2017年的链接数据的问答系统评测（Question_Answering_onLinked_Data），为自然语言问题转化为可用的SPARQL查询以及基于语义万维网标准的知识推理提供了一系列的评价体系和测试数据集，对QALD的工作做了详细介绍。", "relation": [{"head": "QALD", "head_type": "知识问答", "relation": "内容", "tail": "2011—2017年的链接数据的问答系统评测（Question_Answering_onLinked_Data），为自然语言问题转化为可用的SPARQL查询以及基于语义万维网标准的知识推理提供了一系列的评价体系和测试数据集，对QALD的工作做了详细介绍", "tail_type": "文本"}]}
{"text": "QALD的主要任务如下：给定知识库（一个或多个RDF数据集以及其他知识源）和问题（自然语言问题或关键字），返回正确的答案或返回这些答案的SPARQL查询。", "relation": [{"head": "QALD", "head_type": "知识问答", "relation": "目标", "tail": "给定知识库（一个或多个RDF数据集以及其他知识源）和问题（自然语言问题或关键字），返回正确的答案或返回这些答案的SPARQL查询", "tail_type": "文本"}]}
{"text": "4.SQuAD：评价端到端的问答系统解决方案SQuAD[39]是斯坦福大学推出的一个大规模阅读理解数据集，由众多维基百科文章中的众包工作者提出的问题构成，每个问题的答案都是相应阅读段落的一段文字或跨度。", "relation": [{"head": "SQuAD", "head_type": "知识图谱项目", "relation": "创建者", "tail": "斯坦福大学", "tail_type": "文本"}]}
{"text": "SQuAD评价指标主要分两部分：（1）精准匹配。", "relation": [{"head": "SQuAD评价指标", "head_type": "知识问答", "relation": "内容", "tail": "精准匹配", "tail_type": "文本"}]}
{"text": "在此之前，斯坦福大学还发布过Web_Question数据集[41]。", "relation": [{"head": "Web_Question", "head_type": "知识图谱项目", "relation": "创建者", "tail": "斯坦福大学", "tail_type": "文本"}]}
{"text": "在Web_Questions数据集上的F1值为31.3%，后续不少研究者在Web_Questions提出了一些新Jain提出的Factual的有效模型，F1值逐年更新。", "relation": [{"head": "Factual的有效模型", "head_type": "知识问答", "relation": "来源", "tail": "Web_Questions", "tail_type": "知识问答"}]}
{"text": "5.Quora_QA：评价问题相似度计算Quora于2017年在Kaggle发布的数据集包含约40万个问题对，每个问题包含两个问题ID和原始文本，另外还有一个数字标记这两个问题是否等价，即对应到同一个意图的上。", "relation": [{"head": "Quora", "head_type": "知识图谱项目", "relation": "创建时间", "tail": "2017年", "tail_type": "文本"}, {"head": "Quora", "head_type": "知识图谱项目", "relation": "作用", "tail": "评价问题相似度计算", "tail_type": "文本"}]}
{"text": "6.SemEval：词义消歧评测SemEval是由ACL词汇与语义小组组织的词汇与语义计算领域的国际权威技术竞赛。", "relation": [{"head": "词义消歧评测SemEval", "head_type": "知识图谱项目", "relation": "创建者", "tail": "ACL词汇与语义小组", "tail_type": "文本"}]}
{"text": "从1998年开始举办，竞赛包括多方面不同的词汇语义评测任务，如文本语义相似度计算、推特语义分析、空间角色标注、组合名词的自由复述、文本蕴涵识别、多语种的词义消歧等。", "relation": [{"head": "词汇语义评测任务", "head_type": "知识问答", "relation": "内容", "tail": "推特语义分析任务", "tail_type": "文本"}, {"head": "词汇语义评测任务", "head_type": "知识问答", "relation": "内容", "tail": "空间角色标注任务", "tail_type": "文本"}, {"head": "词汇语义评测任务", "head_type": "知识问答", "relation": "内容", "tail": "组合名词的自由复述任务", "tail_type": "文本"}, {"head": "词汇语义评测任务", "head_type": "知识问答", "relation": "内容", "tail": "文本蕴涵识别任务", "tail_type": "文本"}, {"head": "词汇语义评测任务", "head_type": "知识问答", "relation": "内容", "tail": "多语种的词义消歧任务", "tail_type": "文本"}, {"head": "词汇语义评测任务", "head_type": "知识问答", "relation": "内容", "tail": "文本语义相似度计算", "tail_type": "文本"}]}
{"text": "分析的定位包括情感分析（情感的强弱、喜怒哀乐等类型的判断、情绪的积极消极以及识别推文中涵盖的多个情感类型）、符号预测（预测推文中可能嵌入的表情图片或颜文字）、反讽语义识别（识别推文中的讽刺表达）。", "relation": [{"head": "情感分析", "head_type": "知识问答", "relation": "内容", "tail": "情感的强弱、喜怒哀乐等类型的判断、情绪的积极消极以及识别推文中涵盖的多个情感类型", "tail_type": "文本"}, {"head": "符号预测", "head_type": "知识问答", "relation": "内容", "tail": "预测推文中可能嵌入的表情图片或颜文字", "tail_type": "文本"}, {"head": "反讽语义识别", "head_type": "知识问答", "relation": "内容", "tail": "识别推文中的讽刺表达", "tail_type": "文本"}]}
{"text": "一个子任务是多人对话中的人物识别，目标是识别对话中提及的所有人物。", "relation": [{"head": "人物识别", "head_type": "知识问答", "relation": "目标", "tail": "识别对话中提及的所有人物", "tail_type": "文本"}]}
{"text": "另一个子任务则是面向事件的识别以及分析，针对给定的问题，从给定文本中找出问题相关的一个事件或多个事件，以及参与角色之间的关系。", "relation": [{"head": "面向事件的识别以及分析", "head_type": "知识问答", "relation": "目标", "tail": "针对给定的问题，从给定文本中找出问题相关的一个事件或多个事件，以及参与角色之间的关系", "tail_type": "文本"}]}
{"text": "该部分介绍的信息抽取包含关系（关系抽取与分类）、时间（基于语义分析的时间标准化）等。", "relation": [{"head": "关系", "head_type": "知识问答", "relation": "内容", "tail": "关系抽取与分类", "tail_type": "文本"}]}
{"text": "一个困难是现有的自然语言理解技术在处理自然语言的歧义性和复杂性方面还显得比较薄弱。", "relation": [{"head": "自然语言理解技术", "head_type": "知识问答", "relation": "内容", "tail": "处理自然语言的歧义性和复杂性方面还显得比较薄弱", "tail_type": "文本"}]}
{"text": "通常还需要定义一个世界模型（World_Model），来指定词典或本体中词汇的上下位关系和关系参数类型的限制。", "relation": [{"head": "世界模型", "head_type": "知识问答", "relation": "英文名", "tail": "World_Model", "tail_type": "文本"}, {"head": "世界模型", "head_type": "知识问答", "relation": "目标", "tail": "指定词典或本体中词汇的上下位关系和关系参数类型的限制", "tail_type": "文本"}]}
{"text": "这个过程中的主要挑战在于如何将自然语言表达映射到知识库的查询，也就是Question2Query语义理解。", "relation": [{"head": "自然语言表达映射到知识库的查询", "head_type": "知识问答", "relation": "等价", "tail": "Question2Query语义理解", "tail_type": "知识问答"}]}
{"text": "图8-20问题到答案的映射过程1.多样的概念映射机制也就是将自然语言表达的查询语义映射知识库的原子查询。", "relation": [{"head": "多样的概念映射机制", "head_type": "知识问答", "relation": "被定义为", "tail": "将自然语言表达的查询语义映射知识库的原子查询", "tail_type": "文本"}]}
{"text": "泛化问题通常可以从词语和句子两个层面来研究。", "relation": [{"head": "泛化问题", "head_type": "知识问答", "relation": "方法", "tail": "词语和句子两个层面来研究", "tail_type": "文本"}]}
{"text": "例如“还活着吗”对应“死亡日期”，这样的平行语料学习不但可以通过基于知识图谱的关系抽取结果来充实，也可以利用深度学习的分布式表示Embedding来计算。", "relation": [{"head": "平行语料学习", "head_type": "知识问答", "relation": "方法", "tail": "基于知识图谱的关系抽取结果", "tail_type": "文本"}, {"head": "平行语料学习", "head_type": "知识问答", "relation": "方法", "tail": "度学习的分布式表示Embedding", "tail_type": "文本"}]}
{"text": "主要是判断问题的语义相似度（Question-QuestionSimilarity）[44]，常用思路通常采用语言模型、机器翻译模型、句子主题分析模型、句子结构相似度分析模型、基于知识图谱的句子成分相似度模型等，SemEval的Task1和Task3_SubTaskB[45]都对这一方面的关键技术做了评测。", "relation": [{"head": "问题的语义相似度", "head_type": "知识问答", "relation": "英文名", "tail": "Question-QuestionSimilarity", "tail_type": "文本"}, {"head": "问题的语义相似度", "head_type": "知识问答", "relation": "方法", "tail": "语言模型", "tail_type": "文本"}, {"head": "问题的语义相似度", "head_type": "知识问答", "relation": "方法", "tail": "机器翻译模型", "tail_type": "文本"}, {"head": "问题的语义相似度", "head_type": "知识问答", "relation": "方法", "tail": "句子主题分析模型", "tail_type": "文本"}, {"head": "问题的语义相似度", "head_type": "知识问答", "relation": "方法", "tail": "句子结构相似度分析模型", "tail_type": "文本"}, {"head": "问题的语义相似度", "head_type": "知识问答", "relation": "方法", "tail": "基于知识图谱的句子成分相似度模型等，", "tail_type": "文本"}]}
{"text": "8.5.2基于模板的方法基于模板（Template）或模式（Pattern）的问答系统定义了一组带变量的模板，直接匹配问题文本形成查询表达式。", "relation": [{"head": "模板", "head_type": "知识问答", "relation": "英文名", "tail": "Template", "tail_type": "文本"}, {"head": "模式", "head_type": "知识问答", "relation": "英文名", "tail": "Pattern", "tail_type": "文本"}, {"head": "基于模板（Template）或模式（Pattern）的问答系统", "head_type": "知识问答", "relation": "作用", "tail": "定义了一组带变量的模板，直接匹配问题文本形成查询表达式", "tail_type": "文本"}]}
{"text": "TBSL中的模板定义为SPARQL查询模板。", "relation": [{"head": "TBSL方模板", "head_type": "知识问答", "relation": "被定义为", "tail": "SPARQL查询模板", "tail_type": "知识问答"}]}
{"text": "图8-22典型的TBSL框架流程TBSL方法有两个重要的步骤：模板生成和模板实例化。", "relation": [{"head": "TBSL方法", "head_type": "知识问答", "relation": "包含", "tail": "模板生成", "tail_type": "知识问答"}, {"head": "TBSL方法", "head_type": "知识问答", "relation": "包含", "tail": "模板实例化", "tail_type": "知识问答"}]}
{"text": "因此，TBSL就查询模板的排序也提出了一种方法：首先，每个实体根据字符串相似度以及显著度获得一个打分；其次，根据填充槽的多个实体的平均打分得到一个查询模板的分值。", "relation": [{"head": "查询模板的排序", "head_type": "知识问答", "relation": "方法", "tail": "每个实体根据字符串相似度以及显著度获得一个打分", "tail_type": "文本"}, {"head": "查询模板的排序", "head_type": "知识问答", "relation": "方法", "tail": "根据填充槽的多个实体的平均打分得到一个查询模板的分值", "tail_type": "文本"}]}
{"text": "模板实例化步骤将自然语言问句与知识库中的本体概念建立映射。", "relation": [{"head": "模板实例化步骤", "head_type": "知识问答", "relation": "作用", "tail": "将自然语言问句与知识库中的本体概念建立映射", "tail_type": "文本"}]}
{"text": "对于Resources和Classes，实体识别的常用方法主要有两点，一是用WordNet定义知识库中标签的同义词，二是计算字符串间的相似度。", "relation": [{"head": "实体识别", "head_type": "知识问答", "relation": "方法", "tail": "用WordNet定义知识库中标签的同义词", "tail_type": "文本"}, {"head": "实体识别", "head_type": "知识问答", "relation": "方法", "tail": "计算字符串间的相似度", "tail_type": "文本"}]}
{"text": "离线过程（Offline_Procedure）侧重基于问题生成模板。", "relation": [{"head": "离线过程", "head_type": "知识问答", "relation": "英文名", "tail": "Offline_Procedure", "tail_type": "文本"}, {"head": "离线过程", "head_type": "知识问答", "relation": "方法", "tail": "侧重基于问题生成模板", "tail_type": "文本"}]}
{"text": "离线过程采用E-M方法计算条件概率分布P（p|t）,p为属性，t为模板。", "relation": [{"head": "离线过程", "head_type": "知识问答", "relation": "方法", "tail": "E-M方法计算条件概率分布P（p|t）,p为属性，t为模板", "tail_type": "文本"}]}
{"text": "在线过程（Online_Procedure）侧重模板选择。", "relation": [{"head": "在线过程", "head_type": "知识问答", "relation": "英文名", "tail": "Online_Procedure", "tail_type": "文本"}, {"head": "在线过程", "head_type": "知识问答", "relation": "方法", "tail": "侧重模板选择", "tail_type": "文本"}]}
{"text": "总的来说，基于模板方法的优点是模板查询的响应速度快、准确率较高，可以回答相对复杂的复合问题，而缺点是模板结构通常无法与真实的用户问题相匹配。", "relation": [{"head": "基于模板方法", "head_type": "知识问答", "relation": "特点", "tail": "响应速度快、准确率较高，可以回答相对复杂的复合问题", "tail_type": "文本"}, {"head": "基于模板方法", "head_type": "知识问答", "relation": "特点", "tail": "模板结构通常无法与真实的用户问题相匹配", "tail_type": "文本"}]}
{"text": "8.5.3基于语义解析的方法基于语义解析的方法是指通过对自然语言查询的语法分析，将查询转换成逻辑表达式，然后利用知识库的语义信息将逻辑表达式转换成知识库查询，最终通过查询知识库得到查询结果。", "relation": [{"head": "基于语义解析的方法", "head_type": "知识问答", "relation": "被定义为", "tail": "通过对自然语言查询的语法分析，将查询转换成逻辑表达式，然后利用知识库的语义信息将逻辑表达式转换成知识库查询，最终通过查询知识库得到查询结果", "tail_type": "文本"}]}
{"text": "逻辑表达式是面向知识库的结构化查询，用于查找知识库中的实体及实体关系等知识。", "relation": [{"head": "逻辑表达式", "head_type": "知识问答", "relation": "作用", "tail": "面向知识库的结构化查询，用于查找知识库中的实体及实体关系等知识", "tail_type": "文本"}]}
{"text": "相比于模板预先生成且固定的表达方式，逻辑表达式作为人工智能知识表示的经典传承，具备更完备、灵活的知识查询生成体系，包括带参数的原子逻辑表达式，以及基于操作组合的复杂逻辑表达式。", "relation": [{"head": "逻辑表达式", "head_type": "知识问答", "relation": "特点", "tail": "具备更完备、灵活的知识查询生成体系，包括带参数的原子逻辑表达式，以及基于操作组合的复杂逻辑表达式", "tail_type": "文本"}]}
{"text": "原子级别的逻辑表达式通常可分为一元形式（unary）与二元形式（binary），其中一元形式匹配知识库中的实体，二元形式匹配实体之间的二元关系。", "relation": [{"head": "原子级别的逻辑表达式", "head_type": "知识问答", "relation": "包含", "tail": "一元形式", "tail_type": "知识问答"}, {"head": "原子级别的逻辑表达式", "head_type": "知识问答", "relation": "包含", "tail": "二元形式", "tail_type": "知识问答"}, {"head": "一元形式", "head_type": "知识问答", "relation": "英文名", "tail": "unary", "tail_type": "文本"}, {"head": "二元形式", "head_type": "知识问答", "relation": "英文名", "tail": "binary", "tail_type": "文本"}]}
